<#META GENERATOR = AnotherECS.Editor.Generator.FStringGenerator FILENAME = FString.cs#>

// <auto-generated>
// This source code was auto-generated by FStringGenerator.cs
// </auto-generated>

using System;
using System.Collections;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using System.Text;

namespace AnotherECS.Collections
{
<#ARRAY [0..STRUCT_COUNT]#>
    public unsafe struct FString<#ELEMENT_COUNT#> : IEquatable<FString<#ELEMENT_COUNT#>>, IEnumerable<char>
    {
        public const int Capacity = <#ELEMENT_COUNT#>;

        public int Length
            => _length;

        private ushort _length;
        private fixed char _data[<#ELEMENT_COUNT#>];


        public FString<#ELEMENT_COUNT#>(string text)
        {
            if (text.Length > Capacity)
            {
                throw new ArgumentException($"{nameof(text)} is longer than ñapacity. Capacity: '{Capacity}'. text length '{text.Length}'");
            }

            for (int i = 0; i < text.Length; ++i)
            {
                _data[i] = text[i];
            }
            _length = (ushort)text.Length;
        }

        public static implicit operator string(FString<#ELEMENT_COUNT#> fstring) => fstring.ToString();
        public static explicit operator FString<#ELEMENT_COUNT#>(string text) => new(text);

        public static FString<#ELEMENT_COUNT#> operator +(FString<#ELEMENT_COUNT#> a, FString<#ELEMENT_COUNT#> b)
        {
            if (a.Length + b.Length > Capacity)
            {
                throw new OverflowException();
            }

            FString<#ELEMENT_COUNT#> result = default;
            for(int i = 0; i < a.Length; ++i)
            {
                result._data[i] = a._data[i];
            }

            var offset = a.Length;
            for (int i = 0; i < b.Length; ++i)
            {
                result._data[i + offset] = b._data[i];
            }
            result._length = (ushort)(a.Length + b.Length);

            return result;
        }

        public static bool operator ==(FString<#ELEMENT_COUNT#> a, FString<#ELEMENT_COUNT#> b)
            => a.Equals(ref b);
        public static bool operator !=(FString<#ELEMENT_COUNT#> a, FString<#ELEMENT_COUNT#> b)
            => !a.Equals(ref b);

        public char this[int index]
        {
            get
            {
                if (index < 0 || index >= _length)
                {
                    throw new IndexOutOfRangeException();
                }
                return _data[index];
            }
            set
            {
                if (index < 0 || index >= _length)
                {
                    throw new IndexOutOfRangeException();
                }

                _data[index] = value;
            }
        }

        public override string ToString()
        {
#pragma warning disable CS0162
            if (Capacity <= 16)
            {
                var text = string.Empty;
                for (int i = 0; i < Length; ++i)
                {
                    text += _data[i];
                }
                return text;
            }
            else
            {
                var stringBuilder = new StringBuilder();
                for (int i = 0; i < Length; ++i)
                {
                    stringBuilder.Append(_data[i]);
                }
                return stringBuilder.ToString();
#pragma warning restore CS0162
            }
        }

        public override bool Equals(object obj)
        {
            if (obj is FString<#ELEMENT_COUNT#> fString)
            {
                return Equals(fString);
            }
            return false;
        }

        public bool Equals(FString<#ELEMENT_COUNT#> other)
            => Equals(ref other);

        public bool Equals(ref FString<#ELEMENT_COUNT#> other)
        {
            if (_length == other._length)
            {
                for (int i = 0; i < _length; ++i)
                {
                    if (_data[i] != other._data[i])
                    {
                        return false;
                    }
                }
                return true;
            }
            return false;
        }

        public override int GetHashCode()
        {
            var hash = new HashCode();
            hash.Add(_length);
            for(int i = 0; i < _length; ++i)
            {
                hash.Add(_data[i]);
            }

            return hash.ToHashCode();
        }

        public IEnumerator<char> GetEnumerator()
            => new Enumerator(ref this);

        IEnumerator IEnumerable.GetEnumerator()
            => GetEnumerator();


        public struct Enumerator : IEnumerator<char>
        {
            private readonly FString<#ELEMENT_COUNT#> _data;
            private int _current;

            public Enumerator(ref FString<#ELEMENT_COUNT#> data)
            {
                _data = data;
                _current = -1;
            }

            public char Current
            {
                [MethodImpl(MethodImplOptions.AggressiveInlining)]
                get => _data[_current];
            }

            object IEnumerator.Current
                => _data[_current];

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public bool MoveNext()
                => ++_current < _data.Length;

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public void Reset()
            {
                _current = -1;
            }

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public void Dispose() { }
        }
    }
<#END#>
}
