<#META GENERATOR = AnotherECS.Generator.CommonGenericGenerator FILENAME = FilterExtensions.cs N = 8#>

// <auto-generated>
// This source code was auto-generated by CommonGenericGenerator.cs
// </auto-generated>


using AnotherECS.Core;
using Unity.Jobs;
using EntityId = System.UInt32;

namespace AnotherECS.Unity.Jobs
{
    public unsafe static class FilterExtensions
    {
		internal unsafe static class BagJobFactory
		{
<#ARRAY [0..STRUCT_COUNT]#>
			public static JobBag<<#ARRAY [0..GENERIC_COUNT]#>T<#INDEX1#><#SEPARATOR1:,#><#END#>> Create<<#ARRAY [0..GENERIC_COUNT]#>T<#INDEX1#><#SEPARATOR1:,#><#END#>>(Filter<<#ARRAY [0..GENERIC_COUNT]#>T<#INDEX1#><#SEPARATOR1:,#><#END#>> filter)
---<#ARRAY [0..GENERIC_COUNT]#>
				where T<#INDEX1#> : unmanaged, IComponent
---<#END#>
			{
				var state = filter.GetState();
				var filterData = filter.GetFilterData();
				var handles = state.GetModuleData<NativeArrayHandles>(NativeArrayHandles.USER_DATA_ID);

				JobBag<<#ARRAY [0..GENERIC_COUNT]#>T<#INDEX1#><#SEPARATOR1:,#><#END#>> bag;
---<#ARRAY [0..GENERIC_COUNT]#>
				bag.indexes = handles.GetNativeArray<T<#INDEX1#>, EntityId>(0, filterData->GetEntities());
				bag.count = (int)filterData->entityCount;
				bag.sparse<#INDEX1#> = handles.GetNativeArray<T<#INDEX1#>, ushort>(1, state.GetSparse<T<#INDEX1#>, ushort>());
				bag.component<#INDEX1#> = handles.GetNativeArray<T<#INDEX1#>, T<#INDEX1#>>(2, state.GetDense<T<#INDEX1#>>());
				bag.version<#INDEX1#> = handles.GetNativeArray<T<#INDEX1#>, uint>(3, state.GetVersion<T<#INDEX1#>>());
---<#END#>
				return bag;
			}
<#END#>
		}
<#ARRAY [0..STRUCT_COUNT]#>
		public static JobHandle AsJobParallel<TJob, <#ARRAY [0..GENERIC_COUNT]#>T<#INDEX1#><#SEPARATOR1:,#><#END#>>(this Filter<<#ARRAY [0..GENERIC_COUNT]#>T<#INDEX1#><#SEPARATOR1:,#><#END#>> filter, TJob job = default)
            where TJob : struct, IJobParallelFilterBag<JobBag<<#ARRAY [0..GENERIC_COUNT]#>T<#INDEX1#><#SEPARATOR1:,#><#END#>>>
---<#ARRAY [0..GENERIC_COUNT]#>
            where T<#INDEX1#> : unmanaged, IComponent
---<#END#>
			=> job.Schedule(BagJobFactory.Create(filter));
        
<#END#>
<#ARRAY [0..STRUCT_COUNT]#>
        public static JobHandle AsJob<TJob, <#ARRAY [0..GENERIC_COUNT]#>T<#INDEX1#><#SEPARATOR1:,#><#END#>>(this Filter<<#ARRAY [0..GENERIC_COUNT]#>T<#INDEX1#><#SEPARATOR1:,#><#END#>> filter, TJob job = default)
            where TJob : struct, IJobFilterBag<JobBag<<#ARRAY [0..GENERIC_COUNT]#>T<#INDEX1#><#SEPARATOR1:,#><#END#>>>
---<#ARRAY [0..GENERIC_COUNT]#>
            where T<#INDEX1#> : unmanaged, IComponent
---<#END#>
			=> job.Schedule(BagJobFactory.Create(filter));
<#END#>
    }
}