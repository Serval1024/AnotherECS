<#META GENERATOR = AnotherECS.Unity.Jobs.Generator.FilterExtensionsGenerator FILENAME = FilterExtensions.cs N = 8#>

// <auto-generated>
// This source code was auto-generated by FilterExtensionsGenerator.cs
// </auto-generated>


using Unity.Jobs;
using AnotherECS.Core;
using EntityId = System.UInt32;

namespace AnotherECS.Unity.Jobs
{
    public unsafe static class FilterExtensions
    {
		public unsafe static class BagJobFactory
		{
<#ARRAY [0..2]#>
---<#ARRAY [0..STRUCT_COUNT]#>
			public static JobBag<#R:TAG#><<#ARRAY [0..GENERIC_COUNT]#>T<#INDEX2#><#SEPARATOR1:,#><#END#>> Create<#R:TAG#><<#ARRAY [0..GENERIC_COUNT]#>T<#INDEX2#><#SEPARATOR1:,#><#END#>>(State state, EntityCollection entities)
------<#ARRAY [0..GENERIC_COUNT]#>
				where T<#INDEX2#> : unmanaged, IComponent
------<#END#>
            {
                var handles = state.GetModuleData<NativeArrayHandles>(NativeArrayHandles.MODULE_DATA_ID);

                JobBag<#R:TAG#><<#ARRAY [0..GENERIC_COUNT]#>T<#INDEX2#><#SEPARATOR1:,#><#END#>> bag;
                bag.indexes = handles.GetNativeArrayById<EntityId>(entities.id, entities.entities);
                bag.count = (int)entities.entities.Length;

------<#ARRAY [0..GENERIC_COUNT]#>
				bag.sparse<#INDEX2#> = handles.GetNativeArrayByComponent<T<#INDEX2#>, ushort>(0, state.GetSparse<T<#INDEX2#>, ushort>());
				bag.component<#INDEX2#> = handles.GetNativeArrayByComponent<T<#INDEX2#>, T<#INDEX2#>>(1, state.GetDense<T<#INDEX2#>>());
				bag.version<#INDEX2#> = handles.GetNativeArrayByComponent<T<#INDEX2#>, uint>(2, state.GetVersion<T<#INDEX2#>>());
                if (!bag.version<#INDEX2#>.IsCreated){ bag.version<#INDEX2#> = handles.UintDummy; }
------<#END#>
                return bag;
            }

			public static JobBag<#R:TAG#><<#ARRAY [0..GENERIC_COUNT]#>T<#INDEX2#><#SEPARATOR1:,#><#END#>> Create<#R:TAG#><<#ARRAY [0..GENERIC_COUNT]#>T<#INDEX2#><#SEPARATOR1:,#><#END#>>(Filter<<#ARRAY [0..GENERIC_COUNT]#>T<#INDEX2#><#SEPARATOR1:,#><#END#>> filter)
------<#ARRAY [0..GENERIC_COUNT]#>
				where T<#INDEX2#> : unmanaged, IComponent
------<#END#>
				=> BagJobFactory.Create<#R:TAG#><<#ARRAY [0..GENERIC_COUNT]#>T<#INDEX2#><#SEPARATOR1:,#><#END#>>(filter.GetState(), filter.GetFilterData()->GetEntities());
---<#END#>
<#END#>
		}
<#ARRAY [0..2]#>
---<#ARRAY [0..STRUCT_COUNT]#>
		public static JobHandle AsJobParallel<#R:TAG#><TJob, <#ARRAY [0..GENERIC_COUNT]#>T<#INDEX2#><#SEPARATOR1:,#><#END#>>(this Filter<<#ARRAY [0..GENERIC_COUNT]#>T<#INDEX2#><#SEPARATOR1:,#><#END#>> filter, TJob job = default)
            where TJob : struct, IJobParallelForBag<JobBag<#R:TAG#><<#ARRAY [0..GENERIC_COUNT]#>T<#INDEX2#><#SEPARATOR1:,#><#END#>>>
------<#ARRAY [0..GENERIC_COUNT]#>
            where T<#INDEX2#> : unmanaged, IComponent
------<#END#>
			=> job.Schedule(BagJobFactory.Create<#R:TAG#>(filter));
        
---<#END#>
---<#ARRAY [0..STRUCT_COUNT]#>
        public static JobHandle AsJob<#R:TAG#><TJob, <#ARRAY [0..GENERIC_COUNT]#>T<#INDEX2#><#SEPARATOR1:,#><#END#>>(this Filter<<#ARRAY [0..GENERIC_COUNT]#>T<#INDEX2#><#SEPARATOR1:,#><#END#>> filter, TJob job = default)
            where TJob : struct, IJobForBag<JobBag<#R:TAG#><<#ARRAY [0..GENERIC_COUNT]#>T<#INDEX2#><#SEPARATOR1:,#><#END#>>>
------<#ARRAY [0..GENERIC_COUNT]#>
            where T<#INDEX2#> : unmanaged, IComponent
------<#END#>
			=> job.Schedule(BagJobFactory.Create<#R:TAG#>(filter));
---<#END#>
<#END#>
    }
}