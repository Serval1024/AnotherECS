<#META GENERATOR = AnotherECS.Generator.CommonGenericGenerator FILENAME = JobBag.cs N = 8#>

// <auto-generated>
// This source code was auto-generated by CommonGenericGenerator.cs
// </auto-generated>


using System.Runtime.CompilerServices;
using Unity.Collections;
using EntityId = System.UInt32;

namespace AnotherECS.Unity.Jobs
{
<#ARRAY [0..STRUCT_COUNT]#>
#if ENABLE_IL2CPP
    [Unity.IL2CPP.CompilerServices.Il2CppSetOption (Option.NullChecks, false)]
    [Unity.IL2CPP.CompilerServices.Il2CppSetOption (Option.ArrayBoundsChecks, false)]
    [Unity.IL2CPP.CompilerServices.Il2CppSetOption (Option.DivideByZeroChecks, false)]
#endif
    public unsafe struct JobBag<<#ARRAY [0..GENERIC_COUNT]#>T<#INDEX1#><#SEPARATOR1:,#><#END#>> : IJobBag
---<#ARRAY [0..GENERIC_COUNT]#>
        where T<#INDEX1#> : unmanaged
---<#END#>
    {
        internal int count;

        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<EntityId> indexes;

---<#ARRAY [0..GENERIC_COUNT]#>
        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<ushort> sparse<#INDEX1#>;
        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<uint> version<#INDEX1#>;
        [NativeDisableParallelForRestriction] internal NativeArray<T<#INDEX1#>> component<#INDEX1#>;
---<#END#>
        public int Count
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => count;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void BeginForEachIndex(int chunkIndex) { }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void EndForEachIndex() { }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int GetEntity(int index)
           => (int)indexes[index];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int GetEntity(uint index)
           => (int)indexes[(int)index];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public EntityId GetEntityId(uint index)
           => indexes[(int)index];

---<#ARRAY [0..GENERIC_COUNT]#>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool HasT<#INDEX1#>(int index)
            => sparse<#INDEX1#>[GetEntity(index)] != 0;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T<#INDEX1#> ReadT<#INDEX1#>(int index)
            => component<#INDEX1#>[GetComponentIndex<#INDEX1#>(index)];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ref T<#INDEX1#> GetT<#INDEX1#>(int index)
            => ref component<#INDEX1#>.GetRef(GetComponentIndex<#INDEX1#>(index));

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint GetVersionT<#INDEX1#>(int index)
        {
#if !ANOTHERECS_RELEASE
            if (!version<#INDEX1#>.IsCreated)
            {
                throw new AnotherECS.Unity.Jobs.Exceptions.ComponentNotSupportVersionException(typeof(T<#INDEX1#>));
            }
#endif
            return version<#INDEX1#>[GetComponentIndex<#INDEX1#>(index)];
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private ushort GetComponentIndex<#INDEX1#>(int index)
            => sparse<#INDEX1#>[GetEntity(index)];
---<#END#>

---<#ARRAY [0..GENERIC_COUNT]#>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool HasT<#INDEX1#>(uint index)
            => sparse<#INDEX1#>[GetEntity(index)] != 0;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T<#INDEX1#> ReadT<#INDEX1#>(uint index)
            => component<#INDEX1#>[GetComponentIndex<#INDEX1#>(index)];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ref T<#INDEX1#> GetT<#INDEX1#>(uint index)
            => ref component<#INDEX1#>.GetRef(GetComponentIndex<#INDEX1#>(index));

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint GetVersionT<#INDEX1#>(uint index)
        {
#if !ANOTHERECS_RELEASE
            if (!version<#INDEX1#>.IsCreated)
            {
                throw new AnotherECS.Unity.Jobs.Exceptions.ComponentNotSupportVersionException(typeof(T<#INDEX1#>));
            }
#endif
            return version<#INDEX1#>[GetComponentIndex<#INDEX1#>(index)];
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private ushort GetComponentIndex<#INDEX1#>(uint index)
            => sparse<#INDEX1#>[GetEntity(index)];
---<#END#>
    }
<#END#>
}
