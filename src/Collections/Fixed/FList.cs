//GENERATOR = AnotherECS.Generator.FListGenerator FILENAME = FList.cs

// <auto-generated>
// This source code was auto-generated by FListGenerator.cs
// </auto-generated>

using AnotherECS.Core;
using AnotherECS.Serializer;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Runtime.CompilerServices;

namespace AnotherECS.Collections
{
    [Serializable]
    [ForceBlittable]
    public struct FList2<TValue> : IListCollection<TValue>, IList<TValue>, ISerialize, IEnumerable<TValue>, IRepairStateId
        where TValue : unmanaged
    {
        public FArray2<TValue> _data;
        public uint _count;

        public uint Capacity
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => _data.Length;
        }

        public uint Count
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => _count;
			internal set => _count = value;
        }

        public bool IsReadOnly => false;

        public TValue this[int index] { get => this[(uint)index]; set => this[(uint)index] = value; }

        int System.Collections.Generic.ICollection<TValue>.Count => (int)Count;

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ExtendToCapacity()
        {
            _count = Capacity;
        }

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Add(TValue value)
        {
#if !ANOTHERECS_RELEASE
            FArrayHelper.ThrowIfOutOfRange(_count, Capacity);
#endif
            this[_count++] = value;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void RemoveLast()
        {
            if (_count != 0)
            {
                this[--_count] = default;
            }
        }

        public void RemoveAt(uint index)
        {
#if !ANOTHERECS_RELEASE
            FArrayHelper.ThrowIfEmpty(_count);
#endif	
            _data.RemoveAtInternal(index, Capacity);
			--_count;
        }
		
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Clear()
        {
            _data.Clear();
			_count = 0;
        }

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
        public object Get(uint index)
            => this[index];

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Set(uint index, object @value)
        {
            this[index] = (TValue)@value;
        }

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Add(object value)
        {
#if !ANOTHERECS_RELEASE
            FArrayHelper.ThrowIfOutOfRange(_count, Capacity);
#endif
            this[_count++] = (TValue)value;
        }

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
        public IEnumerator<TValue> GetEnumerator()
            => new Enumerator(ref this);

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
        IEnumerator IEnumerable.GetEnumerator()
            => GetEnumerator();

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint IndexOf(TValue item)
            => IndexOf(ref item, _count);

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint IndexOf(ref TValue item)
            => IndexOf(ref item, _count);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal uint IndexOf(ref TValue item, uint count)
            => _data.IndexOf(ref item, count);

        public bool Contains(TValue item)
            => _data.Contains(ref item);

        public bool Contains(ref TValue item)
            => _data.Contains(ref item);

        public void Insert(uint index, TValue item)
        {
            Insert(index, ref item);
        }

        public void Insert(uint index, ref TValue item)
        {
#if !ANOTHERECS_RELEASE
            FArrayHelper.ThrowIfOutOfRange(_count, Capacity);
#endif
			_data.Insert(index, ref item);
            ++_count;
        }

        public bool Remove(TValue item)
        {
            var index = IndexOf(ref item);
            if (index != uint.MaxValue)
            {
                RemoveAt(index);
                return true;
            }
            return false;
        }

        public void CopyTo(TValue[] array, uint arrayIndex)
        {
			_data.CopyTo(array, arrayIndex, _count, _count);
        }

        public void CopyTo(TValue[] array, uint arrayIndex, uint count)
        {
			_data.CopyTo(array, arrayIndex, count, _count);
        }

        public void Pack(ref WriterContextSerializer writer)
        {
            writer.Write(_count);
            _data.Pack(ref writer);
        }

        public void Unpack(ref ReaderContextSerializer reader)
        {
            _count = reader.ReadUInt32();
            _data.Unpack(ref reader);
        }

        public TValue this[uint index]
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => _data[index];
            
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set => _data[index] = value;
        }

        bool IRepairStateId.IsRepairStateId
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => typeof(IRepairStateId).IsAssignableFrom(typeof(TValue));
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        void IRepairStateId.RepairStateId(ushort stateId)
        {
            _data.RepairIdElement(stateId, 0, Count);
        }

        public struct Enumerator : IEnumerator<TValue>
        {
            private readonly FList2<TValue> _data;
            private uint _current;

            public Enumerator(ref FList2<TValue> data)
            {
                _data = data;
                _current = uint.MaxValue;
            }

            public TValue Current
            {
                [MethodImpl(MethodImplOptions.AggressiveInlining)]
                get => _data[_current];
            }

            object IEnumerator.Current
                => _data[_current];

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public bool MoveNext()
                => ++_current < _data.Count;

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public void Reset()
            {
                _current = uint.MaxValue;
            }

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public void Dispose() { }
        }

        int IList<TValue>.IndexOf(TValue item)
            => (int)IndexOf(item);

        public void Insert(int index, TValue item)
        {
            Insert((uint)index, item);
        }

        public void RemoveAt(int index)
        {
            RemoveAt((uint)index);
        }

        public void CopyTo(TValue[] array, int arrayIndex)
        {
            CopyTo(array, (uint)arrayIndex);
        }
    }
    [Serializable]
    [ForceBlittable]
    public struct FList4<TValue> : IListCollection<TValue>, IList<TValue>, ISerialize, IEnumerable<TValue>, IRepairStateId
        where TValue : unmanaged
    {
        public FArray4<TValue> _data;
        public uint _count;

        public uint Capacity
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => _data.Length;
        }

        public uint Count
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => _count;
			internal set => _count = value;
        }

        public bool IsReadOnly => false;

        public TValue this[int index] { get => this[(uint)index]; set => this[(uint)index] = value; }

        int System.Collections.Generic.ICollection<TValue>.Count => (int)Count;

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ExtendToCapacity()
        {
            _count = Capacity;
        }

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Add(TValue value)
        {
#if !ANOTHERECS_RELEASE
            FArrayHelper.ThrowIfOutOfRange(_count, Capacity);
#endif
            this[_count++] = value;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void RemoveLast()
        {
            if (_count != 0)
            {
                this[--_count] = default;
            }
        }

        public void RemoveAt(uint index)
        {
#if !ANOTHERECS_RELEASE
            FArrayHelper.ThrowIfEmpty(_count);
#endif	
            _data.RemoveAtInternal(index, Capacity);
			--_count;
        }
		
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Clear()
        {
            _data.Clear();
			_count = 0;
        }

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
        public object Get(uint index)
            => this[index];

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Set(uint index, object @value)
        {
            this[index] = (TValue)@value;
        }

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Add(object value)
        {
#if !ANOTHERECS_RELEASE
            FArrayHelper.ThrowIfOutOfRange(_count, Capacity);
#endif
            this[_count++] = (TValue)value;
        }

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
        public IEnumerator<TValue> GetEnumerator()
            => new Enumerator(ref this);

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
        IEnumerator IEnumerable.GetEnumerator()
            => GetEnumerator();

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint IndexOf(TValue item)
            => IndexOf(ref item, _count);

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint IndexOf(ref TValue item)
            => IndexOf(ref item, _count);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal uint IndexOf(ref TValue item, uint count)
            => _data.IndexOf(ref item, count);

        public bool Contains(TValue item)
            => _data.Contains(ref item);

        public bool Contains(ref TValue item)
            => _data.Contains(ref item);

        public void Insert(uint index, TValue item)
        {
            Insert(index, ref item);
        }

        public void Insert(uint index, ref TValue item)
        {
#if !ANOTHERECS_RELEASE
            FArrayHelper.ThrowIfOutOfRange(_count, Capacity);
#endif
			_data.Insert(index, ref item);
            ++_count;
        }

        public bool Remove(TValue item)
        {
            var index = IndexOf(ref item);
            if (index != uint.MaxValue)
            {
                RemoveAt(index);
                return true;
            }
            return false;
        }

        public void CopyTo(TValue[] array, uint arrayIndex)
        {
			_data.CopyTo(array, arrayIndex, _count, _count);
        }

        public void CopyTo(TValue[] array, uint arrayIndex, uint count)
        {
			_data.CopyTo(array, arrayIndex, count, _count);
        }

        public void Pack(ref WriterContextSerializer writer)
        {
            writer.Write(_count);
            _data.Pack(ref writer);
        }

        public void Unpack(ref ReaderContextSerializer reader)
        {
            _count = reader.ReadUInt32();
            _data.Unpack(ref reader);
        }

        public TValue this[uint index]
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => _data[index];
            
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set => _data[index] = value;
        }

        bool IRepairStateId.IsRepairStateId
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => typeof(IRepairStateId).IsAssignableFrom(typeof(TValue));
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        void IRepairStateId.RepairStateId(ushort stateId)
        {
            _data.RepairIdElement(stateId, 0, Count);
        }

        public struct Enumerator : IEnumerator<TValue>
        {
            private readonly FList4<TValue> _data;
            private uint _current;

            public Enumerator(ref FList4<TValue> data)
            {
                _data = data;
                _current = uint.MaxValue;
            }

            public TValue Current
            {
                [MethodImpl(MethodImplOptions.AggressiveInlining)]
                get => _data[_current];
            }

            object IEnumerator.Current
                => _data[_current];

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public bool MoveNext()
                => ++_current < _data.Count;

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public void Reset()
            {
                _current = uint.MaxValue;
            }

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public void Dispose() { }
        }

        int IList<TValue>.IndexOf(TValue item)
            => (int)IndexOf(item);

        public void Insert(int index, TValue item)
        {
            Insert((uint)index, item);
        }

        public void RemoveAt(int index)
        {
            RemoveAt((uint)index);
        }

        public void CopyTo(TValue[] array, int arrayIndex)
        {
            CopyTo(array, (uint)arrayIndex);
        }
    }
    [Serializable]
    [ForceBlittable]
    public struct FList8<TValue> : IListCollection<TValue>, IList<TValue>, ISerialize, IEnumerable<TValue>, IRepairStateId
        where TValue : unmanaged
    {
        public FArray8<TValue> _data;
        public uint _count;

        public uint Capacity
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => _data.Length;
        }

        public uint Count
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => _count;
			internal set => _count = value;
        }

        public bool IsReadOnly => false;

        public TValue this[int index] { get => this[(uint)index]; set => this[(uint)index] = value; }

        int System.Collections.Generic.ICollection<TValue>.Count => (int)Count;

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ExtendToCapacity()
        {
            _count = Capacity;
        }

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Add(TValue value)
        {
#if !ANOTHERECS_RELEASE
            FArrayHelper.ThrowIfOutOfRange(_count, Capacity);
#endif
            this[_count++] = value;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void RemoveLast()
        {
            if (_count != 0)
            {
                this[--_count] = default;
            }
        }

        public void RemoveAt(uint index)
        {
#if !ANOTHERECS_RELEASE
            FArrayHelper.ThrowIfEmpty(_count);
#endif	
            _data.RemoveAtInternal(index, Capacity);
			--_count;
        }
		
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Clear()
        {
            _data.Clear();
			_count = 0;
        }

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
        public object Get(uint index)
            => this[index];

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Set(uint index, object @value)
        {
            this[index] = (TValue)@value;
        }

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Add(object value)
        {
#if !ANOTHERECS_RELEASE
            FArrayHelper.ThrowIfOutOfRange(_count, Capacity);
#endif
            this[_count++] = (TValue)value;
        }

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
        public IEnumerator<TValue> GetEnumerator()
            => new Enumerator(ref this);

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
        IEnumerator IEnumerable.GetEnumerator()
            => GetEnumerator();

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint IndexOf(TValue item)
            => IndexOf(ref item, _count);

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint IndexOf(ref TValue item)
            => IndexOf(ref item, _count);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal uint IndexOf(ref TValue item, uint count)
            => _data.IndexOf(ref item, count);

        public bool Contains(TValue item)
            => _data.Contains(ref item);

        public bool Contains(ref TValue item)
            => _data.Contains(ref item);

        public void Insert(uint index, TValue item)
        {
            Insert(index, ref item);
        }

        public void Insert(uint index, ref TValue item)
        {
#if !ANOTHERECS_RELEASE
            FArrayHelper.ThrowIfOutOfRange(_count, Capacity);
#endif
			_data.Insert(index, ref item);
            ++_count;
        }

        public bool Remove(TValue item)
        {
            var index = IndexOf(ref item);
            if (index != uint.MaxValue)
            {
                RemoveAt(index);
                return true;
            }
            return false;
        }

        public void CopyTo(TValue[] array, uint arrayIndex)
        {
			_data.CopyTo(array, arrayIndex, _count, _count);
        }

        public void CopyTo(TValue[] array, uint arrayIndex, uint count)
        {
			_data.CopyTo(array, arrayIndex, count, _count);
        }

        public void Pack(ref WriterContextSerializer writer)
        {
            writer.Write(_count);
            _data.Pack(ref writer);
        }

        public void Unpack(ref ReaderContextSerializer reader)
        {
            _count = reader.ReadUInt32();
            _data.Unpack(ref reader);
        }

        public TValue this[uint index]
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => _data[index];
            
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set => _data[index] = value;
        }

        bool IRepairStateId.IsRepairStateId
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => typeof(IRepairStateId).IsAssignableFrom(typeof(TValue));
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        void IRepairStateId.RepairStateId(ushort stateId)
        {
            _data.RepairIdElement(stateId, 0, Count);
        }

        public struct Enumerator : IEnumerator<TValue>
        {
            private readonly FList8<TValue> _data;
            private uint _current;

            public Enumerator(ref FList8<TValue> data)
            {
                _data = data;
                _current = uint.MaxValue;
            }

            public TValue Current
            {
                [MethodImpl(MethodImplOptions.AggressiveInlining)]
                get => _data[_current];
            }

            object IEnumerator.Current
                => _data[_current];

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public bool MoveNext()
                => ++_current < _data.Count;

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public void Reset()
            {
                _current = uint.MaxValue;
            }

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public void Dispose() { }
        }

        int IList<TValue>.IndexOf(TValue item)
            => (int)IndexOf(item);

        public void Insert(int index, TValue item)
        {
            Insert((uint)index, item);
        }

        public void RemoveAt(int index)
        {
            RemoveAt((uint)index);
        }

        public void CopyTo(TValue[] array, int arrayIndex)
        {
            CopyTo(array, (uint)arrayIndex);
        }
    }
    [Serializable]
    [ForceBlittable]
    public struct FList16<TValue> : IListCollection<TValue>, IList<TValue>, ISerialize, IEnumerable<TValue>, IRepairStateId
        where TValue : unmanaged
    {
        public FArray16<TValue> _data;
        public uint _count;

        public uint Capacity
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => _data.Length;
        }

        public uint Count
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => _count;
			internal set => _count = value;
        }

        public bool IsReadOnly => false;

        public TValue this[int index] { get => this[(uint)index]; set => this[(uint)index] = value; }

        int System.Collections.Generic.ICollection<TValue>.Count => (int)Count;

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ExtendToCapacity()
        {
            _count = Capacity;
        }

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Add(TValue value)
        {
#if !ANOTHERECS_RELEASE
            FArrayHelper.ThrowIfOutOfRange(_count, Capacity);
#endif
            this[_count++] = value;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void RemoveLast()
        {
            if (_count != 0)
            {
                this[--_count] = default;
            }
        }

        public void RemoveAt(uint index)
        {
#if !ANOTHERECS_RELEASE
            FArrayHelper.ThrowIfEmpty(_count);
#endif	
            _data.RemoveAtInternal(index, Capacity);
			--_count;
        }
		
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Clear()
        {
            _data.Clear();
			_count = 0;
        }

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
        public object Get(uint index)
            => this[index];

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Set(uint index, object @value)
        {
            this[index] = (TValue)@value;
        }

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Add(object value)
        {
#if !ANOTHERECS_RELEASE
            FArrayHelper.ThrowIfOutOfRange(_count, Capacity);
#endif
            this[_count++] = (TValue)value;
        }

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
        public IEnumerator<TValue> GetEnumerator()
            => new Enumerator(ref this);

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
        IEnumerator IEnumerable.GetEnumerator()
            => GetEnumerator();

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint IndexOf(TValue item)
            => IndexOf(ref item, _count);

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint IndexOf(ref TValue item)
            => IndexOf(ref item, _count);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal uint IndexOf(ref TValue item, uint count)
            => _data.IndexOf(ref item, count);

        public bool Contains(TValue item)
            => _data.Contains(ref item);

        public bool Contains(ref TValue item)
            => _data.Contains(ref item);

        public void Insert(uint index, TValue item)
        {
            Insert(index, ref item);
        }

        public void Insert(uint index, ref TValue item)
        {
#if !ANOTHERECS_RELEASE
            FArrayHelper.ThrowIfOutOfRange(_count, Capacity);
#endif
			_data.Insert(index, ref item);
            ++_count;
        }

        public bool Remove(TValue item)
        {
            var index = IndexOf(ref item);
            if (index != uint.MaxValue)
            {
                RemoveAt(index);
                return true;
            }
            return false;
        }

        public void CopyTo(TValue[] array, uint arrayIndex)
        {
			_data.CopyTo(array, arrayIndex, _count, _count);
        }

        public void CopyTo(TValue[] array, uint arrayIndex, uint count)
        {
			_data.CopyTo(array, arrayIndex, count, _count);
        }

        public void Pack(ref WriterContextSerializer writer)
        {
            writer.Write(_count);
            _data.Pack(ref writer);
        }

        public void Unpack(ref ReaderContextSerializer reader)
        {
            _count = reader.ReadUInt32();
            _data.Unpack(ref reader);
        }

        public TValue this[uint index]
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => _data[index];
            
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set => _data[index] = value;
        }

        bool IRepairStateId.IsRepairStateId
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => typeof(IRepairStateId).IsAssignableFrom(typeof(TValue));
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        void IRepairStateId.RepairStateId(ushort stateId)
        {
            _data.RepairIdElement(stateId, 0, Count);
        }

        public struct Enumerator : IEnumerator<TValue>
        {
            private readonly FList16<TValue> _data;
            private uint _current;

            public Enumerator(ref FList16<TValue> data)
            {
                _data = data;
                _current = uint.MaxValue;
            }

            public TValue Current
            {
                [MethodImpl(MethodImplOptions.AggressiveInlining)]
                get => _data[_current];
            }

            object IEnumerator.Current
                => _data[_current];

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public bool MoveNext()
                => ++_current < _data.Count;

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public void Reset()
            {
                _current = uint.MaxValue;
            }

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public void Dispose() { }
        }

        int IList<TValue>.IndexOf(TValue item)
            => (int)IndexOf(item);

        public void Insert(int index, TValue item)
        {
            Insert((uint)index, item);
        }

        public void RemoveAt(int index)
        {
            RemoveAt((uint)index);
        }

        public void CopyTo(TValue[] array, int arrayIndex)
        {
            CopyTo(array, (uint)arrayIndex);
        }
    }
    [Serializable]
    [ForceBlittable]
    public struct FList32<TValue> : IListCollection<TValue>, IList<TValue>, ISerialize, IEnumerable<TValue>, IRepairStateId
        where TValue : unmanaged
    {
        public FArray32<TValue> _data;
        public uint _count;

        public uint Capacity
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => _data.Length;
        }

        public uint Count
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => _count;
			internal set => _count = value;
        }

        public bool IsReadOnly => false;

        public TValue this[int index] { get => this[(uint)index]; set => this[(uint)index] = value; }

        int System.Collections.Generic.ICollection<TValue>.Count => (int)Count;

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ExtendToCapacity()
        {
            _count = Capacity;
        }

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Add(TValue value)
        {
#if !ANOTHERECS_RELEASE
            FArrayHelper.ThrowIfOutOfRange(_count, Capacity);
#endif
            this[_count++] = value;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void RemoveLast()
        {
            if (_count != 0)
            {
                this[--_count] = default;
            }
        }

        public void RemoveAt(uint index)
        {
#if !ANOTHERECS_RELEASE
            FArrayHelper.ThrowIfEmpty(_count);
#endif	
            _data.RemoveAtInternal(index, Capacity);
			--_count;
        }
		
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Clear()
        {
            _data.Clear();
			_count = 0;
        }

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
        public object Get(uint index)
            => this[index];

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Set(uint index, object @value)
        {
            this[index] = (TValue)@value;
        }

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Add(object value)
        {
#if !ANOTHERECS_RELEASE
            FArrayHelper.ThrowIfOutOfRange(_count, Capacity);
#endif
            this[_count++] = (TValue)value;
        }

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
        public IEnumerator<TValue> GetEnumerator()
            => new Enumerator(ref this);

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
        IEnumerator IEnumerable.GetEnumerator()
            => GetEnumerator();

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint IndexOf(TValue item)
            => IndexOf(ref item, _count);

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint IndexOf(ref TValue item)
            => IndexOf(ref item, _count);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal uint IndexOf(ref TValue item, uint count)
            => _data.IndexOf(ref item, count);

        public bool Contains(TValue item)
            => _data.Contains(ref item);

        public bool Contains(ref TValue item)
            => _data.Contains(ref item);

        public void Insert(uint index, TValue item)
        {
            Insert(index, ref item);
        }

        public void Insert(uint index, ref TValue item)
        {
#if !ANOTHERECS_RELEASE
            FArrayHelper.ThrowIfOutOfRange(_count, Capacity);
#endif
			_data.Insert(index, ref item);
            ++_count;
        }

        public bool Remove(TValue item)
        {
            var index = IndexOf(ref item);
            if (index != uint.MaxValue)
            {
                RemoveAt(index);
                return true;
            }
            return false;
        }

        public void CopyTo(TValue[] array, uint arrayIndex)
        {
			_data.CopyTo(array, arrayIndex, _count, _count);
        }

        public void CopyTo(TValue[] array, uint arrayIndex, uint count)
        {
			_data.CopyTo(array, arrayIndex, count, _count);
        }

        public void Pack(ref WriterContextSerializer writer)
        {
            writer.Write(_count);
            _data.Pack(ref writer);
        }

        public void Unpack(ref ReaderContextSerializer reader)
        {
            _count = reader.ReadUInt32();
            _data.Unpack(ref reader);
        }

        public TValue this[uint index]
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => _data[index];
            
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set => _data[index] = value;
        }

        bool IRepairStateId.IsRepairStateId
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => typeof(IRepairStateId).IsAssignableFrom(typeof(TValue));
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        void IRepairStateId.RepairStateId(ushort stateId)
        {
            _data.RepairIdElement(stateId, 0, Count);
        }

        public struct Enumerator : IEnumerator<TValue>
        {
            private readonly FList32<TValue> _data;
            private uint _current;

            public Enumerator(ref FList32<TValue> data)
            {
                _data = data;
                _current = uint.MaxValue;
            }

            public TValue Current
            {
                [MethodImpl(MethodImplOptions.AggressiveInlining)]
                get => _data[_current];
            }

            object IEnumerator.Current
                => _data[_current];

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public bool MoveNext()
                => ++_current < _data.Count;

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public void Reset()
            {
                _current = uint.MaxValue;
            }

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public void Dispose() { }
        }

        int IList<TValue>.IndexOf(TValue item)
            => (int)IndexOf(item);

        public void Insert(int index, TValue item)
        {
            Insert((uint)index, item);
        }

        public void RemoveAt(int index)
        {
            RemoveAt((uint)index);
        }

        public void CopyTo(TValue[] array, int arrayIndex)
        {
            CopyTo(array, (uint)arrayIndex);
        }
    }
    [Serializable]
    [ForceBlittable]
    public struct FList64<TValue> : IListCollection<TValue>, IList<TValue>, ISerialize, IEnumerable<TValue>, IRepairStateId
        where TValue : unmanaged
    {
        public FArray64<TValue> _data;
        public uint _count;

        public uint Capacity
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => _data.Length;
        }

        public uint Count
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => _count;
			internal set => _count = value;
        }

        public bool IsReadOnly => false;

        public TValue this[int index] { get => this[(uint)index]; set => this[(uint)index] = value; }

        int System.Collections.Generic.ICollection<TValue>.Count => (int)Count;

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ExtendToCapacity()
        {
            _count = Capacity;
        }

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Add(TValue value)
        {
#if !ANOTHERECS_RELEASE
            FArrayHelper.ThrowIfOutOfRange(_count, Capacity);
#endif
            this[_count++] = value;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void RemoveLast()
        {
            if (_count != 0)
            {
                this[--_count] = default;
            }
        }

        public void RemoveAt(uint index)
        {
#if !ANOTHERECS_RELEASE
            FArrayHelper.ThrowIfEmpty(_count);
#endif	
            _data.RemoveAtInternal(index, Capacity);
			--_count;
        }
		
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Clear()
        {
            _data.Clear();
			_count = 0;
        }

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
        public object Get(uint index)
            => this[index];

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Set(uint index, object @value)
        {
            this[index] = (TValue)@value;
        }

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Add(object value)
        {
#if !ANOTHERECS_RELEASE
            FArrayHelper.ThrowIfOutOfRange(_count, Capacity);
#endif
            this[_count++] = (TValue)value;
        }

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
        public IEnumerator<TValue> GetEnumerator()
            => new Enumerator(ref this);

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
        IEnumerator IEnumerable.GetEnumerator()
            => GetEnumerator();

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint IndexOf(TValue item)
            => IndexOf(ref item, _count);

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint IndexOf(ref TValue item)
            => IndexOf(ref item, _count);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal uint IndexOf(ref TValue item, uint count)
            => _data.IndexOf(ref item, count);

        public bool Contains(TValue item)
            => _data.Contains(ref item);

        public bool Contains(ref TValue item)
            => _data.Contains(ref item);

        public void Insert(uint index, TValue item)
        {
            Insert(index, ref item);
        }

        public void Insert(uint index, ref TValue item)
        {
#if !ANOTHERECS_RELEASE
            FArrayHelper.ThrowIfOutOfRange(_count, Capacity);
#endif
			_data.Insert(index, ref item);
            ++_count;
        }

        public bool Remove(TValue item)
        {
            var index = IndexOf(ref item);
            if (index != uint.MaxValue)
            {
                RemoveAt(index);
                return true;
            }
            return false;
        }

        public void CopyTo(TValue[] array, uint arrayIndex)
        {
			_data.CopyTo(array, arrayIndex, _count, _count);
        }

        public void CopyTo(TValue[] array, uint arrayIndex, uint count)
        {
			_data.CopyTo(array, arrayIndex, count, _count);
        }

        public void Pack(ref WriterContextSerializer writer)
        {
            writer.Write(_count);
            _data.Pack(ref writer);
        }

        public void Unpack(ref ReaderContextSerializer reader)
        {
            _count = reader.ReadUInt32();
            _data.Unpack(ref reader);
        }

        public TValue this[uint index]
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => _data[index];
            
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set => _data[index] = value;
        }

        bool IRepairStateId.IsRepairStateId
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => typeof(IRepairStateId).IsAssignableFrom(typeof(TValue));
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        void IRepairStateId.RepairStateId(ushort stateId)
        {
            _data.RepairIdElement(stateId, 0, Count);
        }

        public struct Enumerator : IEnumerator<TValue>
        {
            private readonly FList64<TValue> _data;
            private uint _current;

            public Enumerator(ref FList64<TValue> data)
            {
                _data = data;
                _current = uint.MaxValue;
            }

            public TValue Current
            {
                [MethodImpl(MethodImplOptions.AggressiveInlining)]
                get => _data[_current];
            }

            object IEnumerator.Current
                => _data[_current];

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public bool MoveNext()
                => ++_current < _data.Count;

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public void Reset()
            {
                _current = uint.MaxValue;
            }

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public void Dispose() { }
        }

        int IList<TValue>.IndexOf(TValue item)
            => (int)IndexOf(item);

        public void Insert(int index, TValue item)
        {
            Insert((uint)index, item);
        }

        public void RemoveAt(int index)
        {
            RemoveAt((uint)index);
        }

        public void CopyTo(TValue[] array, int arrayIndex)
        {
            CopyTo(array, (uint)arrayIndex);
        }
    }

}