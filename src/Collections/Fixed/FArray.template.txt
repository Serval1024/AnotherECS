<#META GENERATOR = AnotherECS.Generator.FListGenerator FILENAME = FArray.cs#>

// <auto-generated>
// This source code was auto-generated by FListGenerator.cs
// </auto-generated>

using AnotherECS.Core;
using AnotherECS.Serializer;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

namespace AnotherECS.Collections
{
<#ARRAY [0..STRUCT_COUNT]#>
	[Serializable] internal struct Data<#ELEMENT_COUNT#><TValue> : ISerialize where TValue : unmanaged 
    { 
        public TValue <#ARRAY [0..ELEMENT_COUNT]#>p<#INDEX1#><#SEPARATOR1:,#><#END#>;

		public const uint LENGTH = <#ELEMENT_COUNT#>;
        public unsafe void Pack(ref WriterContextSerializer writer) => FArrayHelper.Pack<TValue>(ref writer, GCHandle.Alloc(this, GCHandleType.Pinned), LENGTH);
        public unsafe void Unpack(ref ReaderContextSerializer reader) => FArrayHelper.Unpack<TValue>(ref reader, GCHandle.Alloc(this, GCHandleType.Pinned), LENGTH);
    }

    [Serializable]
    [ForceBlittable]
    public struct FArray<#ELEMENT_COUNT#><TValue> : ICollection<TValue>, ISerialize, IEnumerable<TValue>, IRepairStateId
        where TValue : unmanaged
    {
		private Data<#ELEMENT_COUNT#><TValue> _data;

        public uint Length
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => Data<#ELEMENT_COUNT#><TValue>.LENGTH;
        }

        uint ICollection.Count => Length;

        public bool IsReadOnly => false;

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Clear()
        {
			_data = default;
        }

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint IndexOf(TValue item)
            => IndexOf(ref item, Length);

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint IndexOf(ref TValue item)
            => IndexOf(ref item, Length);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal uint IndexOf(ref TValue item, uint count)
        {
            for (uint i = 0; i < count; ++i)
            {
                if (EqualityComparer<TValue>.Default.Equals(this[i], item))
                {
                    return i;
                }
            }
            return uint.MaxValue;
        }

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Contains(TValue item)
            => Contains(ref item);

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Contains(ref TValue item)
            => IndexOf(ref item) != uint.MaxValue;

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Insert(uint index, TValue item)
        {
            Insert(index, ref item);
        }

        public void Insert(uint index, ref TValue item)
        {
#if !ANOTHERECS_RELEASE
            FArrayHelper.ThrowIfOutOfRange(index, Length);
#endif
            for (uint i = Length - 1; i > index; --i)
            {
                this[i] = this[i - 1];
            }
            this[index] = item;
        }

        public bool Remove(TValue item)
        {
            var index = IndexOf(ref item);
            if (index != uint.MaxValue)
            {
                RemoveAt(index);
                return true;
            }
            return false;
        }

		public void RemoveAt(uint index)
        {
			RemoveAtInternal(index, Length);
        }
		
        public void CopyTo(TValue[] array, uint arrayIndex)
        {
            CopyTo(array, arrayIndex, Length, Length);
        }
		
		public void CopyTo(TValue[] array, uint arrayIndex, uint count)
        {
            CopyTo(array, arrayIndex, count, Length);
        }

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Pack(ref WriterContextSerializer writer)
        {
			_data.Pack(ref writer);
        }

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Unpack(ref ReaderContextSerializer reader)
        {
			_data.Unpack(ref reader);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public TValue ReadUnsafe(uint index)
            => FArrayHelper.ReadUnsafe<TValue, Data<#ELEMENT_COUNT#><TValue>>(ref _data, index);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WriteUnsafe(uint index, TValue value)
            => FArrayHelper.WriteUnsafe<TValue, Data<#ELEMENT_COUNT#><TValue>>(ref _data, index, value);

        public TValue this[uint index]
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
#if !ANOTHERECS_RELEASE
                FArrayHelper.ThrowIfOutOfRange(index, Length);
#endif
#if ANOTHERECS_UNSAFE_FCOLLECTION
                return ReadUnsafe(index);
#else
                return index switch
                {
<#ARRAY [0..ELEMENT_COUNT]#>
                    <#INDEX1#> => _data.p<#INDEX1#>,
<#END#>
                    _ => throw new IndexOutOfRangeException($"Index {index} is out of range Length {Length}."),
                };    
#endif
            }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set
            {
#if !ANOTHERECS_RELEASE
                FArrayHelper.ThrowIfOutOfRange(index, Length);
#endif
#if ANOTHERECS_UNSAFE_FCOLLECTION
                WriteUnsafe(index, value);
#else
                switch(index)
                {
<#ARRAY [0..ELEMENT_COUNT]#>
                    case <#INDEX1#>: _data.p<#INDEX1#> = value; break;
<#END#>
                    default: throw new IndexOutOfRangeException($"Index {index} is out of range Length {Length}.");
                };
#endif
            }
		}
		
		internal void CopyTo(TValue[] array, uint arrayIndex, uint count, uint capacity)
        {
#if !ANOTHERECS_RELEASE
            if (count > capacity)
            {
                throw new ArgumentOutOfRangeException($"'{nameof(count)}':{count} must be less or equal than '{nameof(capacity)}': {capacity}");
            }
#endif
            if (array == null)
            {
                throw new NullReferenceException(nameof(array));
            }
            if (arrayIndex < 0)
            {
                throw new IndexOutOfRangeException(nameof(arrayIndex));
            }
            if (count <= 0)
            {
                throw new IndexOutOfRangeException(nameof(count));
            }
            if (array.Length - arrayIndex < count)
            {
                throw new ArgumentException($"There is not enough space in {nameof(array)} to copy.");
            }

            var iMax = Math.Min(array.Length - arrayIndex, count);
            for (uint i = 0; i < iMax; ++i)
            {
                array[i + arrayIndex] = this[i];
            }
        }
		
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void RemoveAtInternal(uint index, uint capacity)
        {
#if !ANOTHERECS_RELEASE
            FArrayHelper.ThrowIfOutOfRange(index, capacity);
#endif
            if (index != capacity - 1)
            {
                for (uint i = index; i < capacity - 1; ++i)
                {
                    this[i] = this[i + 1];
                }
			}
			
			this[capacity - 1] = default;
        }
		
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
        object ICollection.Get(uint index)
            => this[index];

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
        void ICollection.Set(uint index, object @value)
        {
            this[index] = (TValue)@value;
        }

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
        public IEnumerator<TValue> GetEnumerator()
            => new Enumerator(ref this);
			
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
        IEnumerator IEnumerable.GetEnumerator()
            => GetEnumerator();

        bool IRepairStateId.IsRepairStateId
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => typeof(IRepairStateId).IsAssignableFrom(typeof(TValue));
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        void IRepairStateId.RepairStateId(ushort stateId)
        {
            RepairIdElement(stateId, 0, Length);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal void RepairIdElement(ushort stateId, uint start, uint elementCount)
        {
            if (typeof(IRepairStateId).IsAssignableFrom(typeof(TValue)))
            {
                for (uint i = start; i < elementCount; ++i)
                {
                    var data = (IRepairStateId)this[i];
                    data.RepairStateId(stateId);
                    this[i] = (TValue)data;
                }
            }
        }

        public struct Enumerator : IEnumerator<TValue>
        {
            private readonly FArray<#ELEMENT_COUNT#><TValue> _data;
            private uint _current;

			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			public Enumerator(ref FArray<#ELEMENT_COUNT#><TValue> data)
            {
                _data = data;
                _current = uint.MaxValue;
            }

            public TValue Current
            {
                [MethodImpl(MethodImplOptions.AggressiveInlining)]
                get => _data[_current];
            }
			
            object IEnumerator.Current
			{
				[MethodImpl(MethodImplOptions.AggressiveInlining)]
                get => _data[_current];
			}

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public bool MoveNext()
                => ++_current < _data.Length;

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public void Reset()
            {
                _current = uint.MaxValue;
            }

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public void Dispose() { }
        }
    }
<#END#>
}