# AnotherECS

## Features
- Ecs with full state rollbacks.
- Thread-safe for each worlds.
- Customizable behavior and storage of components. (partial support for now)
- Deterministic, lockstep.
- Save only changed data in history for rollback. Without full copy. And it can be customized.
- Multi Worlds aka Universe.
- Minimum Internet traffic.
- Dense/Sparse based.
- More demanding on performance than ECS without rollback.
- Support Unity or can be used separately. (partial support for now)
- [Unity] Visual debugging (with synchronization of changes over the network).
- [Unity] Jobs support.

## Installation
1. Download and place wherever you wish.
> Ecs detects itself by AnotherECS.Core.asmdef.
2. [Unity] Minimum requirement Unity 2022.2.1f. Add the following packages:
### Unity Package Dependencies
``` 
"com.unity.burst": "1.7.4",
"com.unity.collections": "1.2.4",
"com.unity.ui": "1.0.0-preview.18",
```

## API
### [Unity] Create new codegen State
Select the directory then in the context menu click Another ECS -> Create State.
The new state will be called CompileState. You can have many states with different sets of components.
ECS will track CompileState and generate code if the AnotherECS -> Auto Compile flag is set in the top bar.
> The automatic compilation flag is disabled by default because it is not stable for now. For manual generate code use AnotherECS -> Compile.

- CompileState is faster than reflection state, but is currently only supported by Unity.
- CompileState support FastAccess Attribute. Look in [Component Options section]

### [C#] Create new reflection State
> [Section not ready, Placeholder]

### [C#] Create new codegen State
> [Section not ready, Placeholder]

### Create World
The world is a container for state and systems.
World is a base class that is not supported network sync. For a complete implementation look in [Remote/Network section].
Also look in [World Api section].
```csharp
public class WorldMonoBehaviour : MonoBehaviour
{
    World _world;

    void Awake()
    {
        var systems = new SystemGroup();    // SystemGroup contains all systems. Look in [SystemGroup section]
        var state = new StateCompile();     // Create state generated by codegen.
        _world = new World(systems, state); // Create a world that runs in non-multithreaded mode.
    }

    void Start()
    {
        _world.Init();  // Call once.
    }

    void FixedUpdate()
    {
        _world.Tick();  // Called at regular intervals.
    }
	
    void Update()
    {
        _world.UpdateFromMainThread();  // To support multithreading. Look in [Threading section]
    }

    private void OnDestroy()
    {
        _world.Destroy();        // Call Destroy events in systems.
        _world.Dispose();        // Free unmanaged memory.
    }
	
    public void SendEvent(IEvent @event)
    {
        _world.SendEvent(@event);  // Send an event to next tick.
    }
}
```

### SystemGroup
SystemGroup contain systems.
```csharp
var systems = new SystemGroup()      // First way to add systems.
{
    new PhysicsSystem(),
    new DiagnosticFeature(),         // Features and systems for ecs are the same.
    new MySystem0(),

    new SystemGroup()                // SystemGroup can be used for better organization of code.
    {
        new MySystem1(),
    }
};

systems                              // Second way to add systems.
    .Add(new MySystem2())
    .Add(new MySystem3());
	
_world = new World(systems, state);  // Create a world that runs in non-multithreaded mode.
```
By default, systems are sorted in SortOrder.Declaration.

- SortOrder.Declaration - Systems are sorted in the order they were added.
- SortOrder.Attributes - Systems are sorted by [SystemOrderAttribute]. Systems are sorted only inside a SystemGroup and can't jump between SystemGroups.

```csharp
var systems = new SystemGroup(SortOrder.Declaration)  // Call SystemTest0 first then PhysicsSystem.
{
    new MySystem0(),
    new PhysicsSystem(),
};

var systems = new SystemGroup(SortOrder.Attributes)   // Сall PhysicsSystem first then SystemTest0
{                                                     // because PhysicsSystem has the [SystemOrder(SystemOrder.First)] attribute.
    new MySystem0(),                                  // Look in [Systems section]
    new PhysicsSystem(),
};
```

### Systems
Systems contain executable code and can receive various events.
> [!IMPORTANT]
> Systems cannot store any non-constant data otherwise it will cause desync.

- ICreateSystem
- ITickSystem
- IDestroySystem
- IReceiverSystem

All interfaces have 2 types: abstract and concrete.
- Abstract type can be reused between different state types. (StateCompile0, StateCompile1, etc.)
- Concrete type can use FastAccess. Look in [Component options section].

```csharp
public class MySystem0 :          // Abstract
    ICreateSystem,
    ITickSystem,
    IDestroySystem,
    IReceiverSystem<MyEvent>
{
    public void OnCreate(State state) { }                  // Call once during the initialization phase.
    public void OnDestroy(State state) { }                 // Call once during the destroy phase.
    public void OnTick(State state) { }                    // Call every time during the tick phase.
    public void Receive(State state, MyEvent @event) { }   // Call when a new event arrives for the current tick from world.Send(new MyEvent());
}

public class MySystem1 :          // Concrete
    ICreateSystem<StateCompile>,
    ITickSystem<StateCompile>,
    IDestroySystem<StateCompile>,
    IReceiverSystem<StateCompile, MyEvent>
{
    public void OnCreate(StateCompile state) { }
    public void OnDestroy(StateCompile state) { }
    public void OnTick(StateCompile state) { }
    public void Receive(StateCompile state, MyEvent @event) { }
}
``` 

#### Order Systems
Systems can be called either in the order in which they are declared or in the order depending on their attributes. Look in [SystemGroup section].

> [!TIP]
> Changing SystemOrder options requires regeneration code.

```csharp
[SystemOrder(SystemOrder.First)]                                // First order as far as possible.
[SystemOrder(SystemOrder.Last)]                                 // Last order as far as possible.
[SystemOrder(SystemOrderRelative.After, typeof(SystemTest1))]   // SystemTest0 is called after SystemTest1
[SystemOrder(SystemOrderRelative.Before, typeof(SystemTest1))]  // SystemTest0 is called before SystemTest1
public class SystemTest0 : ISystem { }
```

### Components
#### Basic syntax
Basic syntax for declaring a component:
```csharp
public struct MyComponent : IComponent
{
    //sfloat is a deterministic version of float. Look in [Deterministic mathematics section]
    public sfloat value;
}
```
> [!IMPORTANT]
> Components can only be of unmanaged type. And cannot contain references or managed objects.
>
>```csharp
>// Broken code.
>public struct MyComponent : IComponent
>{
>    public List<Enemy> enemies;  // Error: managed type.
>    public object target;        // Error: managed type.
>}
>```

#### Component Interfaces
- IComponent
A simple component that can be attached to an entity in one instance per entity.
```csharp
public struct Health : IComponent
{
    public int value;
}
```

- ISingle
A component can exist in one instance per state. It's like singleton.
```csharp
public struct MyScore : ISingle  // Look in [State ISingle Component API]
{
    public int value;
}
```

- IMarker
Marker is similar to IComponent but is automatically deleted at the end of the tick. Also fastest add to Entity but slow to remove manually.
```csharp
public struct MyDamage : IMarker
{
    public int value;
}
```

- IDefault
Default interface let you set default values.
> [!IMPORTANT]
> Don't modificate State from Setup method.
```csharp
public struct Health : IDefault
{
    public int value;

    public void Setup(State state)
    {
        // Look in [Configuration/IConfig section] & [State Api section]
        value = state.GetConfig<HealthConfig>().healthMax;
    }
}
```

- IVersion
The component stores the version in which the tick was changed.
```csharp
public struct MyComponent : IVersion
{
    public int value;
}

public class MySystem0 : ITickSystem,
{
    public void OnTick(State state)
    { 
        // ...
        var version0 = state.GetVersion<MyComponent>(entityId);   // Get a tick when a component has been modified. Look in [State Api section]
        //or
        var version1 = entity.GetVersion<MyComponent>();          // Get a tick when a component has been modified. Look in [State Api section]
    }
}
```

- IShared
> Allows you to filter a component with the same data.
> [Section not ready, Placeholder]

- IAttachExternal & IDetachExternal
Called when a component is attach/detach to an entity.
> [!IMPORTANT]
> Don't modificate any data from OnAttach/OnDetach method. This interface is designed to allow external code to react to an event inside ecs.
> During the time rollback phase, the attach and detach events maintain call consistency.
> This means that if a component was deleted during a time rollback, a OnDetach will be called. If added - OnAttach.

```csharp
public struct MyComponent : IAttachExternal, IDetachExternal
{
    public void OnAttach(ref ADExternalContext context)
    {
        ++MyCounterStatic.counter;  // Counter how many components in total.
    }
	
    public void OnDetach(ref ADExternalContext context)
    {
        --MyCounterStatic.counter;
    }
}
```
> [!TIP]
> IAttachExternal & IDetachExternal can also be used to create custom view system. Default UnityViewFeature uses IAttachExternal & IDetachExternal.

```csharp
public struct MyComponent : IMarker, ISingle, IVersion
{
    public int value;
}
```

#### Component Options
The code generator creates code for each component based on its settings. Using ComponentOptions you can change the behavior of a component.

> [!TIP]
> Changing component options requires regeneration code.

```csharp
[ComponentOption(ComponentOptions.HistoryNonSync)]
public struct MyComponent : IComponent { }
```

- DataFree - The component does not save data. This option is set by default if the component structure does not have fields/properties.
- NotDataFree - Forces memory allocation for a component even if it has no data. This option is the opposite of the option DataFree.
- WithoutSparseDirectDense - Data is read directly without sparse from the component store. Speeds up access to components. But it can increase memory consumption if the components are large. Enabled by default if the component is less than or equal to 2 bytes.
- ForceUseSparse - This option can be useful with [Unity] Jobs. Because Jobs are slower to work with components without sparse. This option is the opposite of the option above. This option is the opposite of the option WithoutSparseDirectDense.
- CompileFastAccess - Compiles the FastAccess for this component. Look in [State IComponent Component API section]
- HistoryNonSync - Do not save history for this component and it will not sync between devices. Main code should not depend on non-sync components. But non-sync components can be used in heavy computing and send the result via state.Send(event). For example, you can distribute AI computing to different devices.
- HistoryByChange - By default. Every time a component is accessed through the get method, the ECS saves the entire storage (all components of this type) to the history buffer. This happens no more than once per tick. For example, with two calls to Get<Health>, the save will happen only once per tick. Dynamic collection is also saved by the get method.
- HistoryByTick - Save storage (all components of this type) every tick. Always saves storage (all components of this type) every tick. Always saves storage (all components of this type) every tick. read or get methods have the same performance and are faster than HistoryByChange.
- HistoryByEveryChange - Saves the component to the history buffer each time the get method is called. Unlike HistoryByChange, only this component is saved.
- Compact
> [Section not ready, Placeholder]

## Configuration/IConfig
The configuration component is used to store initialization data. Like ScriptableObject in Unity.
The IConfig interface is marked configuration class/struct.

> [!IMPORTANT]
> Config is immutable data. Any changes config component is a desync. All configuration must be added to the world before any logic is executed on the systems.

> [!TIP]
> Config can be a managed object. Also, no other component interfaces can be used in the configuration.
```csharp
public struct LevelConfig : IConfig
{
    public List<uint> allEnemyTypesOnThisLevel;
}

public class MySystem0 : ICreateSystem,
{
    // The system can only store constant data. Or better don't store anything in system.
    List<uint> allEnemyTypesOnThisLevel;
	
    public void OnCreate(State state)
    { 
        allEnemyTypesOnThisLevel = state.GetConfig<LevelConfig>().allEnemyTypesOnThisLevel;
    }
}
```

Configuration can be added inside a feature, systems or through the world.
```csharp
world.AddConfig(new DamagePowerConfig());
// Or
public struct DamageFeature : IFeature
{
    // The install is called earlier than any systems interface/events.
    public void Install(ref InstallContext context)
    {
      context.AddConfig<DamagePowerConfig>(new DamagePowerConfig());
    }
}
// Or
public struct MySystem0 : ICreateSystem
{	
    public void OnCreate(State state)
    {
        // In this case, some other system may request the DamagePowerConfig before the MySystem0 called.
        state.AddConfig<DamagePowerConfig>(new DamagePowerConfig());
    }
}
// Or
public struct ClassFeature : Feature          //Feature class instead of IFeature interface.
{	
    public override void OnInstall(ref InstallContext context){ }
}
// Or
var systems = new SystemGroup()               // Look in [SystemGroup section]
{
    new ClassFeature().AddConfig(new DamagePowerConfig()),
};
```

## World Api
The world can work both in the main thread and in its own. Additionally, systems can request the main thread for themselves, even if the world is running on its own thread.

```csharp
IWorld _world;

_world = new World(systems, state, WorldThreadingLevel.MainThreadOnly);   // Create a world that runs in non-multithreaded mode.
_world = new World(systems, state, WorldThreadingLevel.OneThread);        // Create a world that runs in multithreaded mode. This world is runned in a new thread.

// Returns the identifier of the world, this identifier can be reused if the world has been disposed.
uint id = _world.Id;

// Call once before any other methods, except GetState & SetState.
_world.Init();

// [for WorldThreadingLevel.MainThreadOnly world option] Immediately simulate ticks.
// [for WorldThreadingLevel.OneThread world option] Shedule ticks.
// tickCount — how many ticks to simulate.
_world.Tick(tickCount);

// [for WorldThreadingLevel.MainThreadOnly world option] Immediately call Destroy in Systems.
// [for WorldThreadingLevel.OneThread world option] Shedule Destroy.
_world.Destroy();

// [for WorldThreadingLevel.MainThreadOnly world option] Immediately call Dispose.
// [for WorldThreadingLevel.OneThread world option] Immediately call Dispose. And wait until threads are ready to down.
_world.Dispose();

// Send event to buffer. The event is applied on the next tick. Look in [Events/IEvent section]
_world.SendEvent(@event);

// [for WorldThreadingLevel.MainThreadOnly world option] Doing nothing.
// [for WorldThreadingLevel.OneThread world option] Immediately call systems that schedule a call on the main thread. Look in [Threading section]
_world.UpdateFromMainThread();
```

## Events/IEvent
An event is a way for external code to interact with ecs.
The event is received by the system with IReceiverSystem interface.
Event can be managed or unmanaged object, class or struct.

Declare event:
```csharp
// The event is marked by IEvent. Also look in [Serialize section]
public struct InputEvent : IEvent, ISerialize
{
    public Command command;

    // Custom serialization for better performance. This is optional.
    public void Pack(ref WriterContextSerializer writer)
    {
        writer.Write(command);
    }

    // Custom serialization for better performance. This is optional.
    public void Unpack(ref ReaderContextSerializer reader)
    {
        command = reader.ReadEnum<Command>();
    }

    public enum Command
    {
        Jump,
        Shoot,
    }
}
```

Receive event:
```csharp
public class MySystem0 : IReceiverSystem<InputEvent>
{
    // Call when a new event arrives for the current tick from world.Send();
    public void Receive(State state, InputEvent @event)
    {
        if (@event.command == InputEvent.Command.Jump)
        {
            // ...
        }
    }
}
```

Send event:
SendEvent is thread-safe.
```csharp
_world.SendEvent(new InputEvent() { command = InputEventCommand.Jump });  // Send an event to next tick.
```

You can also send a event to a specific tick.
```csharp
_world.SendEvent(new BackTimeEvent() { Tick = _world.CurrentTick - 10, Value = new InputEvent() });  // Send an event to past.

internal struct BackTimeEvent : ITickEvent, ISerialize
{
    public uint Tick { get; private set; }
    public IEvent Value { get; private set; }

    public void Pack(ref WriterContextSerializer writer)
    {
        writer.Write(Tick);
        writer.Pack(Value);
    }

    public void Unpack(ref ReaderContextSerializer reader)
    {
        Tick = reader.ReadUInt32();
        Value = reader.Unpack<IEvent>();
    }
}
```

## Signals
An signals is a way for ecs to interact with external code. It's like events in reverse.
> [!IMPORTANT]
> Ecs signals can be canceled if, as a result of the time rollback, the signal did not happened.

> [Section not ready, Placeholder]

## State Api
State storage all game data.
> [!IMPORTANT]
> Don't store data outside of State instead use ISingle or IConfig for data.

### State Entity API:
There are 2 ways to work with entities:
- Entity as identifier, more performance, less comfortable.
- Entity as object, less performance, more comfortable.

```csharp
public class MySystem0 : ITickSystem<StateCompile>
{
    public void OnTick(StateCompile state)
    {
        // 1. Entity as identifier.
        uint entityId = state.New();         // Create new entity and return entityId.
        state.Delete(entityId);              // Delete entity by entityId.
        bool isHas = state.IsHas(entityId);  // Does an entity with an entity id exists?
		
        // 2. Entity as object.
        Entity entity = state.NewEntity();  // Create new entity and return entity object.
        entity.Delete();                    // Delete entity by entityId.
		
        bool isHas = entity.IsHas();        // Does an entity with an entity id exists?
        bool isValid = entity.IsValid;      // An entity may be invalid if it was not obtained from ECS.
		
        // Entity converts
        if (entity.TryToEntityId(out uint entityId))         // Convert entity object to entity identifier.
        {
            // entity valid and exists, so it's ok.
        }
		
        if (state.TryToEntity(entityId, out Entity entity))  // Convert entity identifier to entity object.
        {
            // entityId valid and exists, so it's ok.
        }
		
        entityId = entity.ToEntityId();         // Convert entity object to entity identifier. If failed, throw an EntityCastException.
        entity = state.ToEntity(entityId);      // Convert entity identifier to entity object. If failed, throw an EntityCastException.
		
        // Total entity exists.
        uint total = state.EntityCount;
    }
}
```

### State IComponent Component API:
Section on how to access the Multi Component aka IComponent.

> [!TIP]
> If the component already exists, throw a ComponentExistsException.
> If the component does not exist, throw a ComponentNotFoundException.

The API have Read & Get methods. By default ecs push component data to history buffer when get method called (one push per tick without duplicates). Using the get method without changing the component is slower by default.
About history options look in [Component Options section].

There are 3 ways to work with components:
- Entity-oriented. Easier to coding. Minimum perfomance.
- Storage-oriented. Something in between.
- FastAccess. More difficult to code. Maximum perfomance. Work only for Concrete Systems. Look in [Systems section]

```csharp
public class MySystem0 : ITickSystem<StateCompile>
{
    public void OnTick(StateCompile state)
    {
        // Entity as identifier.
        uint entityId = state.New();              // Create new entity and return entityId.
        Entity entity = state.NewEntity();        // Create new entity and return entity object.
		
        // Get the total of components in an entity.
        uint total = state.GetCount(entityId);
        uint total = entity.GetCount();
		
        Health health0 = state.Create<Health>();  //Create a new component of type Health. Look in [Create new component section]
		
        // Add and get new component of type Health.
        ref Health health1 = ref state.Fast.Health.Add(entityId);
        ref Health health1 = ref state.Add<Health>(entityId);
        ref Health health1 = ref entity.Add<Health>();
		
        // Add exists component.
        state.Fast.Health.Add(entityId, health0);
        state.Add(entityId, health0);
        entity.Add(health0);
		
        // Add exists component with prevent struct coping.
        state.Fast.Health.Add(entityId, ref health0);
        state.Add(entityId, ref health0);
        entity.Add(ref health0);
		
        // Remove component.
        state.Fast.Health.Remove<Health>(entityId);
        state.Remove<Health>(entityId);
        entity.Remove<Health>();
		
        // Remove component by index. It is very slow and can be used to write generic code. ComponentIndex range [0, state.GetCount(entityId) - 1].
        state.Remove(entityId, componentIndex);
		
        // Checks whether a component exists.
        bool isHas = state.Fast.Health.IsHas<Health>(entityId);
        bool isHas = state.IsHas<Health>(entityId);
        bool isHas = entity.IsHas<Health>();
		
        // Get version of component. Version is valid only for IVersion component otherwise returns 0. Look in [Component Interfaces section]
        uint tickVersion = state.Fast.Health.GetVersion(entityId);
        uint tickVersion = state.GetVersion<Health>(entityId);
        uint tickVersion = entity.GetVersion<Health>();
		
        // Read-only
        ref readonly var health2 = ref state.Fast.Health.Read(entityId);
        ref readonly var health2 = ref state.Read<Health>(entityId);	
        ref readonly var health2 = ref entity.Read<Health>();

        // Get
        ref var health2 = ref state.Get<Health>(entityId);
        ref var health2 = ref state.Get<Health>(entityId);	
        ref var health2 = ref entity.Get<Health>();
    }
}
```

### State ISingle Component API:
Single component is created in only one instance. Api is very similar to [State IComponent Component API]
```csharp
public class MySystem0 : ITickSystem<StateCompile>
{
    public void OnTick(StateCompile state)
    {
        //Create a new component of type MySingle. Look in [Create new component section]
        MySingle mySingle0 = state.Create<MySingle>();

        // Add and get new component of type MySingle.
        ref MySingle mySingle1 = ref state.Add<MySingle>();
        state.Fast.MySingle.Add();

        // Remove component.
        state.Remove<MySingle>();
        state.Fast.MySingle.Remove();

        // Add exists component with prevent struct coping.
        state.Add<MySingle>(mySingle0);
        state.Fast.MySingle.Add(mySingle0);

        // Add exists component.
        state.Add<MySingle>(ref mySingle0);
        state.Fast.MySingle.Add(ref mySingle0);

        // Add or Set component without ComponentExistsException.
        state.SetOrAdd(mySingle0);
        state.Fast.MySingle.SetOrAdd(mySingle0);

        // Add or Set component without ComponentExistsException.
        state.SetOrAdd(ref mySingle0);
        state.Fast.MySingle.SetOrAdd(ref mySingle0);

        // Checks whether a component exists.
        bool isHas = state.IsHas<MySingle>();
        bool isHas = state.Fast.MySingle.IsHas();

        // Get a read-only component.
        ref readonly var mySingle2 = ref state.Read<MySingle>();
        ref readonly var mySingle2 = ref state.MySingle.Read();

        // Get a read/write component.
        ref var mySingle2 = ref state.Get<MySingle>();
        ref var mySingle2 = ref state.MySingle.Get();
    }
}
```

## Create new component
There are 2.5 ways to create component:
```csharp
public class MySystem0 : ITickSystem<StateCompile>
{
    public void OnTick(StateCompile state)
    {
        // 1.0
        MyComponent component0 = state.Create<MyComponent>();  // Only create.
        state.Add(entityId, ref component0);                   // Add to entity.
		
        // 2.0
        // or
	      // Create and add to entity.
        ref MyComponent component1 = ref state.Add<MyComponent>(entityId);
		
        // 2.5
        // This way work only with simple component without IDefault, Dynamic Collection.
        MyComponentComplex componentComplex = new MyComponentComplex();		// C# new().
        // Error: array is not binded to state. Look in [Collections section]
        componentComplex.array.Allocate(5);
        // Add to entity. Error: componentComplex is not in a valid state.
        state.Add(entityId, ref componentComplex);
    }
	
    public struct MyComponentComplex : IDefault
    {
        // In case 2.5 dynamic collection is not binded to state. And always invalid.
        public DArray<int> array;

        // In case 2.5 this method is never called.
        public void Setup(State state) { }
    }
}
```

## Filters
Filters iterate through an entities that match the conditions.
There are 2 filter types:
- Id Filter. Filter returns entity as id.
- Entity Filter. Filter returns entity as object.

```csharp
public class MySystem0 : ICreateSystem
{
    public void OnCreate(State state)
    {
        // Create new id filter. Also look in [Injects section]
        IdFilter<Health> idFilter = state.Filter()		
            .With<Health>()          // Entity with Health.
            .Without<Immortal>()     // Entity without Immortal.
            .BuildAsId();

        // Create new entity filter. Also look in [Injects section]
        EntityFilter<Health> entityFilter = state.Filter()	
            .With<Health>()
            .Without<Immortal>()
            .WithShared(new UnitType() { value = 42 })     // [Section not ready, Placeholder].
            .WithoutShared(new UnitType() { value = 42 })  // [Section not ready, Placeholder].
            .BuildAsEntity();
			
        foreach(var id in idFilter)
        {
            state.Get<Health>(id).value = 42;
        }

        foreach (var entity in entityFilter)
        {
            entity.Get<Health>().value = 42;
        }
		
        //Short version.
        IdFilter<Health, Unit> idFilterShort = state.FilterId<Health, Unit>()
        EntityFilter<Health, Unit> idFilterShort = state.FilterEntity<Health, Unit>()
    }
}
```

## QFilters
Filters iterate through the store with components of the same type.

```csharp
public class MySystem0 : ICreateSystem
{
    public void OnCreate(State state)
    {
        QFilter<Health> qFilter = state.QFilter<Health>();  // Create new entity qfilter. Also look in [Injects section]
        qFilter.Each(new HealthIIterator() { regen = 1 });  // Executes an iterator for each component.
    }
	
    private struct HealthIIterator : IIterator<Health>
    {
        public int regen; 

        public void Each(ref Health data)
        {
            data.value += regen;
        }
    }
}
```

## Features/IFeature
The feature adds systems and configs. Features can be used for better organization of code.

> [!TIP]
> Features can have the same behavior as a system. Implement ICreateSystem, ITickSystem, etc.

```csharp
public struct DamageFeature : IFeature
{
    private DamagePowerConfig _damagePowerConfig;
	
    public DamageFeature(DamagePowerConfig damagePowerConfig)		// Pass configs.
    {
        _damagePowerConfig = damagePowerConfig;
    }
	
    public void Install(ref InstallContext context)
    {
        // Determines how to sort systems. Look in [SystemGroup section]
        context.SystemSortOrder = SortOrder.Declaration;			

        // The configuration can be added either inside the feature or in the world.AddConfig(damagePowerConfig).
        context.AddConfig<DamagePowerConfig>(_damagePowerConfig);

        // Add system to Feature SystemGroup.
        context.AddSystem(new DamageDealerSystem());
    }
}
```

There is a shorter way to pass configs to a feature. Use the Feature class and add configs through it.
```csharp
public struct ClassFeature : Feature    //Feature class instead of IFeature interface.
{	
    public override void OnInstall(ref InstallContext context)
    {
        context.SystemSortOrder = SortOrder.Declaration;

        // Request config from outside code. Throw a FeatureRequestConfigException if the configuration is not found.
        context.RequestConfig<HealthConfig>();						

        // Add system to Feature SystemGroup.
        context.AddSystem(new DamageDealerSystem());
    }
}

// Outside code.
var systems = new SystemGroup()    // Look in [SystemGroup section]
{
    new ClassFeature()
        .AddConfig(new DamagePowerConfig())        // Pass configs.
        .AddConfig(new HealthConfig())
        .AddConfig(new MyConfig0(), new MyConfig1()),
};
```

## Injects
The inject attribute will automatically assign data to fields if possible.
Inject uses reflection and is not currently accelerated by code generation.

```csharp
public class MySystem0 : ICreateSystem
{
    [Inject]
    IdFilter<Health> _iFilter;      // state.FilterId<Health>() equivalent.
	
    [Inject]
    EntityFilter<Health> _eFilter;  // state.EntityFilter<Health>() equivalent.
	
    [Inject]
    QFilter<Health> _qfilter;       // state.QFilter<Health>() equivalent.
	
    [Inject]
    HealthConfig _myIConfig;        // state.GetConfig<HealthConfig>() equivalent.
}
```

## Aspects
> [Section not ready, Placeholder]

## Collections
You can't use C# built-in collections in unmanaged rollback components. That's why there are Dynamic Collections, Shared Dynamic Collections and Fixed Collections.

### Fixed Collection
Fixed collections are built into the component and are limited in size.
- Stored inside the component.
- The size cannot be changed at runtime.
- Best used for small collections. Less than 8-16 elements.
- If the collection has reached the limit then throw an exception.

Collections types:
- FArray#SIZE#<#TYPE#> - like a array, where #SIZE# - size of array, #TYPE# - element type.
```csharp
public struct MyComponent : IComponent
{
    public FArray2<Entity> arraySizeOf2;
    public FArray16<ulong> arraySizeOf16;
}
```

- FList#SIZE#<#TYPE#> - like a list, where #SIZE# - size of list, #TYPE# - element type.
```csharp
public struct MyComponent : IComponent
{
    public FList2<Entity> listSizeOf2;
    public FList16<ulong> listSizeOf16;
}
```

- FString#SIZE# - like a string, where #SIZE# - size of string.
```csharp
public struct MyComponent : IComponent
{
    public FString16 name;
}
```

> [!TIP]
> Define ANOTHERECS_UNSAFE_FCOLLECTION to speed up fixed collection. But in this case, fixed collections should not be stored inside reference types.

### Dynamic Collection
- Stored outside the component.
- Dynamic collection must first be allocated before it can be used.
- Resizable in runtime.
- Not copied or shared between components.

Dynamic collections inherit the owner component options. (ComponentOptions.HistoryNonSync, ComponentOptions.HistoryByChange, etc.)

> [!TIP]
> Add/Remove dynamic collections to a component requires generation code.

- DArray<#TYPE#> - array, where #TYPE# - element type.
```csharp
public struct MyComponent : IComponent
{
    public DArray<int> array;
}

ref var refСollection = ref component0.array;    // Ok.

refСollection.IsValid;           // False if the collection has not allocated memory.
refСollection.Allocate(5);       // Allocate 5 elements. Call before use collection.
refСollection.Allocate(10);      // Deallocate old data then Allocate 10 elements.
refСollection.Deallocate();      // Deallocate data.
refСollection.Resize(10);        // Resize array with save data.

refСollection[0] = 42;           // Set 0 element is 42.

ref readonly var first = ref refСollection.Read(0);  // Read-only.
ref var first = ref refСollection.Get(0);            // Read/write.

// Errors:
var collection0 = component0.array;    // Error: Not copied or shared between components.
collection0[0] = 5;                    // Error: UB.

component1.array = component0.array;  // Error: Not copied or shared between components. UB.

component0.array = new DArray<int>(); // Error: invalid collection.
```

```csharp
public struct MyComponent : IComponent
{
    public DList<int> list;
}

ref var refСollection = ref component0.list;

refСollection.IsValid;        // False if the collection has not allocated memory.
refСollection.Allocate(5);    // Allocate 5 elements.
refСollection.Allocate(10);   // Deallocate old data then Allocate 10 elements.
refСollection.Deallocate();		// Deallocate data.

refСollection.Add(24);        // Add 24 and automatically resize if necessary.
refСollection.Remove(24);     // Remove 24.

refСollection.list[0] = 42;   // Set 0 element is 42.

ref readonly var first = ref refСollection.Read(0);  // Read-only.
ref var first = ref refСollection.Get(0);            // Read/write.	
```


- DDictionary<#KEY#, #VALUE#> where #KEY# - key type, #VALUE# - value type.
```csharp
public struct MyComponent : IComponent
{
    public DDictionary<int, FString8> dictionary;
}

ref var refСollection = ref component0.dictionary;

refСollection.IsValid;                    // False if the collection has not allocated memory.
refСollection.Allocate(5);                // Allocate start size.
refСollection.Add(1, (FString8)"Apple");  // Add value and automatically resize if necessary.
refСollection.Remove(1);                  // Remove key.
```

- DHashSet<#VALUE#> where #VALUE# - value type.
```csharp
public struct MyComponent : IComponent
{
    public DHashSet<int> hashSet;
}

ref var refСollection = ref component0.hashSet;

refСollection.Allocate(5);          // Allocate start size.
refСollection.Add(1);               // Add value and automatically resize if necessary.
refСollection.Remove(1);            // Remove key.
```

- DString.
```csharp
public struct MyComponent : IComponent
{
    public DString str;
}

ref var refStr = ref component0.str;

refStr.Set("Text");                // Set string value. Same CopyFrom().
string str = refStr.ToString();    // Convert to string.

var fStr8 = (FString8)"Apple";
if (refStr == "Text" || refStr == fStr8)
{
    // ..
}

refStr.CopyFrom("Apply");        // Copy from string.
refStr.CopyFrom(fStr8);          // Copy from FString.
refStr.CopyFrom(dString2);       // Copy from DString.
```

### Shared Dynamic Collection
- Stored outside the component.
- Dynamic collection must first be allocated before it can be used.
- Resizable in runtime.
- Can be copied or shared between components.
- Slower than Dynamic Collection.
> [Section not ready, Placeholder]

## Threading
ECS thread-safe for each worlds.

```csharp
var world = new World(systems, state, WorldThreadingLevel.OneThread);     // // Create a world that runs in single thread mode. This world is runned in a new thread.

// The simulation is called in a new thread.
world.Tick(tickCount);
world.Destroy();
world.Dispose();

// This method requires a call from the main thread.
world.UpdateFromMainThread();

// True id the world has a task, and the threads are working.
world.IsBusy();
// Block thread and wait for threads to complete. IMainThread will also be completed.
// This method requires a call from the main thread.
world.Wait();
```

The system can select a thread to execute.
- ISyncThread - Option by default. The system must be called sequentially relative to other systems.
- IASyncThread - The system can be called in parallel relative to other systems. [Section not ready, Placeholder]
- IMainThread - The system must be called from main thread. This happen when calling world.UpdateFromMainThread().
> [!TIP]
> IMainThread can be used to execute unity jobs or communicate with external code.

```csharp
public class MySystem0 : ITickSystem, IMainThread    // IMainThread
{
    [Inject]    // Look in [Injects section]
    IdFilter<Health> _filter;
	
    public void OnTick(State state)
    {
        // [Unity] Unity jobs require a main thread. Look in [[Unity] Jobs support section]
        _filter.AsJobParallel(new MyJob()).Complete();
    }
}
```

## Universe
> [Section not ready, Placeholder]

## Remote/Network
> [Section not ready, Placeholder]

## Code Generation
> [Section not ready, Placeholder]

## [Unity] Views
Views display entities. 
Steps to set up and add a new view.
- Create new GameObject or Prefab.
- Attach #View Name# : EntityView or #View Name# : ComponentView<> to GameObject/Prefab.
- Add view component to UnityViewController -> views field.
- Add UnityViewModule(unityViewController) to world.

Add module:
```csharp
IEnumerable<MonoBehaviourView> views;    // Place an existing prefabs into a variable from scene, resources, etc. MonoBehaviourView is a super class for unity views.
_world = new World(new UnityViewModule(views), state, WorldThreadingLevel.MainThreadOnly)
// Or
UnityViewController unityViewController; // Place an existing UnityViewController from scene, resources, etc. UnityViewController is a MonoBehaviour with IEnumerable<MonoBehaviourView> data.
_world = new World(new UnityViewModule(unityViewController), state, WorldThreadingLevel.MainThreadOnly)
```

There are 2 options to display entities:

- One entity - one unique view class (Class type as Id).
```csharp
public class HeroView : EntityView								// MonoBehaviour.
{
    private HealthBar _healthBar;
	
    public override void OnCreated(ref EntityReadOnly entity) { }

    public override void OnApply(ref EntityReadOnly entity) 	// Called every tick finished phase.
    {
        transform.position = (Vector3)entity.Read<Position>().value;
		
        _healthBar.Value = (float)entity.Read<Health>().value;
        _healthBar.ValueMax = (float)entity.Read<HealthMax>().value;
    }

    public override void OnDestroyed() { }
}
```

- One entity - several view classes, so you can split the one big view for display components into different classes.
```csharp
public class PositionView : ComponentView<Position>      // MonoBehaviour.
{
    public override void OnApply(in Position component)  // Called every tick finished phase. Called only if components exist.
    {
        transform.position = (Vector3)component.value;
    }
}

public class HealthView : ComponentView<Health, HealthMax>	// MonoBehaviour.
{
    private HealthBar _healthBar;
	
    public override void OnApply(in Health component0, in HealthMax component1)		// Called only if both components exist.
    {
        _healthBar.Value = (float)component0.value;
        _healthBar.ValueMax = (float)component1.value;
    }
}
```
You can also combine both ways.
> [!TIP]
> It's better to place the EntityView at the top of the list of GameObject/Prefab components, because the EntityView has a guid.

Views have 3 ways to be identified.

- By ID. The ID is not const and can be changed if you add/remove a new view prefab.
- By Type. Different views can have the same Type. For example HealthView can attached to prefab Hero and prefab Enemy.
```csharp
public void OnCreate(State state)
{
    state.CreateView<HealthView>(entityId);    // Warr: Will create the first view found.
    state.CreateView<HeroView>(entityId);      // Ok: HeroView is one view on prefab.
}
```
> [!TIP]
> This way is good for [One entity - one unique view class].

- By GUID. Accurately identifies the view.
> [!TIP]
> You can have many MonoBehaviourView in a prefab but only one GUID. It will use the GUID of the component that was added to UnityViewController -> views field.
> By default, the Inspector adds a top component by drag and drop.

You can embed the GUID in the code.
```csharp
public class HeroView : EntityView
{
    public override ViewGuid GetGUID()    // Override the GUID from the inspector.
        => new("override guid");
}
```

```csharp
public void OnCreate(State state)
{
    var guid_hero = new ViewGuid("guid-hero");
		
    uint viewId0 = state.GetViewId<HeroView>();
    uint viewId1 = state.GetViewId("guid-hero");
    uint viewId2 = state.GetViewId(guid_hero);
		
    // Entity as Id
    uint id = state.New();
		
    state.CreateView<HeroView>(id);     // Create
    state.CreateView("guid-hero", id);
    state.CreateView(guid_hero, id);
    state.CreateView(viewId0, id);
		
    state.ChangeView<EnemyView>(id);    // Create or change
    state.ChangeView("guid-enemy", id);
    state.ChangeView(guid_enemy, id);
    state.ChangeView(viewId0, id);
		
    state.DestroyView(id);              // Destroy
		
    // Entity as object
    Entity entity = state.NewEntity();
		
    entity.CreateView<HeroView>();      // Create
    entity.CreateView("guid-hero");
    entity.CreateView(guid_hero);
    entity.CreateView(viewId0);
		
    entity.ChangeView<EnemyView>();    // Create or change
    entity.ChangeView("guid-enemy");
    entity.ChangeView(guid_hero);
    entity.ChangeView(viewId0);
		
    entity.DestroyView();              // Destroy
}
```

## [Unity] Jobs support
```csharp
public class MySystem0 : ITickSystem
{
    [Inject]    // Look in [Injects section]
    IdFilter<Health> _filter;
	
    public void OnTick(State state)
    {
        // Jobs works only for IdFilter.
        // Write/Read jobs:
        _filter.AsJobParallel(new MyJobParallel()).Complete();    // Create and execute parallel job.
        _filter.AsJob(new MyJob()).Complete();                    // Create and execute job.
		
        // Read-only jobs:
        _filter.AsJobParallelR(new MyJobParallelReadOnly()).Complete();  // AsJobParallel**R**
        _filter.AsJobR(new MyJobReadOnly()).Complete();                  // AsJob**R**
    }
}

[BurstCompile]
private struct MyJobParallel : IJobParallelForBag<JobBag<Health>>
{
    public void Execute(ref JobBag<Health> bag, int index)    // Index range [0, bag.Count - 1].
    {
        int count = bag.Count;                // Total entity.
		
        uint id = bag.GetEntityId(index);     // Get entity id by index.
		
        bool isHas = bag.HasT0(index);        // Does the component exist?
		
        Health health = bag.ReadT0(index);    // Read by value.
		
        ref Health health = ref bag.GetT0(index);  // Get by ref.

        uint version = ReadVersionT0(index);       // Get component version. Throw ComponentNotSupportVersionException if the component does not use IVersion.
    }
}

[BurstCompile]
private struct MyJob : IJobForBag<JobBag<Health>>
{
    public void Execute(ref JobBag<Health> bag)
    {
        for(int i = 0; i < bag.Count; ++i)
        {
            bag.GetT0(i).value = 42;
        }
    }
}

[BurstCompile]
private struct MyJobParallelReadOnly : IJobParallelForBag<JobBagR<Health>>  // JobBag**R**
{
    public void Execute(ref JobBagR<Health> bag, int index) { }  // JobBag**R**
}

[BurstCompile]
private struct MyJobReadOnly : IJobForBag<JobBagR<Health>>  // JobBag**R**
{
    public void Execute(ref JobBagR<Health> bag) { }  // JobBag**R**
}
```

Jobs for dynamic collection:
```csharp
public struct MyComponent : IComponent
{
    public DArray<uint> array;
}

myComponent.array.AsJob(state, new Job()).Complete();
myComponent.array.AsJobParallel(state, new JobParallel()).Complete();

public struct Job : IJobForBag<JobCollectionBag<uint>>
{
    public void Execute(ref JobCollectionBag<uint> bag)
    {
        int count = bag.Count;
        uint element0 = bag.Read(0);
        ref uint element0 = ref bag.Get(0);
    }
}

public struct JobParallel : IJobParallelForBag<JobCollectionBag<uint>>
{
    public void Execute(ref JobCollectionBag<uint> bag, int index) { }
}
```
> [!TIP]
> Collection jobs also have a  AsJob**R** and AsJobParallel**R**.

## Deterministic Mathematics
Deterministic Mathematics located at namespace AnotherECS.Mathematics.
For guaranteed determinism, use sfloat instead of float.
[Unity] Use AnotherECS.Mathematics.float#SIZE# instead of UnityEngine.Vector#SIZE#. AnotherECS.Mathematics.quaternion instead of UnityEngine.Quaternion.

## Random
For random you can use a custom component:
```csharp
public struct MyRandom : ISingle
{
    public AnotherECS.Mathematics.Random value;
}

state.Get<MyRandom>().value = new AnotherECS.Mathematics.Random(seed);
sfloat rand01 = state.Get<MyRandom>().value.NextFloat();
```

Or RandomFeature:
```csharp
namespace AnotherECS.Random;

systems.Add(new RandomFeature());							// Add RandomFeature to SystemGroup.
_world = new World(systems, state);

public class MySystem0 : ITickSystem,
{
    public void OnTick(State state)
    { 
        sfloat rand01 = state.GetRandom().NextFloat(1, 5);	// Get random sfloat [1, 5). Throw FeatureNotExists if RandomFeature is not attached.
    }
}
```

## [Unity] Visual Debugging
Unity Visual Debugging creates a hierarchy of worlds in the Unity Inspector with entities and components.
- Component/Entity editing support.
- Changes are applied on the next tick.
- Delete Entity GameObject to delete Entity.
- Shows debugging information.

```csharp
_world = new World(new DiagnosticModule(), state, WorldThreadingLevel.MainThreadOnly);
```

## Defindes
ANOTHERECS_RELEASE - set ecs to release mode. Disables almost all safe checks. In case of an error in the game logic, a crash is possible.
> [!IMPORTANT]
> It is preferable to develop in debug mode. Before set define, make sure ecs code gen is in a fresh state. For manual generate code use AnotherECS -> Compile.

ANOTHERECS_STATISTIC - Collects statistics from worlds. If ANOTHERECS_RELEASE is not set, statistics will also be collected. To get statistics use world.GetStatistic().

ANOTHERECS_UNSAFE_FCOLLECTION - Speed up fixed collection. But in this case, fixed collections should not be stored inside reference types.

ANOTHERECS_HISTORY_DISABLE - Disables rollback for all ecs.

## Example project
> [Section not ready, Placeholder]
