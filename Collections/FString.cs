//GENERATOR = AnotherECS.Editor.Generator.FStringGenerator FILENAME = FString.cs

// <auto-generated>
// This source code was auto-generated by FStringGenerator.cs
// </auto-generated>

using System;
using System.Collections;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using System.Text;

namespace AnotherECS.Collections
{
    public unsafe struct FString2 : IEquatable<FString2>, IEnumerable<char>
    {
        public const int Capacity = 2;

        public int Length
            => _length;

        private ushort _length;
        private fixed char _data[2];


        public FString2(string text)
        {
            if (text.Length > Capacity)
            {
                throw new ArgumentException($"{nameof(text)} is longer than �apacity. Capacity: '{Capacity}'. text length '{text.Length}'");
            }

            for (int i = 0; i < text.Length; ++i)
            {
                _data[i] = text[i];
            }
            _length = (ushort)text.Length;
        }

        public static implicit operator string(FString2 fstring) => fstring.ToString();
        public static explicit operator FString2(string text) => new(text);

        public static FString2 operator +(FString2 a, FString2 b)
        {
            if (a.Length + b.Length > Capacity)
            {
                throw new OverflowException();
            }

            FString2 result = default;
            for(int i = 0; i < a.Length; ++i)
            {
                result._data[i] = a._data[i];
            }

            var offset = a.Length;
            for (int i = 0; i < b.Length; ++i)
            {
                result._data[i + offset] = b._data[i];
            }
            result._length = (ushort)(a.Length + b.Length);

            return result;
        }

        public static bool operator ==(FString2 a, FString2 b)
            => a.Equals(ref b);
        public static bool operator !=(FString2 a, FString2 b)
            => !a.Equals(ref b);

        public char this[int index]
        {
            get
            {
                if (index < 0 || index >= _length)
                {
                    throw new IndexOutOfRangeException();
                }
                return _data[index];
            }
            set
            {
                if (index < 0 || index >= _length)
                {
                    throw new IndexOutOfRangeException();
                }

                _data[index] = value;
            }
        }

        public override string ToString()
        {
            if (Capacity <= 16)
            {
                var text = string.Empty;
                for (int i = 0; i < Length; ++i)
                {
                    text += _data[i];
                }
                return text;
            }
            else
            {
#pragma warning disable CS0162
                var stringBuilder = new StringBuilder();
                for (int i = 0; i < Length; ++i)
                {
                    stringBuilder.Append(_data[i]);
                }
                return stringBuilder.ToString();
#pragma warning restore CS0162
            }
        }

        public override bool Equals(object obj)
        {
            if (obj is FString2 fString)
            {
                return Equals(fString);
            }
            return false;
        }

        public bool Equals(FString2 other)
            => Equals(ref other);

        public bool Equals(ref FString2 other)
        {
            if (_length == other._length)
            {
                for (int i = 0; i < _length; ++i)
                {
                    if (_data[i] != other._data[i])
                    {
                        return false;
                    }
                }
                return true;
            }
            return false;
        }

        public override int GetHashCode()
        {
            var hash = new HashCode();
            hash.Add(_length);
            for(int i = 0; i < _length; ++i)
            {
                hash.Add(_data[i]);
            }

            return hash.ToHashCode();
        }

        public IEnumerator<char> GetEnumerator()
            => new Enumerator(ref this);

        IEnumerator IEnumerable.GetEnumerator()
            => GetEnumerator();


        public struct Enumerator : IEnumerator<char>
        {
            private readonly FString2 _data;
            private int _current;

            public Enumerator(ref FString2 data)
            {
                _data = data;
                _current = -1;
            }

            public char Current
            {
                [MethodImpl(MethodImplOptions.AggressiveInlining)]
                get => _data[_current];
            }

            object IEnumerator.Current
                => _data[_current];

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public bool MoveNext()
                => ++_current < _data.Length;

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public void Reset()
            {
                _current = -1;
            }

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public void Dispose() { }
        }
    }
    public unsafe struct FString4 : IEquatable<FString4>, IEnumerable<char>
    {
        public const int Capacity = 4;

        public int Length
            => _length;

        private ushort _length;
        private fixed char _data[4];


        public FString4(string text)
        {
            if (text.Length > Capacity)
            {
                throw new ArgumentException($"{nameof(text)} is longer than �apacity. Capacity: '{Capacity}'. text length '{text.Length}'");
            }

            for (int i = 0; i < text.Length; ++i)
            {
                _data[i] = text[i];
            }
            _length = (ushort)text.Length;
        }

        public static implicit operator string(FString4 fstring) => fstring.ToString();
        public static explicit operator FString4(string text) => new(text);

        public static FString4 operator +(FString4 a, FString4 b)
        {
            if (a.Length + b.Length > Capacity)
            {
                throw new OverflowException();
            }

            FString4 result = default;
            for(int i = 0; i < a.Length; ++i)
            {
                result._data[i] = a._data[i];
            }

            var offset = a.Length;
            for (int i = 0; i < b.Length; ++i)
            {
                result._data[i + offset] = b._data[i];
            }
            result._length = (ushort)(a.Length + b.Length);

            return result;
        }

        public static bool operator ==(FString4 a, FString4 b)
            => a.Equals(ref b);
        public static bool operator !=(FString4 a, FString4 b)
            => !a.Equals(ref b);

        public char this[int index]
        {
            get
            {
                if (index < 0 || index >= _length)
                {
                    throw new IndexOutOfRangeException();
                }
                return _data[index];
            }
            set
            {
                if (index < 0 || index >= _length)
                {
                    throw new IndexOutOfRangeException();
                }

                _data[index] = value;
            }
        }

        public override string ToString()
        {
            if (Capacity <= 16)
            {
                var text = string.Empty;
                for (int i = 0; i < Length; ++i)
                {
                    text += _data[i];
                }
                return text;
            }
            else
            {
#pragma warning disable CS0162
                var stringBuilder = new StringBuilder();
                for (int i = 0; i < Length; ++i)
                {
                    stringBuilder.Append(_data[i]);
                }
                return stringBuilder.ToString();
#pragma warning restore CS0162
            }
        }

        public override bool Equals(object obj)
        {
            if (obj is FString4 fString)
            {
                return Equals(fString);
            }
            return false;
        }

        public bool Equals(FString4 other)
            => Equals(ref other);

        public bool Equals(ref FString4 other)
        {
            if (_length == other._length)
            {
                for (int i = 0; i < _length; ++i)
                {
                    if (_data[i] != other._data[i])
                    {
                        return false;
                    }
                }
                return true;
            }
            return false;
        }

        public override int GetHashCode()
        {
            var hash = new HashCode();
            hash.Add(_length);
            for(int i = 0; i < _length; ++i)
            {
                hash.Add(_data[i]);
            }

            return hash.ToHashCode();
        }

        public IEnumerator<char> GetEnumerator()
            => new Enumerator(ref this);

        IEnumerator IEnumerable.GetEnumerator()
            => GetEnumerator();


        public struct Enumerator : IEnumerator<char>
        {
            private readonly FString4 _data;
            private int _current;

            public Enumerator(ref FString4 data)
            {
                _data = data;
                _current = -1;
            }

            public char Current
            {
                [MethodImpl(MethodImplOptions.AggressiveInlining)]
                get => _data[_current];
            }

            object IEnumerator.Current
                => _data[_current];

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public bool MoveNext()
                => ++_current < _data.Length;

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public void Reset()
            {
                _current = -1;
            }

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public void Dispose() { }
        }
    }
    public unsafe struct FString8 : IEquatable<FString8>, IEnumerable<char>
    {
        public const int Capacity = 8;

        public int Length
            => _length;

        private ushort _length;
        private fixed char _data[8];


        public FString8(string text)
        {
            if (text.Length > Capacity)
            {
                throw new ArgumentException($"{nameof(text)} is longer than �apacity. Capacity: '{Capacity}'. text length '{text.Length}'");
            }

            for (int i = 0; i < text.Length; ++i)
            {
                _data[i] = text[i];
            }
            _length = (ushort)text.Length;
        }

        public static implicit operator string(FString8 fstring) => fstring.ToString();
        public static explicit operator FString8(string text) => new(text);

        public static FString8 operator +(FString8 a, FString8 b)
        {
            if (a.Length + b.Length > Capacity)
            {
                throw new OverflowException();
            }

            FString8 result = default;
            for(int i = 0; i < a.Length; ++i)
            {
                result._data[i] = a._data[i];
            }

            var offset = a.Length;
            for (int i = 0; i < b.Length; ++i)
            {
                result._data[i + offset] = b._data[i];
            }
            result._length = (ushort)(a.Length + b.Length);

            return result;
        }

        public static bool operator ==(FString8 a, FString8 b)
            => a.Equals(ref b);
        public static bool operator !=(FString8 a, FString8 b)
            => !a.Equals(ref b);

        public char this[int index]
        {
            get
            {
                if (index < 0 || index >= _length)
                {
                    throw new IndexOutOfRangeException();
                }
                return _data[index];
            }
            set
            {
                if (index < 0 || index >= _length)
                {
                    throw new IndexOutOfRangeException();
                }

                _data[index] = value;
            }
        }

        public override string ToString()
        {
            if (Capacity <= 16)
            {
                var text = string.Empty;
                for (int i = 0; i < Length; ++i)
                {
                    text += _data[i];
                }
                return text;
            }
            else
            {
#pragma warning disable CS0162
                var stringBuilder = new StringBuilder();
                for (int i = 0; i < Length; ++i)
                {
                    stringBuilder.Append(_data[i]);
                }
                return stringBuilder.ToString();
#pragma warning restore CS0162
            }
        }

        public override bool Equals(object obj)
        {
            if (obj is FString8 fString)
            {
                return Equals(fString);
            }
            return false;
        }

        public bool Equals(FString8 other)
            => Equals(ref other);

        public bool Equals(ref FString8 other)
        {
            if (_length == other._length)
            {
                for (int i = 0; i < _length; ++i)
                {
                    if (_data[i] != other._data[i])
                    {
                        return false;
                    }
                }
                return true;
            }
            return false;
        }

        public override int GetHashCode()
        {
            var hash = new HashCode();
            hash.Add(_length);
            for(int i = 0; i < _length; ++i)
            {
                hash.Add(_data[i]);
            }

            return hash.ToHashCode();
        }

        public IEnumerator<char> GetEnumerator()
            => new Enumerator(ref this);

        IEnumerator IEnumerable.GetEnumerator()
            => GetEnumerator();


        public struct Enumerator : IEnumerator<char>
        {
            private readonly FString8 _data;
            private int _current;

            public Enumerator(ref FString8 data)
            {
                _data = data;
                _current = -1;
            }

            public char Current
            {
                [MethodImpl(MethodImplOptions.AggressiveInlining)]
                get => _data[_current];
            }

            object IEnumerator.Current
                => _data[_current];

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public bool MoveNext()
                => ++_current < _data.Length;

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public void Reset()
            {
                _current = -1;
            }

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public void Dispose() { }
        }
    }
    public unsafe struct FString16 : IEquatable<FString16>, IEnumerable<char>
    {
        public const int Capacity = 16;

        public int Length
            => _length;

        private ushort _length;
        private fixed char _data[16];


        public FString16(string text)
        {
            if (text.Length > Capacity)
            {
                throw new ArgumentException($"{nameof(text)} is longer than �apacity. Capacity: '{Capacity}'. text length '{text.Length}'");
            }

            for (int i = 0; i < text.Length; ++i)
            {
                _data[i] = text[i];
            }
            _length = (ushort)text.Length;
        }

        public static implicit operator string(FString16 fstring) => fstring.ToString();
        public static explicit operator FString16(string text) => new(text);

        public static FString16 operator +(FString16 a, FString16 b)
        {
            if (a.Length + b.Length > Capacity)
            {
                throw new OverflowException();
            }

            FString16 result = default;
            for(int i = 0; i < a.Length; ++i)
            {
                result._data[i] = a._data[i];
            }

            var offset = a.Length;
            for (int i = 0; i < b.Length; ++i)
            {
                result._data[i + offset] = b._data[i];
            }
            result._length = (ushort)(a.Length + b.Length);

            return result;
        }

        public static bool operator ==(FString16 a, FString16 b)
            => a.Equals(ref b);
        public static bool operator !=(FString16 a, FString16 b)
            => !a.Equals(ref b);

        public char this[int index]
        {
            get
            {
                if (index < 0 || index >= _length)
                {
                    throw new IndexOutOfRangeException();
                }
                return _data[index];
            }
            set
            {
                if (index < 0 || index >= _length)
                {
                    throw new IndexOutOfRangeException();
                }

                _data[index] = value;
            }
        }

        public override string ToString()
        {
            if (Capacity <= 16)
            {
                var text = string.Empty;
                for (int i = 0; i < Length; ++i)
                {
                    text += _data[i];
                }
                return text;
            }
            else
            {
#pragma warning disable CS0162
                var stringBuilder = new StringBuilder();
                for (int i = 0; i < Length; ++i)
                {
                    stringBuilder.Append(_data[i]);
                }
                return stringBuilder.ToString();
#pragma warning restore CS0162
            }
        }

        public override bool Equals(object obj)
        {
            if (obj is FString16 fString)
            {
                return Equals(fString);
            }
            return false;
        }

        public bool Equals(FString16 other)
            => Equals(ref other);

        public bool Equals(ref FString16 other)
        {
            if (_length == other._length)
            {
                for (int i = 0; i < _length; ++i)
                {
                    if (_data[i] != other._data[i])
                    {
                        return false;
                    }
                }
                return true;
            }
            return false;
        }

        public override int GetHashCode()
        {
            var hash = new HashCode();
            hash.Add(_length);
            for(int i = 0; i < _length; ++i)
            {
                hash.Add(_data[i]);
            }

            return hash.ToHashCode();
        }

        public IEnumerator<char> GetEnumerator()
            => new Enumerator(ref this);

        IEnumerator IEnumerable.GetEnumerator()
            => GetEnumerator();


        public struct Enumerator : IEnumerator<char>
        {
            private readonly FString16 _data;
            private int _current;

            public Enumerator(ref FString16 data)
            {
                _data = data;
                _current = -1;
            }

            public char Current
            {
                [MethodImpl(MethodImplOptions.AggressiveInlining)]
                get => _data[_current];
            }

            object IEnumerator.Current
                => _data[_current];

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public bool MoveNext()
                => ++_current < _data.Length;

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public void Reset()
            {
                _current = -1;
            }

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public void Dispose() { }
        }
    }
    public unsafe struct FString32 : IEquatable<FString32>, IEnumerable<char>
    {
        public const int Capacity = 32;

        public int Length
            => _length;

        private ushort _length;
        private fixed char _data[32];


        public FString32(string text)
        {
            if (text.Length > Capacity)
            {
                throw new ArgumentException($"{nameof(text)} is longer than �apacity. Capacity: '{Capacity}'. text length '{text.Length}'");
            }

            for (int i = 0; i < text.Length; ++i)
            {
                _data[i] = text[i];
            }
            _length = (ushort)text.Length;
        }

        public static implicit operator string(FString32 fstring) => fstring.ToString();
        public static explicit operator FString32(string text) => new(text);

        public static FString32 operator +(FString32 a, FString32 b)
        {
            if (a.Length + b.Length > Capacity)
            {
                throw new OverflowException();
            }

            FString32 result = default;
            for(int i = 0; i < a.Length; ++i)
            {
                result._data[i] = a._data[i];
            }

            var offset = a.Length;
            for (int i = 0; i < b.Length; ++i)
            {
                result._data[i + offset] = b._data[i];
            }
            result._length = (ushort)(a.Length + b.Length);

            return result;
        }

        public static bool operator ==(FString32 a, FString32 b)
            => a.Equals(ref b);
        public static bool operator !=(FString32 a, FString32 b)
            => !a.Equals(ref b);

        public char this[int index]
        {
            get
            {
                if (index < 0 || index >= _length)
                {
                    throw new IndexOutOfRangeException();
                }
                return _data[index];
            }
            set
            {
                if (index < 0 || index >= _length)
                {
                    throw new IndexOutOfRangeException();
                }

                _data[index] = value;
            }
        }

        public override string ToString()
        {
#pragma warning disable CS0162
            if (Capacity <= 16)
            {
                var text = string.Empty;
                for (int i = 0; i < Length; ++i)
                {
                    text += _data[i];
                }
                return text;
            }
            else
            {
                var stringBuilder = new StringBuilder();
                for (int i = 0; i < Length; ++i)
                {
                    stringBuilder.Append(_data[i]);
                }
                return stringBuilder.ToString();
#pragma warning restore CS0162
            }
        }

        public override bool Equals(object obj)
        {
            if (obj is FString32 fString)
            {
                return Equals(fString);
            }
            return false;
        }

        public bool Equals(FString32 other)
            => Equals(ref other);

        public bool Equals(ref FString32 other)
        {
            if (_length == other._length)
            {
                for (int i = 0; i < _length; ++i)
                {
                    if (_data[i] != other._data[i])
                    {
                        return false;
                    }
                }
                return true;
            }
            return false;
        }

        public override int GetHashCode()
        {
            var hash = new HashCode();
            hash.Add(_length);
            for(int i = 0; i < _length; ++i)
            {
                hash.Add(_data[i]);
            }

            return hash.ToHashCode();
        }

        public IEnumerator<char> GetEnumerator()
            => new Enumerator(ref this);

        IEnumerator IEnumerable.GetEnumerator()
            => GetEnumerator();


        public struct Enumerator : IEnumerator<char>
        {
            private readonly FString32 _data;
            private int _current;

            public Enumerator(ref FString32 data)
            {
                _data = data;
                _current = -1;
            }

            public char Current
            {
                [MethodImpl(MethodImplOptions.AggressiveInlining)]
                get => _data[_current];
            }

            object IEnumerator.Current
                => _data[_current];

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public bool MoveNext()
                => ++_current < _data.Length;

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public void Reset()
            {
                _current = -1;
            }

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public void Dispose() { }
        }
    }
    public unsafe struct FString64 : IEquatable<FString64>, IEnumerable<char>
    {
        public const int Capacity = 64;

        public int Length
            => _length;

        private ushort _length;
        private fixed char _data[64];


        public FString64(string text)
        {
            if (text.Length > Capacity)
            {
                throw new ArgumentException($"{nameof(text)} is longer than �apacity. Capacity: '{Capacity}'. text length '{text.Length}'");
            }

            for (int i = 0; i < text.Length; ++i)
            {
                _data[i] = text[i];
            }
            _length = (ushort)text.Length;
        }

        public static implicit operator string(FString64 fstring) => fstring.ToString();
        public static explicit operator FString64(string text) => new(text);

        public static FString64 operator +(FString64 a, FString64 b)
        {
            if (a.Length + b.Length > Capacity)
            {
                throw new OverflowException();
            }

            FString64 result = default;
            for(int i = 0; i < a.Length; ++i)
            {
                result._data[i] = a._data[i];
            }

            var offset = a.Length;
            for (int i = 0; i < b.Length; ++i)
            {
                result._data[i + offset] = b._data[i];
            }
            result._length = (ushort)(a.Length + b.Length);

            return result;
        }

        public static bool operator ==(FString64 a, FString64 b)
            => a.Equals(ref b);
        public static bool operator !=(FString64 a, FString64 b)
            => !a.Equals(ref b);

        public char this[int index]
        {
            get
            {
                if (index < 0 || index >= _length)
                {
                    throw new IndexOutOfRangeException();
                }
                return _data[index];
            }
            set
            {
                if (index < 0 || index >= _length)
                {
                    throw new IndexOutOfRangeException();
                }

                _data[index] = value;
            }
        }

        public override string ToString()
        {
#pragma warning disable CS0162
            if (Capacity <= 16)
            {
                var text = string.Empty;
                for (int i = 0; i < Length; ++i)
                {
                    text += _data[i];
                }
                return text;
            }
            else
            {
                var stringBuilder = new StringBuilder();
                for (int i = 0; i < Length; ++i)
                {
                    stringBuilder.Append(_data[i]);
                }
                return stringBuilder.ToString();
#pragma warning restore CS0162
            }
        }

        public override bool Equals(object obj)
        {
            if (obj is FString64 fString)
            {
                return Equals(fString);
            }
            return false;
        }

        public bool Equals(FString64 other)
            => Equals(ref other);

        public bool Equals(ref FString64 other)
        {
            if (_length == other._length)
            {
                for (int i = 0; i < _length; ++i)
                {
                    if (_data[i] != other._data[i])
                    {
                        return false;
                    }
                }
                return true;
            }
            return false;
        }

        public override int GetHashCode()
        {
            var hash = new HashCode();
            hash.Add(_length);
            for(int i = 0; i < _length; ++i)
            {
                hash.Add(_data[i]);
            }

            return hash.ToHashCode();
        }

        public IEnumerator<char> GetEnumerator()
            => new Enumerator(ref this);

        IEnumerator IEnumerable.GetEnumerator()
            => GetEnumerator();


        public struct Enumerator : IEnumerator<char>
        {
            private readonly FString64 _data;
            private int _current;

            public Enumerator(ref FString64 data)
            {
                _data = data;
                _current = -1;
            }

            public char Current
            {
                [MethodImpl(MethodImplOptions.AggressiveInlining)]
                get => _data[_current];
            }

            object IEnumerator.Current
                => _data[_current];

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public bool MoveNext()
                => ++_current < _data.Length;

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public void Reset()
            {
                _current = -1;
            }

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public void Dispose() { }
        }
    }

}
