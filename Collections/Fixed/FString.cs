//GENERATOR = AnotherECS.Generator.FStringGenerator FILENAME = FString.cs

// <auto-generated>
// This source code was auto-generated by FStringGenerator.cs
// </auto-generated>

using AnotherECS.Core;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using System.Text;

namespace AnotherECS.Collections
{
    [ForceBlittable]
    public unsafe struct FString2 : IEquatable<FString2>, IEquatable<string>, IEquatable<ICString<char>>, IEnumerable<char>, ICString<char>
    {
		public static readonly FString2 Empty = new();
	
		private FList2<char> _data;

		public uint Capacity
		{
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			get => _data.Capacity;
		}
		
		public uint Length
		{
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			get => _data.Count;
		}

        public FString2(string text)
        {
			_data = default;
            if (text.Length > Capacity)
            {
                throw new ArgumentException($"{nameof(text)} is longer than capacity. Capacity: '{Capacity}'. text length '{text.Length}'");
            }

            for (int i = 0; i < text.Length; ++i)
            {
                _data[i] = text[i];
            }
            _data.Count = (uint)text.Length;
        }

        public static implicit operator string(FString2 fstring) => fstring.ToString();
        public static explicit operator FString2(string text) => new(text);

        public static FString2 operator +(FString2 a, FString2 b)
        {
            if (a.Length + b.Length > a.Capacity)
            {
                throw new ArgumentException($"Capacity not enough. Capacity: '{a.Capacity}'. Requirement: '{a.Length + b.Length}'.");
            }

            FString2 result = a;
            var offset = a.Length;
            for (uint i = 0; i < b.Length; ++i)
            {
                result._data[i + offset] = b._data[i];
            }
            result._data.Count = (a.Length + b.Length);

            return result;
        }

        public static bool operator ==(FString2 a, FString2 b)
            => a.Equals(ref b);

        public static bool operator !=(FString2 a, FString2 b)
            => !a.Equals(ref b);

        public static bool operator ==(FString2 a, ICString<char> b)
            => a.Equals(b);

        public static bool operator !=(FString2 a, ICString<char> b)
            => !a.Equals(b);

        public static bool operator ==(FString2 a, string b)
            => a.Equals(b);

        public static bool operator !=(FString2 a, string b)
            => !a.Equals(b);

        public char this[uint index]
        {
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => _data[index];
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
            set => _data[index] = value;
        }

        public void Set(string text)
        {
            this = new(text);
        }

        public override string ToString()
        {
#pragma warning disable CS0162
            if (Capacity <= 16)
            {
                var text = string.Empty;
                for (uint i = 0; i < Length; ++i)
                {
                    text += _data[i];
                }
                return text;
            }
            else
            {
                var stringBuilder = new StringBuilder();
                for (uint i = 0; i < Length; ++i)
                {
                    stringBuilder.Append(_data[i]);
                }
                return stringBuilder.ToString();
#pragma warning restore CS0162
            }
        }

         public override bool Equals(object obj)
        {
            if (obj is FString2 fString)
            {
                return Equals(ref fString);
            }
            else if (obj is ICString<char> iString)
            {
                return Equals(iString);
            }
            else if (obj is string cString)
            {
                return Equals(cString);
            }
            return false;
        }

        public bool Equals(string other)
        {
            if (Length == other.Length)
            {
                for (int i = 0; i < Length; ++i)
                {
                    if (_data[i] != other[i])
                    {
                        return false;
                    }
                }
                return true;
            }
            return false;
        }

        public bool Equals(FString2 other)
            => Equals(ref other);

        public bool Equals(ref FString2 other)
        {
            if (Length == other.Length)
            {
                for (uint i = 0; i < Length; ++i)
                {
                    if (_data[i] != other._data[i])
                    {
                        return false;
                    }
                }
                return true;
            }
            return false;
        }

         public bool Equals<TCString>(ref TCString other)
            where TCString : struct, ICString<char>
        {
            if (Length == other.Length)
            {
                for (uint i = 0; i < Length; ++i)
                {
                    if (!_data[i].Equals(other[i]))
                    {
                        return false;
                    }
                }
                return true;
            }
            return false;
        }

        public bool Equals(ICString<char> other)
        {
            if (Length == other.Length)
            {
                for (uint i = 0; i < Length; ++i)
                {
                    if (!_data[i].Equals(other[i]))
                    {
                        return false;
                    }
                }
                return true;
            }
            return false;
        }

        public override int GetHashCode()
        {
            HashCode hash = default;
            hash.Add(Length);
            for(uint i = 0; i < Length; ++i)
            {
                hash.Add(_data[i]);
            }

            return hash.ToHashCode();
        }

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
        public IEnumerator<char> GetEnumerator()
            => new Enumerator(ref this);

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
        IEnumerator IEnumerable.GetEnumerator()
            => GetEnumerator();


        public struct Enumerator : IEnumerator<char>
        {
            private readonly FString2 _data;
            private uint _current;

            public Enumerator(ref FString2 data)
            {
                _data = data;
                _current = uint.MaxValue;
            }

            public char Current
            {
                [MethodImpl(MethodImplOptions.AggressiveInlining)]
                get => _data[_current];
            }

            object IEnumerator.Current
                => _data[_current];

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public bool MoveNext()
                => ++_current < _data.Length;

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public void Reset()
            {
                _current = uint.MaxValue;
            }

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public void Dispose() { }
        }
    }
    [ForceBlittable]
    public unsafe struct FString4 : IEquatable<FString4>, IEquatable<string>, IEquatable<ICString<char>>, IEnumerable<char>, ICString<char>
    {
		public static readonly FString4 Empty = new();
	
		private FList4<char> _data;

		public uint Capacity
		{
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			get => _data.Capacity;
		}
		
		public uint Length
		{
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			get => _data.Count;
		}

        public FString4(string text)
        {
			_data = default;
            if (text.Length > Capacity)
            {
                throw new ArgumentException($"{nameof(text)} is longer than capacity. Capacity: '{Capacity}'. text length '{text.Length}'");
            }

            for (int i = 0; i < text.Length; ++i)
            {
                _data[i] = text[i];
            }
            _data.Count = (uint)text.Length;
        }

        public static implicit operator string(FString4 fstring) => fstring.ToString();
        public static explicit operator FString4(string text) => new(text);

        public static FString4 operator +(FString4 a, FString4 b)
        {
            if (a.Length + b.Length > a.Capacity)
            {
                throw new ArgumentException($"Capacity not enough. Capacity: '{a.Capacity}'. Requirement: '{a.Length + b.Length}'.");
            }

            FString4 result = a;
            var offset = a.Length;
            for (uint i = 0; i < b.Length; ++i)
            {
                result._data[i + offset] = b._data[i];
            }
            result._data.Count = (a.Length + b.Length);

            return result;
        }

        public static bool operator ==(FString4 a, FString4 b)
            => a.Equals(ref b);

        public static bool operator !=(FString4 a, FString4 b)
            => !a.Equals(ref b);

        public static bool operator ==(FString4 a, ICString<char> b)
            => a.Equals(b);

        public static bool operator !=(FString4 a, ICString<char> b)
            => !a.Equals(b);

        public static bool operator ==(FString4 a, string b)
            => a.Equals(b);

        public static bool operator !=(FString4 a, string b)
            => !a.Equals(b);

        public char this[uint index]
        {
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => _data[index];
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
            set => _data[index] = value;
        }

        public void Set(string text)
        {
            this = new(text);
        }

        public override string ToString()
        {
#pragma warning disable CS0162
            if (Capacity <= 16)
            {
                var text = string.Empty;
                for (uint i = 0; i < Length; ++i)
                {
                    text += _data[i];
                }
                return text;
            }
            else
            {
                var stringBuilder = new StringBuilder();
                for (uint i = 0; i < Length; ++i)
                {
                    stringBuilder.Append(_data[i]);
                }
                return stringBuilder.ToString();
#pragma warning restore CS0162
            }
        }

         public override bool Equals(object obj)
        {
            if (obj is FString2 fString)
            {
                return Equals(ref fString);
            }
            else if (obj is ICString<char> iString)
            {
                return Equals(iString);
            }
            else if (obj is string cString)
            {
                return Equals(cString);
            }
            return false;
        }

        public bool Equals(string other)
        {
            if (Length == other.Length)
            {
                for (int i = 0; i < Length; ++i)
                {
                    if (_data[i] != other[i])
                    {
                        return false;
                    }
                }
                return true;
            }
            return false;
        }

        public bool Equals(FString4 other)
            => Equals(ref other);

        public bool Equals(ref FString4 other)
        {
            if (Length == other.Length)
            {
                for (uint i = 0; i < Length; ++i)
                {
                    if (_data[i] != other._data[i])
                    {
                        return false;
                    }
                }
                return true;
            }
            return false;
        }

         public bool Equals<TCString>(ref TCString other)
            where TCString : struct, ICString<char>
        {
            if (Length == other.Length)
            {
                for (uint i = 0; i < Length; ++i)
                {
                    if (!_data[i].Equals(other[i]))
                    {
                        return false;
                    }
                }
                return true;
            }
            return false;
        }

        public bool Equals(ICString<char> other)
        {
            if (Length == other.Length)
            {
                for (uint i = 0; i < Length; ++i)
                {
                    if (!_data[i].Equals(other[i]))
                    {
                        return false;
                    }
                }
                return true;
            }
            return false;
        }

        public override int GetHashCode()
        {
            HashCode hash = default;
            hash.Add(Length);
            for(uint i = 0; i < Length; ++i)
            {
                hash.Add(_data[i]);
            }

            return hash.ToHashCode();
        }

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
        public IEnumerator<char> GetEnumerator()
            => new Enumerator(ref this);

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
        IEnumerator IEnumerable.GetEnumerator()
            => GetEnumerator();


        public struct Enumerator : IEnumerator<char>
        {
            private readonly FString4 _data;
            private uint _current;

            public Enumerator(ref FString4 data)
            {
                _data = data;
                _current = uint.MaxValue;
            }

            public char Current
            {
                [MethodImpl(MethodImplOptions.AggressiveInlining)]
                get => _data[_current];
            }

            object IEnumerator.Current
                => _data[_current];

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public bool MoveNext()
                => ++_current < _data.Length;

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public void Reset()
            {
                _current = uint.MaxValue;
            }

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public void Dispose() { }
        }
    }
    [ForceBlittable]
    public unsafe struct FString8 : IEquatable<FString8>, IEquatable<string>, IEquatable<ICString<char>>, IEnumerable<char>, ICString<char>
    {
		public static readonly FString8 Empty = new();
	
		private FList8<char> _data;

		public uint Capacity
		{
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			get => _data.Capacity;
		}
		
		public uint Length
		{
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			get => _data.Count;
		}

        public FString8(string text)
        {
			_data = default;
            if (text.Length > Capacity)
            {
                throw new ArgumentException($"{nameof(text)} is longer than capacity. Capacity: '{Capacity}'. text length '{text.Length}'");
            }

            for (int i = 0; i < text.Length; ++i)
            {
                _data[i] = text[i];
            }
            _data.Count = (uint)text.Length;
        }

        public static implicit operator string(FString8 fstring) => fstring.ToString();
        public static explicit operator FString8(string text) => new(text);

        public static FString8 operator +(FString8 a, FString8 b)
        {
            if (a.Length + b.Length > a.Capacity)
            {
                throw new ArgumentException($"Capacity not enough. Capacity: '{a.Capacity}'. Requirement: '{a.Length + b.Length}'.");
            }

            FString8 result = a;
            var offset = a.Length;
            for (uint i = 0; i < b.Length; ++i)
            {
                result._data[i + offset] = b._data[i];
            }
            result._data.Count = (a.Length + b.Length);

            return result;
        }

        public static bool operator ==(FString8 a, FString8 b)
            => a.Equals(ref b);

        public static bool operator !=(FString8 a, FString8 b)
            => !a.Equals(ref b);

        public static bool operator ==(FString8 a, ICString<char> b)
            => a.Equals(b);

        public static bool operator !=(FString8 a, ICString<char> b)
            => !a.Equals(b);

        public static bool operator ==(FString8 a, string b)
            => a.Equals(b);

        public static bool operator !=(FString8 a, string b)
            => !a.Equals(b);

        public char this[uint index]
        {
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => _data[index];
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
            set => _data[index] = value;
        }

        public void Set(string text)
        {
            this = new(text);
        }

        public override string ToString()
        {
#pragma warning disable CS0162
            if (Capacity <= 16)
            {
                var text = string.Empty;
                for (uint i = 0; i < Length; ++i)
                {
                    text += _data[i];
                }
                return text;
            }
            else
            {
                var stringBuilder = new StringBuilder();
                for (uint i = 0; i < Length; ++i)
                {
                    stringBuilder.Append(_data[i]);
                }
                return stringBuilder.ToString();
#pragma warning restore CS0162
            }
        }

         public override bool Equals(object obj)
        {
            if (obj is FString2 fString)
            {
                return Equals(ref fString);
            }
            else if (obj is ICString<char> iString)
            {
                return Equals(iString);
            }
            else if (obj is string cString)
            {
                return Equals(cString);
            }
            return false;
        }

        public bool Equals(string other)
        {
            if (Length == other.Length)
            {
                for (int i = 0; i < Length; ++i)
                {
                    if (_data[i] != other[i])
                    {
                        return false;
                    }
                }
                return true;
            }
            return false;
        }

        public bool Equals(FString8 other)
            => Equals(ref other);

        public bool Equals(ref FString8 other)
        {
            if (Length == other.Length)
            {
                for (uint i = 0; i < Length; ++i)
                {
                    if (_data[i] != other._data[i])
                    {
                        return false;
                    }
                }
                return true;
            }
            return false;
        }

         public bool Equals<TCString>(ref TCString other)
            where TCString : struct, ICString<char>
        {
            if (Length == other.Length)
            {
                for (uint i = 0; i < Length; ++i)
                {
                    if (!_data[i].Equals(other[i]))
                    {
                        return false;
                    }
                }
                return true;
            }
            return false;
        }

        public bool Equals(ICString<char> other)
        {
            if (Length == other.Length)
            {
                for (uint i = 0; i < Length; ++i)
                {
                    if (!_data[i].Equals(other[i]))
                    {
                        return false;
                    }
                }
                return true;
            }
            return false;
        }

        public override int GetHashCode()
        {
            HashCode hash = default;
            hash.Add(Length);
            for(uint i = 0; i < Length; ++i)
            {
                hash.Add(_data[i]);
            }

            return hash.ToHashCode();
        }

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
        public IEnumerator<char> GetEnumerator()
            => new Enumerator(ref this);

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
        IEnumerator IEnumerable.GetEnumerator()
            => GetEnumerator();


        public struct Enumerator : IEnumerator<char>
        {
            private readonly FString8 _data;
            private uint _current;

            public Enumerator(ref FString8 data)
            {
                _data = data;
                _current = uint.MaxValue;
            }

            public char Current
            {
                [MethodImpl(MethodImplOptions.AggressiveInlining)]
                get => _data[_current];
            }

            object IEnumerator.Current
                => _data[_current];

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public bool MoveNext()
                => ++_current < _data.Length;

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public void Reset()
            {
                _current = uint.MaxValue;
            }

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public void Dispose() { }
        }
    }
    [ForceBlittable]
    public unsafe struct FString16 : IEquatable<FString16>, IEquatable<string>, IEquatable<ICString<char>>, IEnumerable<char>, ICString<char>
    {
		public static readonly FString16 Empty = new();
	
		private FList16<char> _data;

		public uint Capacity
		{
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			get => _data.Capacity;
		}
		
		public uint Length
		{
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			get => _data.Count;
		}

        public FString16(string text)
        {
			_data = default;
            if (text.Length > Capacity)
            {
                throw new ArgumentException($"{nameof(text)} is longer than capacity. Capacity: '{Capacity}'. text length '{text.Length}'");
            }

            for (int i = 0; i < text.Length; ++i)
            {
                _data[i] = text[i];
            }
            _data.Count = (uint)text.Length;
        }

        public static implicit operator string(FString16 fstring) => fstring.ToString();
        public static explicit operator FString16(string text) => new(text);

        public static FString16 operator +(FString16 a, FString16 b)
        {
            if (a.Length + b.Length > a.Capacity)
            {
                throw new ArgumentException($"Capacity not enough. Capacity: '{a.Capacity}'. Requirement: '{a.Length + b.Length}'.");
            }

            FString16 result = a;
            var offset = a.Length;
            for (uint i = 0; i < b.Length; ++i)
            {
                result._data[i + offset] = b._data[i];
            }
            result._data.Count = (a.Length + b.Length);

            return result;
        }

        public static bool operator ==(FString16 a, FString16 b)
            => a.Equals(ref b);

        public static bool operator !=(FString16 a, FString16 b)
            => !a.Equals(ref b);

        public static bool operator ==(FString16 a, ICString<char> b)
            => a.Equals(b);

        public static bool operator !=(FString16 a, ICString<char> b)
            => !a.Equals(b);

        public static bool operator ==(FString16 a, string b)
            => a.Equals(b);

        public static bool operator !=(FString16 a, string b)
            => !a.Equals(b);

        public char this[uint index]
        {
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => _data[index];
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
            set => _data[index] = value;
        }

        public void Set(string text)
        {
            this = new(text);
        }

        public override string ToString()
        {
#pragma warning disable CS0162
            if (Capacity <= 16)
            {
                var text = string.Empty;
                for (uint i = 0; i < Length; ++i)
                {
                    text += _data[i];
                }
                return text;
            }
            else
            {
                var stringBuilder = new StringBuilder();
                for (uint i = 0; i < Length; ++i)
                {
                    stringBuilder.Append(_data[i]);
                }
                return stringBuilder.ToString();
#pragma warning restore CS0162
            }
        }

         public override bool Equals(object obj)
        {
            if (obj is FString2 fString)
            {
                return Equals(ref fString);
            }
            else if (obj is ICString<char> iString)
            {
                return Equals(iString);
            }
            else if (obj is string cString)
            {
                return Equals(cString);
            }
            return false;
        }

        public bool Equals(string other)
        {
            if (Length == other.Length)
            {
                for (int i = 0; i < Length; ++i)
                {
                    if (_data[i] != other[i])
                    {
                        return false;
                    }
                }
                return true;
            }
            return false;
        }

        public bool Equals(FString16 other)
            => Equals(ref other);

        public bool Equals(ref FString16 other)
        {
            if (Length == other.Length)
            {
                for (uint i = 0; i < Length; ++i)
                {
                    if (_data[i] != other._data[i])
                    {
                        return false;
                    }
                }
                return true;
            }
            return false;
        }

         public bool Equals<TCString>(ref TCString other)
            where TCString : struct, ICString<char>
        {
            if (Length == other.Length)
            {
                for (uint i = 0; i < Length; ++i)
                {
                    if (!_data[i].Equals(other[i]))
                    {
                        return false;
                    }
                }
                return true;
            }
            return false;
        }

        public bool Equals(ICString<char> other)
        {
            if (Length == other.Length)
            {
                for (uint i = 0; i < Length; ++i)
                {
                    if (!_data[i].Equals(other[i]))
                    {
                        return false;
                    }
                }
                return true;
            }
            return false;
        }

        public override int GetHashCode()
        {
            HashCode hash = default;
            hash.Add(Length);
            for(uint i = 0; i < Length; ++i)
            {
                hash.Add(_data[i]);
            }

            return hash.ToHashCode();
        }

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
        public IEnumerator<char> GetEnumerator()
            => new Enumerator(ref this);

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
        IEnumerator IEnumerable.GetEnumerator()
            => GetEnumerator();


        public struct Enumerator : IEnumerator<char>
        {
            private readonly FString16 _data;
            private uint _current;

            public Enumerator(ref FString16 data)
            {
                _data = data;
                _current = uint.MaxValue;
            }

            public char Current
            {
                [MethodImpl(MethodImplOptions.AggressiveInlining)]
                get => _data[_current];
            }

            object IEnumerator.Current
                => _data[_current];

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public bool MoveNext()
                => ++_current < _data.Length;

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public void Reset()
            {
                _current = uint.MaxValue;
            }

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public void Dispose() { }
        }
    }
    [ForceBlittable]
    public unsafe struct FString32 : IEquatable<FString32>, IEquatable<string>, IEquatable<ICString<char>>, IEnumerable<char>, ICString<char>
    {
		public static readonly FString32 Empty = new();
	
		private FList32<char> _data;

		public uint Capacity
		{
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			get => _data.Capacity;
		}
		
		public uint Length
		{
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			get => _data.Count;
		}

        public FString32(string text)
        {
			_data = default;
            if (text.Length > Capacity)
            {
                throw new ArgumentException($"{nameof(text)} is longer than capacity. Capacity: '{Capacity}'. text length '{text.Length}'");
            }

            for (int i = 0; i < text.Length; ++i)
            {
                _data[i] = text[i];
            }
            _data.Count = (uint)text.Length;
        }

        public static implicit operator string(FString32 fstring) => fstring.ToString();
        public static explicit operator FString32(string text) => new(text);

        public static FString32 operator +(FString32 a, FString32 b)
        {
            if (a.Length + b.Length > a.Capacity)
            {
                throw new ArgumentException($"Capacity not enough. Capacity: '{a.Capacity}'. Requirement: '{a.Length + b.Length}'.");
            }

            FString32 result = a;
            var offset = a.Length;
            for (uint i = 0; i < b.Length; ++i)
            {
                result._data[i + offset] = b._data[i];
            }
            result._data.Count = (a.Length + b.Length);

            return result;
        }

        public static bool operator ==(FString32 a, FString32 b)
            => a.Equals(ref b);

        public static bool operator !=(FString32 a, FString32 b)
            => !a.Equals(ref b);

        public static bool operator ==(FString32 a, ICString<char> b)
            => a.Equals(b);

        public static bool operator !=(FString32 a, ICString<char> b)
            => !a.Equals(b);

        public static bool operator ==(FString32 a, string b)
            => a.Equals(b);

        public static bool operator !=(FString32 a, string b)
            => !a.Equals(b);

        public char this[uint index]
        {
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => _data[index];
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
            set => _data[index] = value;
        }

        public void Set(string text)
        {
            this = new(text);
        }

        public override string ToString()
        {
#pragma warning disable CS0162
            if (Capacity <= 16)
            {
                var text = string.Empty;
                for (uint i = 0; i < Length; ++i)
                {
                    text += _data[i];
                }
                return text;
            }
            else
            {
                var stringBuilder = new StringBuilder();
                for (uint i = 0; i < Length; ++i)
                {
                    stringBuilder.Append(_data[i]);
                }
                return stringBuilder.ToString();
#pragma warning restore CS0162
            }
        }

         public override bool Equals(object obj)
        {
            if (obj is FString2 fString)
            {
                return Equals(ref fString);
            }
            else if (obj is ICString<char> iString)
            {
                return Equals(iString);
            }
            else if (obj is string cString)
            {
                return Equals(cString);
            }
            return false;
        }

        public bool Equals(string other)
        {
            if (Length == other.Length)
            {
                for (int i = 0; i < Length; ++i)
                {
                    if (_data[i] != other[i])
                    {
                        return false;
                    }
                }
                return true;
            }
            return false;
        }

        public bool Equals(FString32 other)
            => Equals(ref other);

        public bool Equals(ref FString32 other)
        {
            if (Length == other.Length)
            {
                for (uint i = 0; i < Length; ++i)
                {
                    if (_data[i] != other._data[i])
                    {
                        return false;
                    }
                }
                return true;
            }
            return false;
        }

         public bool Equals<TCString>(ref TCString other)
            where TCString : struct, ICString<char>
        {
            if (Length == other.Length)
            {
                for (uint i = 0; i < Length; ++i)
                {
                    if (!_data[i].Equals(other[i]))
                    {
                        return false;
                    }
                }
                return true;
            }
            return false;
        }

        public bool Equals(ICString<char> other)
        {
            if (Length == other.Length)
            {
                for (uint i = 0; i < Length; ++i)
                {
                    if (!_data[i].Equals(other[i]))
                    {
                        return false;
                    }
                }
                return true;
            }
            return false;
        }

        public override int GetHashCode()
        {
            HashCode hash = default;
            hash.Add(Length);
            for(uint i = 0; i < Length; ++i)
            {
                hash.Add(_data[i]);
            }

            return hash.ToHashCode();
        }

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
        public IEnumerator<char> GetEnumerator()
            => new Enumerator(ref this);

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
        IEnumerator IEnumerable.GetEnumerator()
            => GetEnumerator();


        public struct Enumerator : IEnumerator<char>
        {
            private readonly FString32 _data;
            private uint _current;

            public Enumerator(ref FString32 data)
            {
                _data = data;
                _current = uint.MaxValue;
            }

            public char Current
            {
                [MethodImpl(MethodImplOptions.AggressiveInlining)]
                get => _data[_current];
            }

            object IEnumerator.Current
                => _data[_current];

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public bool MoveNext()
                => ++_current < _data.Length;

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public void Reset()
            {
                _current = uint.MaxValue;
            }

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public void Dispose() { }
        }
    }
    [ForceBlittable]
    public unsafe struct FString64 : IEquatable<FString64>, IEquatable<string>, IEquatable<ICString<char>>, IEnumerable<char>, ICString<char>
    {
		public static readonly FString64 Empty = new();
	
		private FList64<char> _data;

		public uint Capacity
		{
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			get => _data.Capacity;
		}
		
		public uint Length
		{
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			get => _data.Count;
		}

        public FString64(string text)
        {
			_data = default;
            if (text.Length > Capacity)
            {
                throw new ArgumentException($"{nameof(text)} is longer than capacity. Capacity: '{Capacity}'. text length '{text.Length}'");
            }

            for (int i = 0; i < text.Length; ++i)
            {
                _data[i] = text[i];
            }
            _data.Count = (uint)text.Length;
        }

        public static implicit operator string(FString64 fstring) => fstring.ToString();
        public static explicit operator FString64(string text) => new(text);

        public static FString64 operator +(FString64 a, FString64 b)
        {
            if (a.Length + b.Length > a.Capacity)
            {
                throw new ArgumentException($"Capacity not enough. Capacity: '{a.Capacity}'. Requirement: '{a.Length + b.Length}'.");
            }

            FString64 result = a;
            var offset = a.Length;
            for (uint i = 0; i < b.Length; ++i)
            {
                result._data[i + offset] = b._data[i];
            }
            result._data.Count = (a.Length + b.Length);

            return result;
        }

        public static bool operator ==(FString64 a, FString64 b)
            => a.Equals(ref b);

        public static bool operator !=(FString64 a, FString64 b)
            => !a.Equals(ref b);

        public static bool operator ==(FString64 a, ICString<char> b)
            => a.Equals(b);

        public static bool operator !=(FString64 a, ICString<char> b)
            => !a.Equals(b);

        public static bool operator ==(FString64 a, string b)
            => a.Equals(b);

        public static bool operator !=(FString64 a, string b)
            => !a.Equals(b);

        public char this[uint index]
        {
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => _data[index];
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
            set => _data[index] = value;
        }

        public void Set(string text)
        {
            this = new(text);
        }

        public override string ToString()
        {
#pragma warning disable CS0162
            if (Capacity <= 16)
            {
                var text = string.Empty;
                for (uint i = 0; i < Length; ++i)
                {
                    text += _data[i];
                }
                return text;
            }
            else
            {
                var stringBuilder = new StringBuilder();
                for (uint i = 0; i < Length; ++i)
                {
                    stringBuilder.Append(_data[i]);
                }
                return stringBuilder.ToString();
#pragma warning restore CS0162
            }
        }

         public override bool Equals(object obj)
        {
            if (obj is FString2 fString)
            {
                return Equals(ref fString);
            }
            else if (obj is ICString<char> iString)
            {
                return Equals(iString);
            }
            else if (obj is string cString)
            {
                return Equals(cString);
            }
            return false;
        }

        public bool Equals(string other)
        {
            if (Length == other.Length)
            {
                for (int i = 0; i < Length; ++i)
                {
                    if (_data[i] != other[i])
                    {
                        return false;
                    }
                }
                return true;
            }
            return false;
        }

        public bool Equals(FString64 other)
            => Equals(ref other);

        public bool Equals(ref FString64 other)
        {
            if (Length == other.Length)
            {
                for (uint i = 0; i < Length; ++i)
                {
                    if (_data[i] != other._data[i])
                    {
                        return false;
                    }
                }
                return true;
            }
            return false;
        }

         public bool Equals<TCString>(ref TCString other)
            where TCString : struct, ICString<char>
        {
            if (Length == other.Length)
            {
                for (uint i = 0; i < Length; ++i)
                {
                    if (!_data[i].Equals(other[i]))
                    {
                        return false;
                    }
                }
                return true;
            }
            return false;
        }

        public bool Equals(ICString<char> other)
        {
            if (Length == other.Length)
            {
                for (uint i = 0; i < Length; ++i)
                {
                    if (!_data[i].Equals(other[i]))
                    {
                        return false;
                    }
                }
                return true;
            }
            return false;
        }

        public override int GetHashCode()
        {
            HashCode hash = default;
            hash.Add(Length);
            for(uint i = 0; i < Length; ++i)
            {
                hash.Add(_data[i]);
            }

            return hash.ToHashCode();
        }

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
        public IEnumerator<char> GetEnumerator()
            => new Enumerator(ref this);

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
        IEnumerator IEnumerable.GetEnumerator()
            => GetEnumerator();


        public struct Enumerator : IEnumerator<char>
        {
            private readonly FString64 _data;
            private uint _current;

            public Enumerator(ref FString64 data)
            {
                _data = data;
                _current = uint.MaxValue;
            }

            public char Current
            {
                [MethodImpl(MethodImplOptions.AggressiveInlining)]
                get => _data[_current];
            }

            object IEnumerator.Current
                => _data[_current];

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public bool MoveNext()
                => ++_current < _data.Length;

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public void Reset()
            {
                _current = uint.MaxValue;
            }

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public void Dispose() { }
        }
    }

}
