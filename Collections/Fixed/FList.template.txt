<#META GENERATOR = AnotherECS.Generator.FListGenerator FILENAME = FList.cs#>

// <auto-generated>
// This source code was auto-generated by FListGenerator.cs
// </auto-generated>

using System;
using System.Collections;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using AnotherECS.Core;
using AnotherECS.Serializer;

namespace AnotherECS.Collections
{
<#ARRAY [0..STRUCT_COUNT]#>
    [Serializable]
    [ForceBlittable]
    public struct FList<#ELEMENT_COUNT#><TData> : ICList<TData>, IList<TData>, ISerialize, IEnumerable<TData>
        where TData : unmanaged
    {
        public FArray<#ELEMENT_COUNT#><TData> _data;
        public uint _count;

        public uint Capacity
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => _data.Length;
        }

        public uint Count
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => _count;
			internal set => _count = value;
        }

        public bool IsReadOnly => false;

        int ICollection<TData>.Count => (int)Count;

        public TData this[int index] { get => this[(uint)index]; set => this[(uint)index] = value; }


		[MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ExtendToCapacity()
        {
            _count = Capacity;
        }

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Add(TData value)
        {
#if !ANOTHERECS_RELEASE
            FArrayHelper.ThrowIfOutOfRange(_count, Capacity);
#endif
            this[_count++] = value;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void RemoveLast()
        {
            if (_count != 0)
            {
                this[--_count] = default;
            }
        }

        public void RemoveAt(uint index)
        {
#if !ANOTHERECS_RELEASE
            FArrayHelper.ThrowIfEmpty(_count);
#endif	
            _data.RemoveAtInternal(index, Capacity);
			--_count;
        }
		
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Clear()
        {
            _data.Clear();
			_count = 0;
        }

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
        public object Get(uint index)
            => this[index];

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Set(uint index, object @value)
        {
            this[index] = (TData)@value;
        }

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Add(object value)
        {
#if !ANOTHERECS_RELEASE
            FArrayHelper.ThrowIfOutOfRange(_count, Capacity);
#endif
            this[_count++] = (TData)value;
        }

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
        public IEnumerator<TData> GetEnumerator()
            => new Enumerator(ref this);

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
        IEnumerator IEnumerable.GetEnumerator()
            => GetEnumerator();

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint IndexOf(TData item)
            => IndexOf(ref item, _count);

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint IndexOf(ref TData item)
            => IndexOf(ref item, _count);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal uint IndexOf(ref TData item, uint count)
            => _data.IndexOf(ref item, count);

        public bool Contains(TData item)
            => _data.Contains(ref item);

        public bool Contains(ref TData item)
            => _data.Contains(ref item);

        public void Insert(uint index, TData item)
        {
            Insert(index, ref item);
        }

        public void Insert(uint index, ref TData item)
        {
#if !ANOTHERECS_RELEASE
            FArrayHelper.ThrowIfOutOfRange(_count, Capacity);
#endif
			_data.Insert(index, ref item);
            ++_count;
        }

        public bool Remove(TData item)
        {
            var index = IndexOf(ref item);
            if (index != uint.MaxValue)
            {
                RemoveAt(index);
                return true;
            }
            return false;
        }

        public void CopyTo(TData[] array, uint arrayIndex)
        {
			_data.CopyTo(array, arrayIndex, _count, _count);
        }

        public void CopyTo(TData[] array, uint arrayIndex, uint count)
        {
			_data.CopyTo(array, arrayIndex, count, _count);
        }

        public void Pack(ref WriterContextSerializer writer)
        {
            writer.Write(_count);
            _data.Pack(ref writer);
        }

        public void Unpack(ref ReaderContextSerializer reader)
        {
            _count = reader.ReadUInt32();
            _data.Unpack(ref reader);
        }

        public TData this[uint index]
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => _data[index];
            
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set => _data[index] = value;
        }
		
	
        public struct Enumerator : IEnumerator<TData>
        {
            private readonly FList<#ELEMENT_COUNT#><TData> _data;
            private uint _current;

            public Enumerator(ref FList<#ELEMENT_COUNT#><TData> data)
            {
                _data = data;
                _current = uint.MaxValue;
            }

            public TData Current
            {
                [MethodImpl(MethodImplOptions.AggressiveInlining)]
                get => _data[_current];
            }

            object IEnumerator.Current
                => _data[_current];

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public bool MoveNext()
                => ++_current < _data.Count;

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public void Reset()
            {
                _current = uint.MaxValue;
            }

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public void Dispose() { }
        }

        int IList<TData>.IndexOf(TData item)
            => (int)IndexOf(item);

        public void Insert(int index, TData item)
        {
            Insert((uint)index, item);
        }

        public void RemoveAt(int index)
        {
            RemoveAt((uint)index);
        }

        public void CopyTo(TData[] array, int arrayIndex)
        {
            CopyTo(array, (uint)arrayIndex);
        }
    }
<#END#>
}