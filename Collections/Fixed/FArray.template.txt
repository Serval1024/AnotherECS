<#META GENERATOR = AnotherECS.Generator.FListGenerator FILENAME = FArray.cs#>

// <auto-generated>
// This source code was auto-generated by FListGenerator.cs
// </auto-generated>

using System;
using System.Collections;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using AnotherECS.Core;
using AnotherECS.Serializer;

namespace AnotherECS.Collections
{
<#ARRAY [0..STRUCT_COUNT]#>
	[Serializable] internal struct Data<#ELEMENT_COUNT#><TData> : ISerialize where TData : unmanaged 
    { 
        public TData <#ARRAY [0..ELEMENT_COUNT]#>p<#INDEX1#><#SEPARATOR1:,#><#END#>;

		public const int LENGTH = <#ELEMENT_COUNT#>;
        public unsafe void Pack(ref WriterContextSerializer writer) => FArrayHelper.Pack<TData>(ref writer, GCHandle.Alloc(this, GCHandleType.Pinned), LENGTH);
        public unsafe void Unpack(ref ReaderContextSerializer reader) => FArrayHelper.Unpack<TData>(ref reader, GCHandle.Alloc(this, GCHandleType.Pinned), LENGTH);
    }

    [Serializable]
    [ForceBlittable]
    public struct FArray<#ELEMENT_COUNT#><TData> : ICArray<TData>, ISerialize, IEnumerable<TData>
        where TData : unmanaged
    {
		private Data<#ELEMENT_COUNT#><TData> _data;

        public int Length
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => Data<#ELEMENT_COUNT#><TData>.LENGTH;
        }

        public bool IsReadOnly => false;

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Clear()
        {
			_data = default;
        }

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int IndexOf(TData item)
            => IndexOf(ref item, Length);

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int IndexOf(ref TData item)
            => IndexOf(ref item, Length);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal int IndexOf(ref TData item, int count)
        {
            for (int i = 0; i < Length; ++i)
            {
                if (EqualityComparer<TData>.Default.Equals(this[i], item))
                {
                    return i;
                }
            }
            return -1;
        }

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Contains(TData item)
            => Contains(ref item);

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Contains(ref TData item)
            => IndexOf(ref item) != -1;

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Insert(int index, TData item)
        {
            Insert(index, ref item);
        }

        public void Insert(int index, ref TData item)
        {
#if !ANOTHERECS_RELEASE
            FArrayHelper.ThrowIfOutOfRange(index, Length);
#endif
            for (int i = Length - 1; i > index; --i)
            {
                this[i] = this[i - 1];
            }
            this[index] = item;
        }

        public bool Remove(TData item)
        {
            var index = IndexOf(ref item);
            if (index != -1)
            {
                RemoveAt(index);
                return true;
            }
            return false;
        }

		public void RemoveAt(int index)
        {
			RemoveAtInternal(index, Length);
        }
		
        public void CopyTo(TData[] array, int arrayIndex)
        {
            CopyTo(array, arrayIndex, Length, Length);
        }
		
		public void CopyTo(TData[] array, int arrayIndex, int count)
        {
            CopyTo(array, arrayIndex, count, Length);
        }

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Pack(ref WriterContextSerializer writer)
        {
			_data.Pack(ref writer);
        }

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Unpack(ref ReaderContextSerializer reader)
        {
			_data.Unpack(ref reader);
        }

        public TData this[int index]
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
#if !ANOTHERECS_RELEASE
                FArrayHelper.ThrowIfOutOfRange(index, Length);
#endif
                return index switch
                {
<#ARRAY [0..ELEMENT_COUNT]#>
                    <#INDEX1#> => _data.p<#INDEX1#>,
<#END#>
                    _ => throw new IndexOutOfRangeException($"Index {index} is out of range Length {Length}."),
                };    
            }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set
            {
#if !ANOTHERECS_RELEASE
                FArrayHelper.ThrowIfOutOfRange(index, Length);
#endif
                switch(index)
                {
<#ARRAY [0..ELEMENT_COUNT]#>
                    case <#INDEX1#>: _data.p<#INDEX1#> = value; break;
<#END#>
                    default: throw new IndexOutOfRangeException($"Index {index} is out of range Length {Length}.");
                };
            }
		}
		
		internal void CopyTo(TData[] array, int arrayIndex, int count, int capacity)
        {
#if !ANOTHERECS_RELEASE
            if (count > capacity)
            {
                throw new ArgumentOutOfRangeException($"'{nameof(count)}':{count} must be less or equal than '{nameof(capacity)}': {capacity}");
            }
#endif
            if (array == null)
            {
                throw new NullReferenceException(nameof(array));
            }
            if (arrayIndex < 0)
            {
                throw new IndexOutOfRangeException(nameof(arrayIndex));
            }
            if (count <= 0)
            {
                throw new IndexOutOfRangeException(nameof(count));
            }
            if (array.Length - arrayIndex < count)
            {
                throw new ArgumentException($"There is not enough space in {nameof(array)} to copy.");
            }

            var iMax = Math.Min(array.Length - arrayIndex, count);
            for (int i = 0; i < iMax; ++i)
            {
                array[i + arrayIndex] = this[i];
            }
        }
		
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void RemoveAtInternal(int index, int capacity)
        {
#if !ANOTHERECS_RELEASE
            FArrayHelper.ThrowIfOutOfRange(index, capacity);
#endif
            if (index != capacity - 1)
            {
                for (int i = index; i < capacity - 1; ++i)
                {
                    this[i] = this[i + 1];
                }
			}
			
			this[capacity - 1] = default;
        }
		
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
        object ICArray.Get(int index)
            => this[index];

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
        void ICArray.Set(int index, object @value)
        {
            this[index] = (TData)@value;
        }

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
        public IEnumerator<TData> GetEnumerator()
            => new Enumerator(ref this);
			
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
        IEnumerator IEnumerable.GetEnumerator()
            => GetEnumerator();


        public struct Enumerator : IEnumerator<TData>
        {
            private readonly FArray<#ELEMENT_COUNT#><TData> _data;
            private int _current;

			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			public Enumerator(ref FArray<#ELEMENT_COUNT#><TData> data)
            {
                _data = data;
                _current = -1;
            }

            public TData Current
            {
                [MethodImpl(MethodImplOptions.AggressiveInlining)]
                get => _data[_current];
            }
			
            object IEnumerator.Current
			{
				[MethodImpl(MethodImplOptions.AggressiveInlining)]
                get => _data[_current];
			}

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public bool MoveNext()
                => ++_current < _data.Length;

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public void Reset()
            {
                _current = -1;
            }

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public void Dispose() { }
        }
    }
<#END#>
}