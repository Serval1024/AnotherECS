//GENERATOR = AnotherECS.Generator.FListGenerator FILENAME = FArray.cs

// <auto-generated>
// This source code was auto-generated by FListGenerator.cs
// </auto-generated>

using System;
using System.Collections;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using AnotherECS.Core;
using AnotherECS.Serializer;

namespace AnotherECS.Collections
{
	[Serializable] internal struct Data2<TData> : ISerialize where TData : unmanaged 
    { 
        public TData p0, p1;

		public const uint LENGTH = 2;
        public unsafe void Pack(ref WriterContextSerializer writer) => FArrayHelper.Pack<TData>(ref writer, GCHandle.Alloc(this, GCHandleType.Pinned), LENGTH);
        public unsafe void Unpack(ref ReaderContextSerializer reader) => FArrayHelper.Unpack<TData>(ref reader, GCHandle.Alloc(this, GCHandleType.Pinned), LENGTH);
    }

    [Serializable]
    [ForceBlittable]
    public struct FArray2<TData> : ICollection<TData>, ISerialize, IEnumerable<TData>
        where TData : unmanaged
    {
		private Data2<TData> _data;

        public uint Length
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => Data2<TData>.LENGTH;
        }

        public bool IsReadOnly => false;

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Clear()
        {
			_data = default;
        }

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint IndexOf(TData item)
            => IndexOf(ref item, Length);

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint IndexOf(ref TData item)
            => IndexOf(ref item, Length);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal uint IndexOf(ref TData item, uint count)
        {
            for (uint i = 0; i < count; ++i)
            {
                if (EqualityComparer<TData>.Default.Equals(this[i], item))
                {
                    return i;
                }
            }
            return uint.MaxValue;
        }

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Contains(TData item)
            => Contains(ref item);

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Contains(ref TData item)
            => IndexOf(ref item) != uint.MaxValue;

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Insert(uint index, TData item)
        {
            Insert(index, ref item);
        }

        public void Insert(uint index, ref TData item)
        {
#if !ANOTHERECS_RELEASE
            FArrayHelper.ThrowIfOutOfRange(index, Length);
#endif
            for (uint i = Length - 1; i > index; --i)
            {
                this[i] = this[i - 1];
            }
            this[index] = item;
        }

        public bool Remove(TData item)
        {
            var index = IndexOf(ref item);
            if (index != uint.MaxValue)
            {
                RemoveAt(index);
                return true;
            }
            return false;
        }

		public void RemoveAt(uint index)
        {
			RemoveAtInternal(index, Length);
        }
		
        public void CopyTo(TData[] array, uint arrayIndex)
        {
            CopyTo(array, arrayIndex, Length, Length);
        }
		
		public void CopyTo(TData[] array, uint arrayIndex, uint count)
        {
            CopyTo(array, arrayIndex, count, Length);
        }

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Pack(ref WriterContextSerializer writer)
        {
			_data.Pack(ref writer);
        }

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Unpack(ref ReaderContextSerializer reader)
        {
			_data.Unpack(ref reader);
        }

        public TData this[uint index]
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
#if !ANOTHERECS_RELEASE
                FArrayHelper.ThrowIfOutOfRange(index, Length);
#endif
                return index switch
                {
                    0 => _data.p0,
                    1 => _data.p1,

                    _ => throw new IndexOutOfRangeException($"Index {index} is out of range Length {Length}."),
                };    
            }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set
            {
#if !ANOTHERECS_RELEASE
                FArrayHelper.ThrowIfOutOfRange(index, Length);
#endif
                switch(index)
                {
                    case 0: _data.p0 = value; break;
                    case 1: _data.p1 = value; break;

                    default: throw new IndexOutOfRangeException($"Index {index} is out of range Length {Length}.");
                };
            }
		}
		
		internal void CopyTo(TData[] array, uint arrayIndex, uint count, uint capacity)
        {
#if !ANOTHERECS_RELEASE
            if (count > capacity)
            {
                throw new ArgumentOutOfRangeException($"'{nameof(count)}':{count} must be less or equal than '{nameof(capacity)}': {capacity}");
            }
#endif
            if (array == null)
            {
                throw new NullReferenceException(nameof(array));
            }
            if (arrayIndex < 0)
            {
                throw new IndexOutOfRangeException(nameof(arrayIndex));
            }
            if (count <= 0)
            {
                throw new IndexOutOfRangeException(nameof(count));
            }
            if (array.Length - arrayIndex < count)
            {
                throw new ArgumentException($"There is not enough space in {nameof(array)} to copy.");
            }

            var iMax = Math.Min(array.Length - arrayIndex, count);
            for (uint i = 0; i < iMax; ++i)
            {
                array[i + arrayIndex] = this[i];
            }
        }
		
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void RemoveAtInternal(uint index, uint capacity)
        {
#if !ANOTHERECS_RELEASE
            FArrayHelper.ThrowIfOutOfRange(index, capacity);
#endif
            if (index != capacity - 1)
            {
                for (uint i = index; i < capacity - 1; ++i)
                {
                    this[i] = this[i + 1];
                }
			}
			
			this[capacity - 1] = default;
        }
		
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
        object ICollection.Get(uint index)
            => this[index];

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
        void ICollection.Set(uint index, object @value)
        {
            this[index] = (TData)@value;
        }

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
        public IEnumerator<TData> GetEnumerator()
            => new Enumerator(ref this);
			
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
        IEnumerator IEnumerable.GetEnumerator()
            => GetEnumerator();


        public struct Enumerator : IEnumerator<TData>
        {
            private readonly FArray2<TData> _data;
            private uint _current;

			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			public Enumerator(ref FArray2<TData> data)
            {
                _data = data;
                _current = uint.MaxValue;
            }

            public TData Current
            {
                [MethodImpl(MethodImplOptions.AggressiveInlining)]
                get => _data[_current];
            }
			
            object IEnumerator.Current
			{
				[MethodImpl(MethodImplOptions.AggressiveInlining)]
                get => _data[_current];
			}

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public bool MoveNext()
                => ++_current < _data.Length;

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public void Reset()
            {
                _current = uint.MaxValue;
            }

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public void Dispose() { }
        }
    }
	[Serializable] internal struct Data4<TData> : ISerialize where TData : unmanaged 
    { 
        public TData p0, p1, p2, p3;

		public const uint LENGTH = 4;
        public unsafe void Pack(ref WriterContextSerializer writer) => FArrayHelper.Pack<TData>(ref writer, GCHandle.Alloc(this, GCHandleType.Pinned), LENGTH);
        public unsafe void Unpack(ref ReaderContextSerializer reader) => FArrayHelper.Unpack<TData>(ref reader, GCHandle.Alloc(this, GCHandleType.Pinned), LENGTH);
    }

    [Serializable]
    [ForceBlittable]
    public struct FArray4<TData> : ICollection<TData>, ISerialize, IEnumerable<TData>
        where TData : unmanaged
    {
		private Data4<TData> _data;

        public uint Length
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => Data4<TData>.LENGTH;
        }

        public bool IsReadOnly => false;

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Clear()
        {
			_data = default;
        }

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint IndexOf(TData item)
            => IndexOf(ref item, Length);

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint IndexOf(ref TData item)
            => IndexOf(ref item, Length);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal uint IndexOf(ref TData item, uint count)
        {
            for (uint i = 0; i < count; ++i)
            {
                if (EqualityComparer<TData>.Default.Equals(this[i], item))
                {
                    return i;
                }
            }
            return uint.MaxValue;
        }

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Contains(TData item)
            => Contains(ref item);

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Contains(ref TData item)
            => IndexOf(ref item) != uint.MaxValue;

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Insert(uint index, TData item)
        {
            Insert(index, ref item);
        }

        public void Insert(uint index, ref TData item)
        {
#if !ANOTHERECS_RELEASE
            FArrayHelper.ThrowIfOutOfRange(index, Length);
#endif
            for (uint i = Length - 1; i > index; --i)
            {
                this[i] = this[i - 1];
            }
            this[index] = item;
        }

        public bool Remove(TData item)
        {
            var index = IndexOf(ref item);
            if (index != uint.MaxValue)
            {
                RemoveAt(index);
                return true;
            }
            return false;
        }

		public void RemoveAt(uint index)
        {
			RemoveAtInternal(index, Length);
        }
		
        public void CopyTo(TData[] array, uint arrayIndex)
        {
            CopyTo(array, arrayIndex, Length, Length);
        }
		
		public void CopyTo(TData[] array, uint arrayIndex, uint count)
        {
            CopyTo(array, arrayIndex, count, Length);
        }

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Pack(ref WriterContextSerializer writer)
        {
			_data.Pack(ref writer);
        }

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Unpack(ref ReaderContextSerializer reader)
        {
			_data.Unpack(ref reader);
        }

        public TData this[uint index]
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
#if !ANOTHERECS_RELEASE
                FArrayHelper.ThrowIfOutOfRange(index, Length);
#endif
                return index switch
                {
                    0 => _data.p0,
                    1 => _data.p1,
                    2 => _data.p2,
                    3 => _data.p3,

                    _ => throw new IndexOutOfRangeException($"Index {index} is out of range Length {Length}."),
                };    
            }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set
            {
#if !ANOTHERECS_RELEASE
                FArrayHelper.ThrowIfOutOfRange(index, Length);
#endif
                switch(index)
                {
                    case 0: _data.p0 = value; break;
                    case 1: _data.p1 = value; break;
                    case 2: _data.p2 = value; break;
                    case 3: _data.p3 = value; break;

                    default: throw new IndexOutOfRangeException($"Index {index} is out of range Length {Length}.");
                };
            }
		}
		
		internal void CopyTo(TData[] array, uint arrayIndex, uint count, uint capacity)
        {
#if !ANOTHERECS_RELEASE
            if (count > capacity)
            {
                throw new ArgumentOutOfRangeException($"'{nameof(count)}':{count} must be less or equal than '{nameof(capacity)}': {capacity}");
            }
#endif
            if (array == null)
            {
                throw new NullReferenceException(nameof(array));
            }
            if (arrayIndex < 0)
            {
                throw new IndexOutOfRangeException(nameof(arrayIndex));
            }
            if (count <= 0)
            {
                throw new IndexOutOfRangeException(nameof(count));
            }
            if (array.Length - arrayIndex < count)
            {
                throw new ArgumentException($"There is not enough space in {nameof(array)} to copy.");
            }

            var iMax = Math.Min(array.Length - arrayIndex, count);
            for (uint i = 0; i < iMax; ++i)
            {
                array[i + arrayIndex] = this[i];
            }
        }
		
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void RemoveAtInternal(uint index, uint capacity)
        {
#if !ANOTHERECS_RELEASE
            FArrayHelper.ThrowIfOutOfRange(index, capacity);
#endif
            if (index != capacity - 1)
            {
                for (uint i = index; i < capacity - 1; ++i)
                {
                    this[i] = this[i + 1];
                }
			}
			
			this[capacity - 1] = default;
        }
		
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
        object ICollection.Get(uint index)
            => this[index];

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
        void ICollection.Set(uint index, object @value)
        {
            this[index] = (TData)@value;
        }

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
        public IEnumerator<TData> GetEnumerator()
            => new Enumerator(ref this);
			
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
        IEnumerator IEnumerable.GetEnumerator()
            => GetEnumerator();


        public struct Enumerator : IEnumerator<TData>
        {
            private readonly FArray4<TData> _data;
            private uint _current;

			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			public Enumerator(ref FArray4<TData> data)
            {
                _data = data;
                _current = uint.MaxValue;
            }

            public TData Current
            {
                [MethodImpl(MethodImplOptions.AggressiveInlining)]
                get => _data[_current];
            }
			
            object IEnumerator.Current
			{
				[MethodImpl(MethodImplOptions.AggressiveInlining)]
                get => _data[_current];
			}

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public bool MoveNext()
                => ++_current < _data.Length;

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public void Reset()
            {
                _current = uint.MaxValue;
            }

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public void Dispose() { }
        }
    }
	[Serializable] internal struct Data8<TData> : ISerialize where TData : unmanaged 
    { 
        public TData p0, p1, p2, p3, p4, p5, p6, p7;

		public const uint LENGTH = 8;
        public unsafe void Pack(ref WriterContextSerializer writer) => FArrayHelper.Pack<TData>(ref writer, GCHandle.Alloc(this, GCHandleType.Pinned), LENGTH);
        public unsafe void Unpack(ref ReaderContextSerializer reader) => FArrayHelper.Unpack<TData>(ref reader, GCHandle.Alloc(this, GCHandleType.Pinned), LENGTH);
    }

    [Serializable]
    [ForceBlittable]
    public struct FArray8<TData> : ICollection<TData>, ISerialize, IEnumerable<TData>
        where TData : unmanaged
    {
		private Data8<TData> _data;

        public uint Length
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => Data8<TData>.LENGTH;
        }

        public bool IsReadOnly => false;

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Clear()
        {
			_data = default;
        }

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint IndexOf(TData item)
            => IndexOf(ref item, Length);

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint IndexOf(ref TData item)
            => IndexOf(ref item, Length);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal uint IndexOf(ref TData item, uint count)
        {
            for (uint i = 0; i < count; ++i)
            {
                if (EqualityComparer<TData>.Default.Equals(this[i], item))
                {
                    return i;
                }
            }
            return uint.MaxValue;
        }

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Contains(TData item)
            => Contains(ref item);

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Contains(ref TData item)
            => IndexOf(ref item) != uint.MaxValue;

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Insert(uint index, TData item)
        {
            Insert(index, ref item);
        }

        public void Insert(uint index, ref TData item)
        {
#if !ANOTHERECS_RELEASE
            FArrayHelper.ThrowIfOutOfRange(index, Length);
#endif
            for (uint i = Length - 1; i > index; --i)
            {
                this[i] = this[i - 1];
            }
            this[index] = item;
        }

        public bool Remove(TData item)
        {
            var index = IndexOf(ref item);
            if (index != uint.MaxValue)
            {
                RemoveAt(index);
                return true;
            }
            return false;
        }

		public void RemoveAt(uint index)
        {
			RemoveAtInternal(index, Length);
        }
		
        public void CopyTo(TData[] array, uint arrayIndex)
        {
            CopyTo(array, arrayIndex, Length, Length);
        }
		
		public void CopyTo(TData[] array, uint arrayIndex, uint count)
        {
            CopyTo(array, arrayIndex, count, Length);
        }

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Pack(ref WriterContextSerializer writer)
        {
			_data.Pack(ref writer);
        }

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Unpack(ref ReaderContextSerializer reader)
        {
			_data.Unpack(ref reader);
        }

        public TData this[uint index]
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
#if !ANOTHERECS_RELEASE
                FArrayHelper.ThrowIfOutOfRange(index, Length);
#endif
                return index switch
                {
                    0 => _data.p0,
                    1 => _data.p1,
                    2 => _data.p2,
                    3 => _data.p3,
                    4 => _data.p4,
                    5 => _data.p5,
                    6 => _data.p6,
                    7 => _data.p7,

                    _ => throw new IndexOutOfRangeException($"Index {index} is out of range Length {Length}."),
                };    
            }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set
            {
#if !ANOTHERECS_RELEASE
                FArrayHelper.ThrowIfOutOfRange(index, Length);
#endif
                switch(index)
                {
                    case 0: _data.p0 = value; break;
                    case 1: _data.p1 = value; break;
                    case 2: _data.p2 = value; break;
                    case 3: _data.p3 = value; break;
                    case 4: _data.p4 = value; break;
                    case 5: _data.p5 = value; break;
                    case 6: _data.p6 = value; break;
                    case 7: _data.p7 = value; break;

                    default: throw new IndexOutOfRangeException($"Index {index} is out of range Length {Length}.");
                };
            }
		}
		
		internal void CopyTo(TData[] array, uint arrayIndex, uint count, uint capacity)
        {
#if !ANOTHERECS_RELEASE
            if (count > capacity)
            {
                throw new ArgumentOutOfRangeException($"'{nameof(count)}':{count} must be less or equal than '{nameof(capacity)}': {capacity}");
            }
#endif
            if (array == null)
            {
                throw new NullReferenceException(nameof(array));
            }
            if (arrayIndex < 0)
            {
                throw new IndexOutOfRangeException(nameof(arrayIndex));
            }
            if (count <= 0)
            {
                throw new IndexOutOfRangeException(nameof(count));
            }
            if (array.Length - arrayIndex < count)
            {
                throw new ArgumentException($"There is not enough space in {nameof(array)} to copy.");
            }

            var iMax = Math.Min(array.Length - arrayIndex, count);
            for (uint i = 0; i < iMax; ++i)
            {
                array[i + arrayIndex] = this[i];
            }
        }
		
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void RemoveAtInternal(uint index, uint capacity)
        {
#if !ANOTHERECS_RELEASE
            FArrayHelper.ThrowIfOutOfRange(index, capacity);
#endif
            if (index != capacity - 1)
            {
                for (uint i = index; i < capacity - 1; ++i)
                {
                    this[i] = this[i + 1];
                }
			}
			
			this[capacity - 1] = default;
        }
		
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
        object ICollection.Get(uint index)
            => this[index];

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
        void ICollection.Set(uint index, object @value)
        {
            this[index] = (TData)@value;
        }

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
        public IEnumerator<TData> GetEnumerator()
            => new Enumerator(ref this);
			
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
        IEnumerator IEnumerable.GetEnumerator()
            => GetEnumerator();


        public struct Enumerator : IEnumerator<TData>
        {
            private readonly FArray8<TData> _data;
            private uint _current;

			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			public Enumerator(ref FArray8<TData> data)
            {
                _data = data;
                _current = uint.MaxValue;
            }

            public TData Current
            {
                [MethodImpl(MethodImplOptions.AggressiveInlining)]
                get => _data[_current];
            }
			
            object IEnumerator.Current
			{
				[MethodImpl(MethodImplOptions.AggressiveInlining)]
                get => _data[_current];
			}

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public bool MoveNext()
                => ++_current < _data.Length;

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public void Reset()
            {
                _current = uint.MaxValue;
            }

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public void Dispose() { }
        }
    }
	[Serializable] internal struct Data16<TData> : ISerialize where TData : unmanaged 
    { 
        public TData p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15;

		public const uint LENGTH = 16;
        public unsafe void Pack(ref WriterContextSerializer writer) => FArrayHelper.Pack<TData>(ref writer, GCHandle.Alloc(this, GCHandleType.Pinned), LENGTH);
        public unsafe void Unpack(ref ReaderContextSerializer reader) => FArrayHelper.Unpack<TData>(ref reader, GCHandle.Alloc(this, GCHandleType.Pinned), LENGTH);
    }

    [Serializable]
    [ForceBlittable]
    public struct FArray16<TData> : ICollection<TData>, ISerialize, IEnumerable<TData>
        where TData : unmanaged
    {
		private Data16<TData> _data;

        public uint Length
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => Data16<TData>.LENGTH;
        }

        public bool IsReadOnly => false;

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Clear()
        {
			_data = default;
        }

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint IndexOf(TData item)
            => IndexOf(ref item, Length);

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint IndexOf(ref TData item)
            => IndexOf(ref item, Length);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal uint IndexOf(ref TData item, uint count)
        {
            for (uint i = 0; i < count; ++i)
            {
                if (EqualityComparer<TData>.Default.Equals(this[i], item))
                {
                    return i;
                }
            }
            return uint.MaxValue;
        }

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Contains(TData item)
            => Contains(ref item);

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Contains(ref TData item)
            => IndexOf(ref item) != uint.MaxValue;

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Insert(uint index, TData item)
        {
            Insert(index, ref item);
        }

        public void Insert(uint index, ref TData item)
        {
#if !ANOTHERECS_RELEASE
            FArrayHelper.ThrowIfOutOfRange(index, Length);
#endif
            for (uint i = Length - 1; i > index; --i)
            {
                this[i] = this[i - 1];
            }
            this[index] = item;
        }

        public bool Remove(TData item)
        {
            var index = IndexOf(ref item);
            if (index != uint.MaxValue)
            {
                RemoveAt(index);
                return true;
            }
            return false;
        }

		public void RemoveAt(uint index)
        {
			RemoveAtInternal(index, Length);
        }
		
        public void CopyTo(TData[] array, uint arrayIndex)
        {
            CopyTo(array, arrayIndex, Length, Length);
        }
		
		public void CopyTo(TData[] array, uint arrayIndex, uint count)
        {
            CopyTo(array, arrayIndex, count, Length);
        }

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Pack(ref WriterContextSerializer writer)
        {
			_data.Pack(ref writer);
        }

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Unpack(ref ReaderContextSerializer reader)
        {
			_data.Unpack(ref reader);
        }

        public TData this[uint index]
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
#if !ANOTHERECS_RELEASE
                FArrayHelper.ThrowIfOutOfRange(index, Length);
#endif
                return index switch
                {
                    0 => _data.p0,
                    1 => _data.p1,
                    2 => _data.p2,
                    3 => _data.p3,
                    4 => _data.p4,
                    5 => _data.p5,
                    6 => _data.p6,
                    7 => _data.p7,
                    8 => _data.p8,
                    9 => _data.p9,
                    10 => _data.p10,
                    11 => _data.p11,
                    12 => _data.p12,
                    13 => _data.p13,
                    14 => _data.p14,
                    15 => _data.p15,

                    _ => throw new IndexOutOfRangeException($"Index {index} is out of range Length {Length}."),
                };    
            }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set
            {
#if !ANOTHERECS_RELEASE
                FArrayHelper.ThrowIfOutOfRange(index, Length);
#endif
                switch(index)
                {
                    case 0: _data.p0 = value; break;
                    case 1: _data.p1 = value; break;
                    case 2: _data.p2 = value; break;
                    case 3: _data.p3 = value; break;
                    case 4: _data.p4 = value; break;
                    case 5: _data.p5 = value; break;
                    case 6: _data.p6 = value; break;
                    case 7: _data.p7 = value; break;
                    case 8: _data.p8 = value; break;
                    case 9: _data.p9 = value; break;
                    case 10: _data.p10 = value; break;
                    case 11: _data.p11 = value; break;
                    case 12: _data.p12 = value; break;
                    case 13: _data.p13 = value; break;
                    case 14: _data.p14 = value; break;
                    case 15: _data.p15 = value; break;

                    default: throw new IndexOutOfRangeException($"Index {index} is out of range Length {Length}.");
                };
            }
		}
		
		internal void CopyTo(TData[] array, uint arrayIndex, uint count, uint capacity)
        {
#if !ANOTHERECS_RELEASE
            if (count > capacity)
            {
                throw new ArgumentOutOfRangeException($"'{nameof(count)}':{count} must be less or equal than '{nameof(capacity)}': {capacity}");
            }
#endif
            if (array == null)
            {
                throw new NullReferenceException(nameof(array));
            }
            if (arrayIndex < 0)
            {
                throw new IndexOutOfRangeException(nameof(arrayIndex));
            }
            if (count <= 0)
            {
                throw new IndexOutOfRangeException(nameof(count));
            }
            if (array.Length - arrayIndex < count)
            {
                throw new ArgumentException($"There is not enough space in {nameof(array)} to copy.");
            }

            var iMax = Math.Min(array.Length - arrayIndex, count);
            for (uint i = 0; i < iMax; ++i)
            {
                array[i + arrayIndex] = this[i];
            }
        }
		
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void RemoveAtInternal(uint index, uint capacity)
        {
#if !ANOTHERECS_RELEASE
            FArrayHelper.ThrowIfOutOfRange(index, capacity);
#endif
            if (index != capacity - 1)
            {
                for (uint i = index; i < capacity - 1; ++i)
                {
                    this[i] = this[i + 1];
                }
			}
			
			this[capacity - 1] = default;
        }
		
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
        object ICollection.Get(uint index)
            => this[index];

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
        void ICollection.Set(uint index, object @value)
        {
            this[index] = (TData)@value;
        }

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
        public IEnumerator<TData> GetEnumerator()
            => new Enumerator(ref this);
			
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
        IEnumerator IEnumerable.GetEnumerator()
            => GetEnumerator();


        public struct Enumerator : IEnumerator<TData>
        {
            private readonly FArray16<TData> _data;
            private uint _current;

			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			public Enumerator(ref FArray16<TData> data)
            {
                _data = data;
                _current = uint.MaxValue;
            }

            public TData Current
            {
                [MethodImpl(MethodImplOptions.AggressiveInlining)]
                get => _data[_current];
            }
			
            object IEnumerator.Current
			{
				[MethodImpl(MethodImplOptions.AggressiveInlining)]
                get => _data[_current];
			}

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public bool MoveNext()
                => ++_current < _data.Length;

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public void Reset()
            {
                _current = uint.MaxValue;
            }

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public void Dispose() { }
        }
    }
	[Serializable] internal struct Data32<TData> : ISerialize where TData : unmanaged 
    { 
        public TData p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16, p17, p18, p19, p20, p21, p22, p23, p24, p25, p26, p27, p28, p29, p30, p31;

		public const uint LENGTH = 32;
        public unsafe void Pack(ref WriterContextSerializer writer) => FArrayHelper.Pack<TData>(ref writer, GCHandle.Alloc(this, GCHandleType.Pinned), LENGTH);
        public unsafe void Unpack(ref ReaderContextSerializer reader) => FArrayHelper.Unpack<TData>(ref reader, GCHandle.Alloc(this, GCHandleType.Pinned), LENGTH);
    }

    [Serializable]
    [ForceBlittable]
    public struct FArray32<TData> : ICollection<TData>, ISerialize, IEnumerable<TData>
        where TData : unmanaged
    {
		private Data32<TData> _data;

        public uint Length
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => Data32<TData>.LENGTH;
        }

        public bool IsReadOnly => false;

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Clear()
        {
			_data = default;
        }

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint IndexOf(TData item)
            => IndexOf(ref item, Length);

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint IndexOf(ref TData item)
            => IndexOf(ref item, Length);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal uint IndexOf(ref TData item, uint count)
        {
            for (uint i = 0; i < count; ++i)
            {
                if (EqualityComparer<TData>.Default.Equals(this[i], item))
                {
                    return i;
                }
            }
            return uint.MaxValue;
        }

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Contains(TData item)
            => Contains(ref item);

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Contains(ref TData item)
            => IndexOf(ref item) != uint.MaxValue;

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Insert(uint index, TData item)
        {
            Insert(index, ref item);
        }

        public void Insert(uint index, ref TData item)
        {
#if !ANOTHERECS_RELEASE
            FArrayHelper.ThrowIfOutOfRange(index, Length);
#endif
            for (uint i = Length - 1; i > index; --i)
            {
                this[i] = this[i - 1];
            }
            this[index] = item;
        }

        public bool Remove(TData item)
        {
            var index = IndexOf(ref item);
            if (index != uint.MaxValue)
            {
                RemoveAt(index);
                return true;
            }
            return false;
        }

		public void RemoveAt(uint index)
        {
			RemoveAtInternal(index, Length);
        }
		
        public void CopyTo(TData[] array, uint arrayIndex)
        {
            CopyTo(array, arrayIndex, Length, Length);
        }
		
		public void CopyTo(TData[] array, uint arrayIndex, uint count)
        {
            CopyTo(array, arrayIndex, count, Length);
        }

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Pack(ref WriterContextSerializer writer)
        {
			_data.Pack(ref writer);
        }

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Unpack(ref ReaderContextSerializer reader)
        {
			_data.Unpack(ref reader);
        }

        public TData this[uint index]
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
#if !ANOTHERECS_RELEASE
                FArrayHelper.ThrowIfOutOfRange(index, Length);
#endif
                return index switch
                {
                    0 => _data.p0,
                    1 => _data.p1,
                    2 => _data.p2,
                    3 => _data.p3,
                    4 => _data.p4,
                    5 => _data.p5,
                    6 => _data.p6,
                    7 => _data.p7,
                    8 => _data.p8,
                    9 => _data.p9,
                    10 => _data.p10,
                    11 => _data.p11,
                    12 => _data.p12,
                    13 => _data.p13,
                    14 => _data.p14,
                    15 => _data.p15,
                    16 => _data.p16,
                    17 => _data.p17,
                    18 => _data.p18,
                    19 => _data.p19,
                    20 => _data.p20,
                    21 => _data.p21,
                    22 => _data.p22,
                    23 => _data.p23,
                    24 => _data.p24,
                    25 => _data.p25,
                    26 => _data.p26,
                    27 => _data.p27,
                    28 => _data.p28,
                    29 => _data.p29,
                    30 => _data.p30,
                    31 => _data.p31,

                    _ => throw new IndexOutOfRangeException($"Index {index} is out of range Length {Length}."),
                };    
            }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set
            {
#if !ANOTHERECS_RELEASE
                FArrayHelper.ThrowIfOutOfRange(index, Length);
#endif
                switch(index)
                {
                    case 0: _data.p0 = value; break;
                    case 1: _data.p1 = value; break;
                    case 2: _data.p2 = value; break;
                    case 3: _data.p3 = value; break;
                    case 4: _data.p4 = value; break;
                    case 5: _data.p5 = value; break;
                    case 6: _data.p6 = value; break;
                    case 7: _data.p7 = value; break;
                    case 8: _data.p8 = value; break;
                    case 9: _data.p9 = value; break;
                    case 10: _data.p10 = value; break;
                    case 11: _data.p11 = value; break;
                    case 12: _data.p12 = value; break;
                    case 13: _data.p13 = value; break;
                    case 14: _data.p14 = value; break;
                    case 15: _data.p15 = value; break;
                    case 16: _data.p16 = value; break;
                    case 17: _data.p17 = value; break;
                    case 18: _data.p18 = value; break;
                    case 19: _data.p19 = value; break;
                    case 20: _data.p20 = value; break;
                    case 21: _data.p21 = value; break;
                    case 22: _data.p22 = value; break;
                    case 23: _data.p23 = value; break;
                    case 24: _data.p24 = value; break;
                    case 25: _data.p25 = value; break;
                    case 26: _data.p26 = value; break;
                    case 27: _data.p27 = value; break;
                    case 28: _data.p28 = value; break;
                    case 29: _data.p29 = value; break;
                    case 30: _data.p30 = value; break;
                    case 31: _data.p31 = value; break;

                    default: throw new IndexOutOfRangeException($"Index {index} is out of range Length {Length}.");
                };
            }
		}
		
		internal void CopyTo(TData[] array, uint arrayIndex, uint count, uint capacity)
        {
#if !ANOTHERECS_RELEASE
            if (count > capacity)
            {
                throw new ArgumentOutOfRangeException($"'{nameof(count)}':{count} must be less or equal than '{nameof(capacity)}': {capacity}");
            }
#endif
            if (array == null)
            {
                throw new NullReferenceException(nameof(array));
            }
            if (arrayIndex < 0)
            {
                throw new IndexOutOfRangeException(nameof(arrayIndex));
            }
            if (count <= 0)
            {
                throw new IndexOutOfRangeException(nameof(count));
            }
            if (array.Length - arrayIndex < count)
            {
                throw new ArgumentException($"There is not enough space in {nameof(array)} to copy.");
            }

            var iMax = Math.Min(array.Length - arrayIndex, count);
            for (uint i = 0; i < iMax; ++i)
            {
                array[i + arrayIndex] = this[i];
            }
        }
		
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void RemoveAtInternal(uint index, uint capacity)
        {
#if !ANOTHERECS_RELEASE
            FArrayHelper.ThrowIfOutOfRange(index, capacity);
#endif
            if (index != capacity - 1)
            {
                for (uint i = index; i < capacity - 1; ++i)
                {
                    this[i] = this[i + 1];
                }
			}
			
			this[capacity - 1] = default;
        }
		
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
        object ICollection.Get(uint index)
            => this[index];

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
        void ICollection.Set(uint index, object @value)
        {
            this[index] = (TData)@value;
        }

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
        public IEnumerator<TData> GetEnumerator()
            => new Enumerator(ref this);
			
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
        IEnumerator IEnumerable.GetEnumerator()
            => GetEnumerator();


        public struct Enumerator : IEnumerator<TData>
        {
            private readonly FArray32<TData> _data;
            private uint _current;

			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			public Enumerator(ref FArray32<TData> data)
            {
                _data = data;
                _current = uint.MaxValue;
            }

            public TData Current
            {
                [MethodImpl(MethodImplOptions.AggressiveInlining)]
                get => _data[_current];
            }
			
            object IEnumerator.Current
			{
				[MethodImpl(MethodImplOptions.AggressiveInlining)]
                get => _data[_current];
			}

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public bool MoveNext()
                => ++_current < _data.Length;

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public void Reset()
            {
                _current = uint.MaxValue;
            }

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public void Dispose() { }
        }
    }
	[Serializable] internal struct Data64<TData> : ISerialize where TData : unmanaged 
    { 
        public TData p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16, p17, p18, p19, p20, p21, p22, p23, p24, p25, p26, p27, p28, p29, p30, p31, p32, p33, p34, p35, p36, p37, p38, p39, p40, p41, p42, p43, p44, p45, p46, p47, p48, p49, p50, p51, p52, p53, p54, p55, p56, p57, p58, p59, p60, p61, p62, p63;

		public const uint LENGTH = 64;
        public unsafe void Pack(ref WriterContextSerializer writer) => FArrayHelper.Pack<TData>(ref writer, GCHandle.Alloc(this, GCHandleType.Pinned), LENGTH);
        public unsafe void Unpack(ref ReaderContextSerializer reader) => FArrayHelper.Unpack<TData>(ref reader, GCHandle.Alloc(this, GCHandleType.Pinned), LENGTH);
    }

    [Serializable]
    [ForceBlittable]
    public struct FArray64<TData> : ICollection<TData>, ISerialize, IEnumerable<TData>
        where TData : unmanaged
    {
		private Data64<TData> _data;

        public uint Length
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => Data64<TData>.LENGTH;
        }

        public bool IsReadOnly => false;

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Clear()
        {
			_data = default;
        }

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint IndexOf(TData item)
            => IndexOf(ref item, Length);

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint IndexOf(ref TData item)
            => IndexOf(ref item, Length);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal uint IndexOf(ref TData item, uint count)
        {
            for (uint i = 0; i < count; ++i)
            {
                if (EqualityComparer<TData>.Default.Equals(this[i], item))
                {
                    return i;
                }
            }
            return uint.MaxValue;
        }

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Contains(TData item)
            => Contains(ref item);

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Contains(ref TData item)
            => IndexOf(ref item) != uint.MaxValue;

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Insert(uint index, TData item)
        {
            Insert(index, ref item);
        }

        public void Insert(uint index, ref TData item)
        {
#if !ANOTHERECS_RELEASE
            FArrayHelper.ThrowIfOutOfRange(index, Length);
#endif
            for (uint i = Length - 1; i > index; --i)
            {
                this[i] = this[i - 1];
            }
            this[index] = item;
        }

        public bool Remove(TData item)
        {
            var index = IndexOf(ref item);
            if (index != uint.MaxValue)
            {
                RemoveAt(index);
                return true;
            }
            return false;
        }

		public void RemoveAt(uint index)
        {
			RemoveAtInternal(index, Length);
        }
		
        public void CopyTo(TData[] array, uint arrayIndex)
        {
            CopyTo(array, arrayIndex, Length, Length);
        }
		
		public void CopyTo(TData[] array, uint arrayIndex, uint count)
        {
            CopyTo(array, arrayIndex, count, Length);
        }

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Pack(ref WriterContextSerializer writer)
        {
			_data.Pack(ref writer);
        }

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Unpack(ref ReaderContextSerializer reader)
        {
			_data.Unpack(ref reader);
        }

        public TData this[uint index]
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
#if !ANOTHERECS_RELEASE
                FArrayHelper.ThrowIfOutOfRange(index, Length);
#endif
                return index switch
                {
                    0 => _data.p0,
                    1 => _data.p1,
                    2 => _data.p2,
                    3 => _data.p3,
                    4 => _data.p4,
                    5 => _data.p5,
                    6 => _data.p6,
                    7 => _data.p7,
                    8 => _data.p8,
                    9 => _data.p9,
                    10 => _data.p10,
                    11 => _data.p11,
                    12 => _data.p12,
                    13 => _data.p13,
                    14 => _data.p14,
                    15 => _data.p15,
                    16 => _data.p16,
                    17 => _data.p17,
                    18 => _data.p18,
                    19 => _data.p19,
                    20 => _data.p20,
                    21 => _data.p21,
                    22 => _data.p22,
                    23 => _data.p23,
                    24 => _data.p24,
                    25 => _data.p25,
                    26 => _data.p26,
                    27 => _data.p27,
                    28 => _data.p28,
                    29 => _data.p29,
                    30 => _data.p30,
                    31 => _data.p31,
                    32 => _data.p32,
                    33 => _data.p33,
                    34 => _data.p34,
                    35 => _data.p35,
                    36 => _data.p36,
                    37 => _data.p37,
                    38 => _data.p38,
                    39 => _data.p39,
                    40 => _data.p40,
                    41 => _data.p41,
                    42 => _data.p42,
                    43 => _data.p43,
                    44 => _data.p44,
                    45 => _data.p45,
                    46 => _data.p46,
                    47 => _data.p47,
                    48 => _data.p48,
                    49 => _data.p49,
                    50 => _data.p50,
                    51 => _data.p51,
                    52 => _data.p52,
                    53 => _data.p53,
                    54 => _data.p54,
                    55 => _data.p55,
                    56 => _data.p56,
                    57 => _data.p57,
                    58 => _data.p58,
                    59 => _data.p59,
                    60 => _data.p60,
                    61 => _data.p61,
                    62 => _data.p62,
                    63 => _data.p63,

                    _ => throw new IndexOutOfRangeException($"Index {index} is out of range Length {Length}."),
                };    
            }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set
            {
#if !ANOTHERECS_RELEASE
                FArrayHelper.ThrowIfOutOfRange(index, Length);
#endif
                switch(index)
                {
                    case 0: _data.p0 = value; break;
                    case 1: _data.p1 = value; break;
                    case 2: _data.p2 = value; break;
                    case 3: _data.p3 = value; break;
                    case 4: _data.p4 = value; break;
                    case 5: _data.p5 = value; break;
                    case 6: _data.p6 = value; break;
                    case 7: _data.p7 = value; break;
                    case 8: _data.p8 = value; break;
                    case 9: _data.p9 = value; break;
                    case 10: _data.p10 = value; break;
                    case 11: _data.p11 = value; break;
                    case 12: _data.p12 = value; break;
                    case 13: _data.p13 = value; break;
                    case 14: _data.p14 = value; break;
                    case 15: _data.p15 = value; break;
                    case 16: _data.p16 = value; break;
                    case 17: _data.p17 = value; break;
                    case 18: _data.p18 = value; break;
                    case 19: _data.p19 = value; break;
                    case 20: _data.p20 = value; break;
                    case 21: _data.p21 = value; break;
                    case 22: _data.p22 = value; break;
                    case 23: _data.p23 = value; break;
                    case 24: _data.p24 = value; break;
                    case 25: _data.p25 = value; break;
                    case 26: _data.p26 = value; break;
                    case 27: _data.p27 = value; break;
                    case 28: _data.p28 = value; break;
                    case 29: _data.p29 = value; break;
                    case 30: _data.p30 = value; break;
                    case 31: _data.p31 = value; break;
                    case 32: _data.p32 = value; break;
                    case 33: _data.p33 = value; break;
                    case 34: _data.p34 = value; break;
                    case 35: _data.p35 = value; break;
                    case 36: _data.p36 = value; break;
                    case 37: _data.p37 = value; break;
                    case 38: _data.p38 = value; break;
                    case 39: _data.p39 = value; break;
                    case 40: _data.p40 = value; break;
                    case 41: _data.p41 = value; break;
                    case 42: _data.p42 = value; break;
                    case 43: _data.p43 = value; break;
                    case 44: _data.p44 = value; break;
                    case 45: _data.p45 = value; break;
                    case 46: _data.p46 = value; break;
                    case 47: _data.p47 = value; break;
                    case 48: _data.p48 = value; break;
                    case 49: _data.p49 = value; break;
                    case 50: _data.p50 = value; break;
                    case 51: _data.p51 = value; break;
                    case 52: _data.p52 = value; break;
                    case 53: _data.p53 = value; break;
                    case 54: _data.p54 = value; break;
                    case 55: _data.p55 = value; break;
                    case 56: _data.p56 = value; break;
                    case 57: _data.p57 = value; break;
                    case 58: _data.p58 = value; break;
                    case 59: _data.p59 = value; break;
                    case 60: _data.p60 = value; break;
                    case 61: _data.p61 = value; break;
                    case 62: _data.p62 = value; break;
                    case 63: _data.p63 = value; break;

                    default: throw new IndexOutOfRangeException($"Index {index} is out of range Length {Length}.");
                };
            }
		}
		
		internal void CopyTo(TData[] array, uint arrayIndex, uint count, uint capacity)
        {
#if !ANOTHERECS_RELEASE
            if (count > capacity)
            {
                throw new ArgumentOutOfRangeException($"'{nameof(count)}':{count} must be less or equal than '{nameof(capacity)}': {capacity}");
            }
#endif
            if (array == null)
            {
                throw new NullReferenceException(nameof(array));
            }
            if (arrayIndex < 0)
            {
                throw new IndexOutOfRangeException(nameof(arrayIndex));
            }
            if (count <= 0)
            {
                throw new IndexOutOfRangeException(nameof(count));
            }
            if (array.Length - arrayIndex < count)
            {
                throw new ArgumentException($"There is not enough space in {nameof(array)} to copy.");
            }

            var iMax = Math.Min(array.Length - arrayIndex, count);
            for (uint i = 0; i < iMax; ++i)
            {
                array[i + arrayIndex] = this[i];
            }
        }
		
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void RemoveAtInternal(uint index, uint capacity)
        {
#if !ANOTHERECS_RELEASE
            FArrayHelper.ThrowIfOutOfRange(index, capacity);
#endif
            if (index != capacity - 1)
            {
                for (uint i = index; i < capacity - 1; ++i)
                {
                    this[i] = this[i + 1];
                }
			}
			
			this[capacity - 1] = default;
        }
		
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
        object ICollection.Get(uint index)
            => this[index];

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
        void ICollection.Set(uint index, object @value)
        {
            this[index] = (TData)@value;
        }

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
        public IEnumerator<TData> GetEnumerator()
            => new Enumerator(ref this);
			
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
        IEnumerator IEnumerable.GetEnumerator()
            => GetEnumerator();


        public struct Enumerator : IEnumerator<TData>
        {
            private readonly FArray64<TData> _data;
            private uint _current;

			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			public Enumerator(ref FArray64<TData> data)
            {
                _data = data;
                _current = uint.MaxValue;
            }

            public TData Current
            {
                [MethodImpl(MethodImplOptions.AggressiveInlining)]
                get => _data[_current];
            }
			
            object IEnumerator.Current
			{
				[MethodImpl(MethodImplOptions.AggressiveInlining)]
                get => _data[_current];
			}

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public bool MoveNext()
                => ++_current < _data.Length;

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public void Reset()
            {
                _current = uint.MaxValue;
            }

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public void Dispose() { }
        }
    }

}