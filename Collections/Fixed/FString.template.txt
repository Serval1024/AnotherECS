<#META GENERATOR = AnotherECS.Generator.FStringGenerator FILENAME = FString.cs#>

// <auto-generated>
// This source code was auto-generated by FStringGenerator.cs
// </auto-generated>

using AnotherECS.Core;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using System.Text;

namespace AnotherECS.Collections
{
<#ARRAY [0..STRUCT_COUNT]#>
    [ForceBlittable]
    public unsafe struct FString<#ELEMENT_COUNT#> : IEquatable<FString<#ELEMENT_COUNT#>>, IEquatable<string>, IEquatable<ICString<char>>, IEnumerable<char>, ICString<char>
    {
		public static readonly FString<#ELEMENT_COUNT#> Empty = new();
	
		private FList<#ELEMENT_COUNT#><char> _data;

		public uint Capacity
		{
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			get => _data.Capacity;
		}
		
		public uint Length
		{
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			get => _data.Count;
		}

        public FString<#ELEMENT_COUNT#>(string text)
        {
			_data = default;
            if (text.Length > Capacity)
            {
                throw new ArgumentException($"{nameof(text)} is longer than capacity. Capacity: '{Capacity}'. text length '{text.Length}'");
            }

            for (int i = 0; i < text.Length; ++i)
            {
                _data[i] = text[i];
            }
            _data.Count = (uint)text.Length;
        }

        public static implicit operator string(FString<#ELEMENT_COUNT#> fstring) => fstring.ToString();
        public static explicit operator FString<#ELEMENT_COUNT#>(string text) => new(text);

        public static FString<#ELEMENT_COUNT#> operator +(FString<#ELEMENT_COUNT#> a, FString<#ELEMENT_COUNT#> b)
        {
            if (a.Length + b.Length > a.Capacity)
            {
                throw new ArgumentException($"Capacity not enough. Capacity: '{a.Capacity}'. Requirement: '{a.Length + b.Length}'.");
            }

            FString<#ELEMENT_COUNT#> result = a;
            var offset = a.Length;
            for (uint i = 0; i < b.Length; ++i)
            {
                result._data[i + offset] = b._data[i];
            }
            result._data.Count = (a.Length + b.Length);

            return result;
        }

        public static bool operator ==(FString<#ELEMENT_COUNT#> a, FString<#ELEMENT_COUNT#> b)
            => a.Equals(ref b);

        public static bool operator !=(FString<#ELEMENT_COUNT#> a, FString<#ELEMENT_COUNT#> b)
            => !a.Equals(ref b);

        public static bool operator ==(FString<#ELEMENT_COUNT#> a, ICString<char> b)
            => a.Equals(b);

        public static bool operator !=(FString<#ELEMENT_COUNT#> a, ICString<char> b)
            => !a.Equals(b);

        public static bool operator ==(FString<#ELEMENT_COUNT#> a, string b)
            => a.Equals(b);

        public static bool operator !=(FString<#ELEMENT_COUNT#> a, string b)
            => !a.Equals(b);

        public char this[uint index]
        {
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => _data[index];
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
            set => _data[index] = value;
        }

        public void Set(string text)
        {
            this = new(text);
        }

        public override string ToString()
        {
#pragma warning disable CS0162
            if (Capacity <= 16)
            {
                var text = string.Empty;
                for (uint i = 0; i < Length; ++i)
                {
                    text += _data[i];
                }
                return text;
            }
            else
            {
                var stringBuilder = new StringBuilder();
                for (uint i = 0; i < Length; ++i)
                {
                    stringBuilder.Append(_data[i]);
                }
                return stringBuilder.ToString();
#pragma warning restore CS0162
            }
        }

         public override bool Equals(object obj)
        {
            if (obj is FString2 fString)
            {
                return Equals(ref fString);
            }
            else if (obj is ICString<char> iString)
            {
                return Equals(iString);
            }
            else if (obj is string cString)
            {
                return Equals(cString);
            }
            return false;
        }

        public bool Equals(string other)
        {
            if (Length == other.Length)
            {
                for (int i = 0; i < Length; ++i)
                {
                    if (_data[i] != other[i])
                    {
                        return false;
                    }
                }
                return true;
            }
            return false;
        }

        public bool Equals(FString<#ELEMENT_COUNT#> other)
            => Equals(ref other);

        public bool Equals(ref FString<#ELEMENT_COUNT#> other)
        {
            if (Length == other.Length)
            {
                for (uint i = 0; i < Length; ++i)
                {
                    if (_data[i] != other._data[i])
                    {
                        return false;
                    }
                }
                return true;
            }
            return false;
        }

        public bool Equals<TCString>(ref TCString other)
            where TCString : struct, ICString<char>
        {
            if (Length == other.Length)
            {
                for (uint i = 0; i < Length; ++i)
                {
                    if (!_data[i].Equals(other[i]))
                    {
                        return false;
                    }
                }
                return true;
            }
            return false;
        }

        public bool Equals(ICString<char> other)
        {
            if (Length == other.Length)
            {
                for (uint i = 0; i < Length; ++i)
                {
                    if (!_data[i].Equals(other[i]))
                    {
                        return false;
                    }
                }
                return true;
            }
            return false;
        }

        public override int GetHashCode()
        {
            HashCode hash = default;
            hash.Add(Length);
            for(uint i = 0; i < Length; ++i)
            {
                hash.Add(_data[i]);
            }

            return hash.ToHashCode();
        }

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
        public IEnumerator<char> GetEnumerator()
            => new Enumerator(ref this);

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
        IEnumerator IEnumerable.GetEnumerator()
            => GetEnumerator();


        public struct Enumerator : IEnumerator<char>
        {
            private readonly FString<#ELEMENT_COUNT#> _data;
            private uint _current;

            public Enumerator(ref FString<#ELEMENT_COUNT#> data)
            {
                _data = data;
                _current = uint.MaxValue;
            }

            public char Current
            {
                [MethodImpl(MethodImplOptions.AggressiveInlining)]
                get => _data[_current];
            }

            object IEnumerator.Current
                => _data[_current];

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public bool MoveNext()
                => ++_current < _data.Length;

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public void Reset()
            {
                _current = uint.MaxValue;
            }

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public void Dispose() { }
        }
    }
<#END#>
}
