<#META GENERATOR = AnotherECS.Editor.Generator.FListGenerator FILENAME = FList.cs#>

// <auto-generated>
// This source code was auto-generated by FListGenerator.cs
// </auto-generated>

using System;
using System.Collections;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using AnotherECS.Serializer;

namespace AnotherECS.Collections
{
<#ARRAY [0..STRUCT_COUNT]#>
    [Serializable] public struct Data<#ELEMENT_COUNT#><T> : ISerialize where T : unmanaged 
    { 
        public T <#ARRAY [0..ELEMENT_COUNT]#>p<#INDEX1#><#SEPARATOR1:,#><#END#>;

        public unsafe void Pack(ref WriterContextSerializer writer) => FListHelper.Pack<T>(ref writer, GCHandle.Alloc(this, GCHandleType.Pinned), <#ELEMENT_COUNT#>);
        public unsafe void Unpack(ref ReaderContextSerializer reader) => FListHelper.Unpack<T>(ref reader, GCHandle.Alloc(this, GCHandleType.Pinned), <#ELEMENT_COUNT#>);
    }

    [Serializable]
    [ForceBlittable]
    public struct FList<#ELEMENT_COUNT#><TData> : IFList, IFList<TData>, IList<TData>, ISerialize
        where TData : unmanaged
    {
        public Data<#ELEMENT_COUNT#><TData> _data;
        public int _count;

        public int Capacity
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => <#ELEMENT_COUNT#>;
        }

        public int Count
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => _count;
        }

        public bool IsReadOnly => false;

        public void ExtendToCapacity()
        {
            _count = Capacity;
        }

        public void Add(TData value)
        {
#if ANOTHERECS_DEBUG
            FListHelper.ThrowIfOutOfRange(_count, Capacity);
#endif
            this[_count++] = value;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void RemoveLast()
        {
            if (_count != 0)
            {
                this[--_count] = default;
            }
        }

        public void RemoveAt(int index)
        {
#if ANOTHERECS_DEBUG
            FListHelper.ThrowIfOutOfRange(_count, Capacity);
#endif
            if (index == _count - 1)
            {
                RemoveLast();
            }
            else
            {
                for (int i = index; i < _count - 1; ++i)
                {
                    this[i] = this[i + 1];
                }
                this[_count - 1] = default;
                --_count;
            }
        }

        public void Clear()
        {
            _data = default;
        }

        public object Get(int index)
            => this[index];

        public void Set(int index, object @value)
        {
            this[index] = (TData)@value;
        }

        public void Add(object value)
        {
#if ANOTHERECS_DEBUG
            FListHelper.ThrowIfOutOfRange(_count, Capacity);
#endif
            this[_count++] = (TData)value;
        }

        public IEnumerator<TData> GetEnumerator()
            => new Enumerator(ref this);

        IEnumerator IEnumerable.GetEnumerator()
            => GetEnumerator();

        public int IndexOf(TData item)
            => IndexOf(ref item, _count);

        public int IndexOf(ref TData item)
            => IndexOf(ref item, _count);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal int IndexOf(ref TData item, int count)
        {
            for (int i = 0; i < count; ++i)
            {
                if (EqualityComparer<TData>.Default.Equals(this[i], item))
                {
                    return i;
                }
            }
            return -1;
        }

        public bool Contains(TData item)
            => Contains(ref item);

        public bool Contains(ref TData item)
            => IndexOf(ref item) != -1;

        public void Insert(int index, TData item)
        {
            Insert(index, ref item);
        }

        public void Insert(int index, ref TData item)
        {
#if ANOTHERECS_DEBUG
            FListHelper.ThrowIfOutOfRange(_count, Capacity);
#endif
            for (int i = _count; i < index; --i)
            {
                this[i] = this[i - 1];
            }
            this[index] = item;
            ++_count;
        }

        public bool Remove(TData item)
        {
            var index = IndexOf(ref item);
            if (index != -1)
            {
                RemoveAt(index);
                return true;
            }
            return false;
        }

        public void CopyTo(TData[] array, int arrayIndex)
        {
            CopyTo(array, arrayIndex, _count);
        }

        public void CopyTo(TData[] array, int arrayIndex, int count)
        {
#if ANOTHERECS_DEBUG
            if (count > _count)
            {
                throw new ArgumentOutOfRangeException($"'{nameof(count)}':{count} must be less or equal than '{nameof(_count)}': {_count}");
            }
#endif
            if (array == null)
            {
                throw new NullReferenceException(nameof(array));
            }
            if (arrayIndex < 0)
            {
                throw new IndexOutOfRangeException(nameof(arrayIndex));
            }
            if (count <= 0)
            {
                throw new IndexOutOfRangeException(nameof(count));
            }
            if (array.Length - arrayIndex < count)
            {
                throw new ArgumentException($"There is not enough space in {nameof(array)} to copy.");
            }

            var iMax = Math.Min(array.Length - arrayIndex, count);
            for (int i = 0; i < iMax; ++i)
            {
                array[i + arrayIndex] = this[i];
            }
        }

        public void Pack(ref WriterContextSerializer writer)
        {
            writer.Write(_count);
            _data.Pack(ref writer);
        }

        public void Unpack(ref ReaderContextSerializer reader)
        {
            _count = reader.ReadInt32();
            _data.Unpack(ref reader);
        }

        public TData this[int index]
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
#if ANOTHERECS_DEBUG
                FListHelper.ThrowIfOutOfRange(index, Count);
#endif
                return index switch
                {
<#ARRAY [0..ELEMENT_COUNT]#>
                    <#INDEX1#> => _data.p<#INDEX1#>,
<#END#>
                    _ => throw new IndexOutOfRangeException($"Index {index} is out of range Length {Count}."),
                };    
            }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set
            {
#if ANOTHERECS_DEBUG
                FListHelper.ThrowIfOutOfRange(index, Count);
#endif
                switch(index)
                {
<#ARRAY [0..ELEMENT_COUNT]#>
                    case <#INDEX1#>: _data.p<#INDEX1#> = value; break;
<#END#>
                    default: throw new IndexOutOfRangeException($"Index {index} is out of range Length {Count}.");
                };
            }
        }

        public struct Enumerator : IEnumerator<TData>
        {
            private readonly FList<#ELEMENT_COUNT#><TData> _data;
            private int _current;

            public Enumerator(ref FList<#ELEMENT_COUNT#><TData> data)
            {
                _data = data;
                _current = -1;
            }

            public TData Current
            {
                [MethodImpl(MethodImplOptions.AggressiveInlining)]
                get => _data[_current];
            }

            object IEnumerator.Current
                => _data[_current];

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public bool MoveNext()
                => ++_current < _data.Count;

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public void Reset()
            {
                _current = -1;
            }

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public void Dispose() { }
        }
    }
<#END#>
}