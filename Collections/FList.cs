//GENERATOR = AnotherECS.Editor.Generator.FListGenerator FILENAME = FList.cs

// <auto-generated>
// This source code was auto-generated by FListGenerator.cs
// </auto-generated>

using AnotherECS.Serializer;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

namespace AnotherECS.Collections
{
    [Serializable] public struct Data2<T> : ISerialize where T : unmanaged 
    { 
        public T p0, p1;

        public unsafe void Pack(ref WriterContextSerializer writer) => FListHelper.Pack<T>(ref writer, GCHandle.Alloc(this, GCHandleType.Pinned), 2);
        public unsafe void Unpack(ref ReaderContextSerializer reader) => FListHelper.Unpack<T>(ref reader, GCHandle.Alloc(this, GCHandleType.Pinned), 2);
    }

    [Serializable]
    public struct FList2<TData> : IFList, IFList<TData>, IList<TData>, ISerialize
        where TData : unmanaged
    {
        public Data2<TData> _data;
        public int _count;

        public int Capacity
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => 2;
        }

        public int Count
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => _count;
        }

        public bool IsReadOnly => false;

        public void ExtendToCapacity()
        {
            _count = Capacity;
        }

        public void Add(TData value)
        {
#if !ANOTHERECS_RELEASE
            FListHelper.ThrowIfOutOfRange(_count, Capacity);
#endif
            this[_count++] = value;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void RemoveLast()
        {
            if (_count != 0)
            {
                this[--_count] = default;
            }
        }

        public void RemoveAt(int index)
        {
#if !ANOTHERECS_RELEASE
            FListHelper.ThrowIfOutOfRange(_count, Capacity);
#endif
            if (index == _count - 1)
            {
                RemoveLast();
            }
            else
            {
                for (int i = index; i < _count - 1; ++i)
                {
                    this[i] = this[i + 1];
                }
                this[_count - 1] = default;
                --_count;
            }
        }

        public void Clear()
        {
            _data = default;
        }

        public object Get(int index)
            => this[index];

        public void Set(int index, object @value)
        {
            this[index] = (TData)@value;
        }

        public void Add(object value)
        {
#if !ANOTHERECS_RELEASE
            FListHelper.ThrowIfOutOfRange(_count, Capacity);
#endif
            this[_count++] = (TData)value;
        }

        public IEnumerator<TData> GetEnumerator()
            => new Enumerator(ref this);

        IEnumerator IEnumerable.GetEnumerator()
            => GetEnumerator();

        public int IndexOf(TData item)
            => IndexOf(ref item, _count);

        public int IndexOf(ref TData item)
            => IndexOf(ref item, _count);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal int IndexOf(ref TData item, int count)
        {
            for (int i = 0; i < count; ++i)
            {
                if (EqualityComparer<TData>.Default.Equals(this[i], item))
                {
                    return i;
                }
            }
            return -1;
        }

        public bool Contains(TData item)
            => Contains(ref item);

        public bool Contains(ref TData item)
            => IndexOf(ref item) != -1;

        public void Insert(int index, TData item)
        {
            Insert(index, ref item);
        }

        public void Insert(int index, ref TData item)
        {
#if !ANOTHERECS_RELEASE
            FListHelper.ThrowIfOutOfRange(_count, Capacity);
#endif
            for (int i = _count; i < index; --i)
            {
                this[i] = this[i - 1];
            }
            this[index] = item;
            ++_count;
        }

        public bool Remove(TData item)
        {
            var index = IndexOf(ref item);
            if (index != -1)
            {
                RemoveAt(index);
                return true;
            }
            return false;
        }

        public void CopyTo(TData[] array, int arrayIndex)
        {
            CopyTo(array, arrayIndex, _count);
        }

        public void CopyTo(TData[] array, int arrayIndex, int count)
        {
#if !ANOTHERECS_RELEASE
            if (count > _count)
            {
                throw new ArgumentOutOfRangeException($"'{nameof(count)}':{count} must be less or equal than '{nameof(_count)}': {_count}");
            }
#endif
            if (array == null)
            {
                throw new NullReferenceException(nameof(array));
            }
            if (arrayIndex < 0)
            {
                throw new IndexOutOfRangeException(nameof(arrayIndex));
            }
            if (count <= 0)
            {
                throw new IndexOutOfRangeException(nameof(count));
            }
            if (array.Length - arrayIndex < count)
            {
                throw new ArgumentException($"There is not enough space in {nameof(array)} to copy.");
            }

            var iMax = Math.Min(array.Length - arrayIndex, count);
            for (int i = 0; i < iMax; ++i)
            {
                array[i + arrayIndex] = this[i];
            }
        }

        public void Pack(ref WriterContextSerializer writer)
        {
            writer.Write(_count);
            _data.Pack(ref writer);
        }

        public void Unpack(ref ReaderContextSerializer reader)
        {
            _count = reader.ReadInt32();
            _data.Unpack(ref reader);
        }

        public TData this[int index]
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
#if !ANOTHERECS_RELEASE
                FListHelper.ThrowIfOutOfRange(index, Count);
#endif
                return index switch
                {
                    0 => _data.p0,
                    1 => _data.p1,

                    _ => throw new IndexOutOfRangeException($"Index {index} is out of range Length {Count}."),
                };    
            }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set
            {
#if !ANOTHERECS_RELEASE
                FListHelper.ThrowIfOutOfRange(index, Count);
#endif
                switch(index)
                {
                    case 0: _data.p0 = value; break;
                    case 1: _data.p1 = value; break;

                    default: throw new IndexOutOfRangeException($"Index {index} is out of range Length {Count}.");
                };
            }
        }

        public struct Enumerator : IEnumerator<TData>
        {
            private readonly FList2<TData> _data;
            private int _current;

            public Enumerator(ref FList2<TData> data)
            {
                _data = data;
                _current = -1;
            }

            public TData Current
            {
                [MethodImpl(MethodImplOptions.AggressiveInlining)]
                get => _data[_current];
            }

            object IEnumerator.Current
                => _data[_current];

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public bool MoveNext()
                => ++_current < _data.Count;

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public void Reset()
            {
                _current = -1;
            }

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public void Dispose() { }
        }
    }
    [Serializable] public struct Data4<T> : ISerialize where T : unmanaged 
    { 
        public T p0, p1, p2, p3;

        public unsafe void Pack(ref WriterContextSerializer writer) => FListHelper.Pack<T>(ref writer, GCHandle.Alloc(this, GCHandleType.Pinned), 4);
        public unsafe void Unpack(ref ReaderContextSerializer reader) => FListHelper.Unpack<T>(ref reader, GCHandle.Alloc(this, GCHandleType.Pinned), 4);
    }

    [Serializable]
    public struct FList4<TData> : IFList, IFList<TData>, IList<TData>, ISerialize
        where TData : unmanaged
    {
        public Data4<TData> _data;
        public int _count;

        public int Capacity
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => 4;
        }

        public int Count
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => _count;
        }

        public bool IsReadOnly => false;

        public void ExtendToCapacity()
        {
            _count = Capacity;
        }

        public void Add(TData value)
        {
#if !ANOTHERECS_RELEASE
            FListHelper.ThrowIfOutOfRange(_count, Capacity);
#endif
            this[_count++] = value;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void RemoveLast()
        {
            if (_count != 0)
            {
                this[--_count] = default;
            }
        }

        public void RemoveAt(int index)
        {
#if !ANOTHERECS_RELEASE
            FListHelper.ThrowIfOutOfRange(_count, Capacity);
#endif
            if (index == _count - 1)
            {
                RemoveLast();
            }
            else
            {
                for (int i = index; i < _count - 1; ++i)
                {
                    this[i] = this[i + 1];
                }
                this[_count - 1] = default;
                --_count;
            }
        }

        public void Clear()
        {
            _data = default;
        }

        public object Get(int index)
            => this[index];

        public void Set(int index, object @value)
        {
            this[index] = (TData)@value;
        }

        public void Add(object value)
        {
#if !ANOTHERECS_RELEASE
            FListHelper.ThrowIfOutOfRange(_count, Capacity);
#endif
            this[_count++] = (TData)value;
        }

        public IEnumerator<TData> GetEnumerator()
            => new Enumerator(ref this);

        IEnumerator IEnumerable.GetEnumerator()
            => GetEnumerator();

        public int IndexOf(TData item)
            => IndexOf(ref item, _count);

        public int IndexOf(ref TData item)
            => IndexOf(ref item, _count);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal int IndexOf(ref TData item, int count)
        {
            for (int i = 0; i < count; ++i)
            {
                if (EqualityComparer<TData>.Default.Equals(this[i], item))
                {
                    return i;
                }
            }
            return -1;
        }

        public bool Contains(TData item)
            => Contains(ref item);

        public bool Contains(ref TData item)
            => IndexOf(ref item) != -1;

        public void Insert(int index, TData item)
        {
            Insert(index, ref item);
        }

        public void Insert(int index, ref TData item)
        {
#if !ANOTHERECS_RELEASE
            FListHelper.ThrowIfOutOfRange(_count, Capacity);
#endif
            for (int i = _count; i < index; --i)
            {
                this[i] = this[i - 1];
            }
            this[index] = item;
            ++_count;
        }

        public bool Remove(TData item)
        {
            var index = IndexOf(ref item);
            if (index != -1)
            {
                RemoveAt(index);
                return true;
            }
            return false;
        }

        public void CopyTo(TData[] array, int arrayIndex)
        {
            CopyTo(array, arrayIndex, _count);
        }

        public void CopyTo(TData[] array, int arrayIndex, int count)
        {
#if !ANOTHERECS_RELEASE
            if (count > _count)
            {
                throw new ArgumentOutOfRangeException($"'{nameof(count)}':{count} must be less or equal than '{nameof(_count)}': {_count}");
            }
#endif
            if (array == null)
            {
                throw new NullReferenceException(nameof(array));
            }
            if (arrayIndex < 0)
            {
                throw new IndexOutOfRangeException(nameof(arrayIndex));
            }
            if (count <= 0)
            {
                throw new IndexOutOfRangeException(nameof(count));
            }
            if (array.Length - arrayIndex < count)
            {
                throw new ArgumentException($"There is not enough space in {nameof(array)} to copy.");
            }

            var iMax = Math.Min(array.Length - arrayIndex, count);
            for (int i = 0; i < iMax; ++i)
            {
                array[i + arrayIndex] = this[i];
            }
        }

        public void Pack(ref WriterContextSerializer writer)
        {
            writer.Write(_count);
            _data.Pack(ref writer);
        }

        public void Unpack(ref ReaderContextSerializer reader)
        {
            _count = reader.ReadInt32();
            _data.Unpack(ref reader);
        }

        public TData this[int index]
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
#if !ANOTHERECS_RELEASE
                FListHelper.ThrowIfOutOfRange(index, Count);
#endif
                return index switch
                {
                    0 => _data.p0,
                    1 => _data.p1,
                    2 => _data.p2,
                    3 => _data.p3,

                    _ => throw new IndexOutOfRangeException($"Index {index} is out of range Length {Count}."),
                };    
            }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set
            {
#if !ANOTHERECS_RELEASE
                FListHelper.ThrowIfOutOfRange(index, Count);
#endif
                switch(index)
                {
                    case 0: _data.p0 = value; break;
                    case 1: _data.p1 = value; break;
                    case 2: _data.p2 = value; break;
                    case 3: _data.p3 = value; break;

                    default: throw new IndexOutOfRangeException($"Index {index} is out of range Length {Count}.");
                };
            }
        }

        public struct Enumerator : IEnumerator<TData>
        {
            private readonly FList4<TData> _data;
            private int _current;

            public Enumerator(ref FList4<TData> data)
            {
                _data = data;
                _current = -1;
            }

            public TData Current
            {
                [MethodImpl(MethodImplOptions.AggressiveInlining)]
                get => _data[_current];
            }

            object IEnumerator.Current
                => _data[_current];

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public bool MoveNext()
                => ++_current < _data.Count;

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public void Reset()
            {
                _current = -1;
            }

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public void Dispose() { }
        }
    }
    [Serializable] public struct Data8<T> : ISerialize where T : unmanaged 
    { 
        public T p0, p1, p2, p3, p4, p5, p6, p7;

        public unsafe void Pack(ref WriterContextSerializer writer) => FListHelper.Pack<T>(ref writer, GCHandle.Alloc(this, GCHandleType.Pinned), 8);
        public unsafe void Unpack(ref ReaderContextSerializer reader) => FListHelper.Unpack<T>(ref reader, GCHandle.Alloc(this, GCHandleType.Pinned), 8);
    }

    [Serializable]
    public struct FList8<TData> : IFList, IFList<TData>, IList<TData>, ISerialize
        where TData : unmanaged
    {
        public Data8<TData> _data;
        public int _count;

        public int Capacity
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => 8;
        }

        public int Count
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => _count;
        }

        public bool IsReadOnly => false;

        public void ExtendToCapacity()
        {
            _count = Capacity;
        }

        public void Add(TData value)
        {
#if !ANOTHERECS_RELEASE
            FListHelper.ThrowIfOutOfRange(_count, Capacity);
#endif
            this[_count++] = value;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void RemoveLast()
        {
            if (_count != 0)
            {
                this[--_count] = default;
            }
        }

        public void RemoveAt(int index)
        {
#if !ANOTHERECS_RELEASE
            FListHelper.ThrowIfOutOfRange(_count, Capacity);
#endif
            if (index == _count - 1)
            {
                RemoveLast();
            }
            else
            {
                for (int i = index; i < _count - 1; ++i)
                {
                    this[i] = this[i + 1];
                }
                this[_count - 1] = default;
                --_count;
            }
        }

        public void Clear()
        {
            _data = default;
        }

        public object Get(int index)
            => this[index];

        public void Set(int index, object @value)
        {
            this[index] = (TData)@value;
        }

        public void Add(object value)
        {
#if !ANOTHERECS_RELEASE
            FListHelper.ThrowIfOutOfRange(_count, Capacity);
#endif
            this[_count++] = (TData)value;
        }

        public IEnumerator<TData> GetEnumerator()
            => new Enumerator(ref this);

        IEnumerator IEnumerable.GetEnumerator()
            => GetEnumerator();

        public int IndexOf(TData item)
            => IndexOf(ref item, _count);

        public int IndexOf(ref TData item)
            => IndexOf(ref item, _count);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal int IndexOf(ref TData item, int count)
        {
            for (int i = 0; i < count; ++i)
            {
                if (EqualityComparer<TData>.Default.Equals(this[i], item))
                {
                    return i;
                }
            }
            return -1;
        }

        public bool Contains(TData item)
            => Contains(ref item);

        public bool Contains(ref TData item)
            => IndexOf(ref item) != -1;

        public void Insert(int index, TData item)
        {
            Insert(index, ref item);
        }

        public void Insert(int index, ref TData item)
        {
#if !ANOTHERECS_RELEASE
            FListHelper.ThrowIfOutOfRange(_count, Capacity);
#endif
            for (int i = _count; i < index; --i)
            {
                this[i] = this[i - 1];
            }
            this[index] = item;
            ++_count;
        }

        public bool Remove(TData item)
        {
            var index = IndexOf(ref item);
            if (index != -1)
            {
                RemoveAt(index);
                return true;
            }
            return false;
        }

        public void CopyTo(TData[] array, int arrayIndex)
        {
            CopyTo(array, arrayIndex, _count);
        }

        public void CopyTo(TData[] array, int arrayIndex, int count)
        {
#if !ANOTHERECS_RELEASE
            if (count > _count)
            {
                throw new ArgumentOutOfRangeException($"'{nameof(count)}':{count} must be less or equal than '{nameof(_count)}': {_count}");
            }
#endif
            if (array == null)
            {
                throw new NullReferenceException(nameof(array));
            }
            if (arrayIndex < 0)
            {
                throw new IndexOutOfRangeException(nameof(arrayIndex));
            }
            if (count <= 0)
            {
                throw new IndexOutOfRangeException(nameof(count));
            }
            if (array.Length - arrayIndex < count)
            {
                throw new ArgumentException($"There is not enough space in {nameof(array)} to copy.");
            }

            var iMax = Math.Min(array.Length - arrayIndex, count);
            for (int i = 0; i < iMax; ++i)
            {
                array[i + arrayIndex] = this[i];
            }
        }

        public void Pack(ref WriterContextSerializer writer)
        {
            writer.Write(_count);
            _data.Pack(ref writer);
        }

        public void Unpack(ref ReaderContextSerializer reader)
        {
            _count = reader.ReadInt32();
            _data.Unpack(ref reader);
        }

        public TData this[int index]
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
#if !ANOTHERECS_RELEASE
                FListHelper.ThrowIfOutOfRange(index, Count);
#endif
                return index switch
                {
                    0 => _data.p0,
                    1 => _data.p1,
                    2 => _data.p2,
                    3 => _data.p3,
                    4 => _data.p4,
                    5 => _data.p5,
                    6 => _data.p6,
                    7 => _data.p7,

                    _ => throw new IndexOutOfRangeException($"Index {index} is out of range Length {Count}."),
                };    
            }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set
            {
#if !ANOTHERECS_RELEASE
                FListHelper.ThrowIfOutOfRange(index, Count);
#endif
                switch(index)
                {
                    case 0: _data.p0 = value; break;
                    case 1: _data.p1 = value; break;
                    case 2: _data.p2 = value; break;
                    case 3: _data.p3 = value; break;
                    case 4: _data.p4 = value; break;
                    case 5: _data.p5 = value; break;
                    case 6: _data.p6 = value; break;
                    case 7: _data.p7 = value; break;

                    default: throw new IndexOutOfRangeException($"Index {index} is out of range Length {Count}.");
                };
            }
        }

        public struct Enumerator : IEnumerator<TData>
        {
            private readonly FList8<TData> _data;
            private int _current;

            public Enumerator(ref FList8<TData> data)
            {
                _data = data;
                _current = -1;
            }

            public TData Current
            {
                [MethodImpl(MethodImplOptions.AggressiveInlining)]
                get => _data[_current];
            }

            object IEnumerator.Current
                => _data[_current];

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public bool MoveNext()
                => ++_current < _data.Count;

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public void Reset()
            {
                _current = -1;
            }

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public void Dispose() { }
        }
    }
    [Serializable] public struct Data16<T> : ISerialize where T : unmanaged 
    { 
        public T p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15;

        public unsafe void Pack(ref WriterContextSerializer writer) => FListHelper.Pack<T>(ref writer, GCHandle.Alloc(this, GCHandleType.Pinned), 16);
        public unsafe void Unpack(ref ReaderContextSerializer reader) => FListHelper.Unpack<T>(ref reader, GCHandle.Alloc(this, GCHandleType.Pinned), 16);
    }

    [Serializable]
    public struct FList16<TData> : IFList, IFList<TData>, IList<TData>, ISerialize
        where TData : unmanaged
    {
        public Data16<TData> _data;
        public int _count;

        public int Capacity
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => 16;
        }

        public int Count
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => _count;
        }

        public bool IsReadOnly => false;

        public void ExtendToCapacity()
        {
            _count = Capacity;
        }

        public void Add(TData value)
        {
#if !ANOTHERECS_RELEASE
            FListHelper.ThrowIfOutOfRange(_count, Capacity);
#endif
            this[_count++] = value;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void RemoveLast()
        {
            if (_count != 0)
            {
                this[--_count] = default;
            }
        }

        public void RemoveAt(int index)
        {
#if !ANOTHERECS_RELEASE
            FListHelper.ThrowIfOutOfRange(_count, Capacity);
#endif
            if (index == _count - 1)
            {
                RemoveLast();
            }
            else
            {
                for (int i = index; i < _count - 1; ++i)
                {
                    this[i] = this[i + 1];
                }
                this[_count - 1] = default;
                --_count;
            }
        }

        public void Clear()
        {
            _data = default;
        }

        public object Get(int index)
            => this[index];

        public void Set(int index, object @value)
        {
            this[index] = (TData)@value;
        }

        public void Add(object value)
        {
#if !ANOTHERECS_RELEASE
            FListHelper.ThrowIfOutOfRange(_count, Capacity);
#endif
            this[_count++] = (TData)value;
        }

        public IEnumerator<TData> GetEnumerator()
            => new Enumerator(ref this);

        IEnumerator IEnumerable.GetEnumerator()
            => GetEnumerator();

        public int IndexOf(TData item)
            => IndexOf(ref item, _count);

        public int IndexOf(ref TData item)
            => IndexOf(ref item, _count);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal int IndexOf(ref TData item, int count)
        {
            for (int i = 0; i < count; ++i)
            {
                if (EqualityComparer<TData>.Default.Equals(this[i], item))
                {
                    return i;
                }
            }
            return -1;
        }

        public bool Contains(TData item)
            => Contains(ref item);

        public bool Contains(ref TData item)
            => IndexOf(ref item) != -1;

        public void Insert(int index, TData item)
        {
            Insert(index, ref item);
        }

        public void Insert(int index, ref TData item)
        {
#if !ANOTHERECS_RELEASE
            FListHelper.ThrowIfOutOfRange(_count, Capacity);
#endif
            for (int i = _count; i < index; --i)
            {
                this[i] = this[i - 1];
            }
            this[index] = item;
            ++_count;
        }

        public bool Remove(TData item)
        {
            var index = IndexOf(ref item);
            if (index != -1)
            {
                RemoveAt(index);
                return true;
            }
            return false;
        }

        public void CopyTo(TData[] array, int arrayIndex)
        {
            CopyTo(array, arrayIndex, _count);
        }

        public void CopyTo(TData[] array, int arrayIndex, int count)
        {
#if !ANOTHERECS_RELEASE
            if (count > _count)
            {
                throw new ArgumentOutOfRangeException($"'{nameof(count)}':{count} must be less or equal than '{nameof(_count)}': {_count}");
            }
#endif
            if (array == null)
            {
                throw new NullReferenceException(nameof(array));
            }
            if (arrayIndex < 0)
            {
                throw new IndexOutOfRangeException(nameof(arrayIndex));
            }
            if (count <= 0)
            {
                throw new IndexOutOfRangeException(nameof(count));
            }
            if (array.Length - arrayIndex < count)
            {
                throw new ArgumentException($"There is not enough space in {nameof(array)} to copy.");
            }

            var iMax = Math.Min(array.Length - arrayIndex, count);
            for (int i = 0; i < iMax; ++i)
            {
                array[i + arrayIndex] = this[i];
            }
        }

        public void Pack(ref WriterContextSerializer writer)
        {
            writer.Write(_count);
            _data.Pack(ref writer);
        }

        public void Unpack(ref ReaderContextSerializer reader)
        {
            _count = reader.ReadInt32();
            _data.Unpack(ref reader);
        }

        public TData this[int index]
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
#if !ANOTHERECS_RELEASE
                FListHelper.ThrowIfOutOfRange(index, Count);
#endif
                return index switch
                {
                    0 => _data.p0,
                    1 => _data.p1,
                    2 => _data.p2,
                    3 => _data.p3,
                    4 => _data.p4,
                    5 => _data.p5,
                    6 => _data.p6,
                    7 => _data.p7,
                    8 => _data.p8,
                    9 => _data.p9,
                    10 => _data.p10,
                    11 => _data.p11,
                    12 => _data.p12,
                    13 => _data.p13,
                    14 => _data.p14,
                    15 => _data.p15,

                    _ => throw new IndexOutOfRangeException($"Index {index} is out of range Length {Count}."),
                };    
            }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set
            {
#if !ANOTHERECS_RELEASE
                FListHelper.ThrowIfOutOfRange(index, Count);
#endif
                switch(index)
                {
                    case 0: _data.p0 = value; break;
                    case 1: _data.p1 = value; break;
                    case 2: _data.p2 = value; break;
                    case 3: _data.p3 = value; break;
                    case 4: _data.p4 = value; break;
                    case 5: _data.p5 = value; break;
                    case 6: _data.p6 = value; break;
                    case 7: _data.p7 = value; break;
                    case 8: _data.p8 = value; break;
                    case 9: _data.p9 = value; break;
                    case 10: _data.p10 = value; break;
                    case 11: _data.p11 = value; break;
                    case 12: _data.p12 = value; break;
                    case 13: _data.p13 = value; break;
                    case 14: _data.p14 = value; break;
                    case 15: _data.p15 = value; break;

                    default: throw new IndexOutOfRangeException($"Index {index} is out of range Length {Count}.");
                };
            }
        }

        public struct Enumerator : IEnumerator<TData>
        {
            private readonly FList16<TData> _data;
            private int _current;

            public Enumerator(ref FList16<TData> data)
            {
                _data = data;
                _current = -1;
            }

            public TData Current
            {
                [MethodImpl(MethodImplOptions.AggressiveInlining)]
                get => _data[_current];
            }

            object IEnumerator.Current
                => _data[_current];

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public bool MoveNext()
                => ++_current < _data.Count;

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public void Reset()
            {
                _current = -1;
            }

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public void Dispose() { }
        }
    }
    [Serializable] public struct Data32<T> : ISerialize where T : unmanaged 
    { 
        public T p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16, p17, p18, p19, p20, p21, p22, p23, p24, p25, p26, p27, p28, p29, p30, p31;

        public unsafe void Pack(ref WriterContextSerializer writer) => FListHelper.Pack<T>(ref writer, GCHandle.Alloc(this, GCHandleType.Pinned), 32);
        public unsafe void Unpack(ref ReaderContextSerializer reader) => FListHelper.Unpack<T>(ref reader, GCHandle.Alloc(this, GCHandleType.Pinned), 32);
    }

    [Serializable]
    public struct FList32<TData> : IFList, IFList<TData>, IList<TData>, ISerialize
        where TData : unmanaged
    {
        public Data32<TData> _data;
        public int _count;

        public int Capacity
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => 32;
        }

        public int Count
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => _count;
        }

        public bool IsReadOnly => false;

        public void ExtendToCapacity()
        {
            _count = Capacity;
        }

        public void Add(TData value)
        {
#if !ANOTHERECS_RELEASE
            FListHelper.ThrowIfOutOfRange(_count, Capacity);
#endif
            this[_count++] = value;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void RemoveLast()
        {
            if (_count != 0)
            {
                this[--_count] = default;
            }
        }

        public void RemoveAt(int index)
        {
#if !ANOTHERECS_RELEASE
            FListHelper.ThrowIfOutOfRange(_count, Capacity);
#endif
            if (index == _count - 1)
            {
                RemoveLast();
            }
            else
            {
                for (int i = index; i < _count - 1; ++i)
                {
                    this[i] = this[i + 1];
                }
                this[_count - 1] = default;
                --_count;
            }
        }

        public void Clear()
        {
            _data = default;
        }

        public object Get(int index)
            => this[index];

        public void Set(int index, object @value)
        {
            this[index] = (TData)@value;
        }

        public void Add(object value)
        {
#if !ANOTHERECS_RELEASE
            FListHelper.ThrowIfOutOfRange(_count, Capacity);
#endif
            this[_count++] = (TData)value;
        }

        public IEnumerator<TData> GetEnumerator()
            => new Enumerator(ref this);

        IEnumerator IEnumerable.GetEnumerator()
            => GetEnumerator();

        public int IndexOf(TData item)
            => IndexOf(ref item, _count);

        public int IndexOf(ref TData item)
            => IndexOf(ref item, _count);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal int IndexOf(ref TData item, int count)
        {
            for (int i = 0; i < count; ++i)
            {
                if (EqualityComparer<TData>.Default.Equals(this[i], item))
                {
                    return i;
                }
            }
            return -1;
        }

        public bool Contains(TData item)
            => Contains(ref item);

        public bool Contains(ref TData item)
            => IndexOf(ref item) != -1;

        public void Insert(int index, TData item)
        {
            Insert(index, ref item);
        }

        public void Insert(int index, ref TData item)
        {
#if !ANOTHERECS_RELEASE
            FListHelper.ThrowIfOutOfRange(_count, Capacity);
#endif
            for (int i = _count; i < index; --i)
            {
                this[i] = this[i - 1];
            }
            this[index] = item;
            ++_count;
        }

        public bool Remove(TData item)
        {
            var index = IndexOf(ref item);
            if (index != -1)
            {
                RemoveAt(index);
                return true;
            }
            return false;
        }

        public void CopyTo(TData[] array, int arrayIndex)
        {
            CopyTo(array, arrayIndex, _count);
        }

        public void CopyTo(TData[] array, int arrayIndex, int count)
        {
#if !ANOTHERECS_RELEASE
            if (count > _count)
            {
                throw new ArgumentOutOfRangeException($"'{nameof(count)}':{count} must be less or equal than '{nameof(_count)}': {_count}");
            }
#endif
            if (array == null)
            {
                throw new NullReferenceException(nameof(array));
            }
            if (arrayIndex < 0)
            {
                throw new IndexOutOfRangeException(nameof(arrayIndex));
            }
            if (count <= 0)
            {
                throw new IndexOutOfRangeException(nameof(count));
            }
            if (array.Length - arrayIndex < count)
            {
                throw new ArgumentException($"There is not enough space in {nameof(array)} to copy.");
            }

            var iMax = Math.Min(array.Length - arrayIndex, count);
            for (int i = 0; i < iMax; ++i)
            {
                array[i + arrayIndex] = this[i];
            }
        }

        public void Pack(ref WriterContextSerializer writer)
        {
            writer.Write(_count);
            _data.Pack(ref writer);
        }

        public void Unpack(ref ReaderContextSerializer reader)
        {
            _count = reader.ReadInt32();
            _data.Unpack(ref reader);
        }

        public TData this[int index]
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
#if !ANOTHERECS_RELEASE
                FListHelper.ThrowIfOutOfRange(index, Count);
#endif
                return index switch
                {
                    0 => _data.p0,
                    1 => _data.p1,
                    2 => _data.p2,
                    3 => _data.p3,
                    4 => _data.p4,
                    5 => _data.p5,
                    6 => _data.p6,
                    7 => _data.p7,
                    8 => _data.p8,
                    9 => _data.p9,
                    10 => _data.p10,
                    11 => _data.p11,
                    12 => _data.p12,
                    13 => _data.p13,
                    14 => _data.p14,
                    15 => _data.p15,
                    16 => _data.p16,
                    17 => _data.p17,
                    18 => _data.p18,
                    19 => _data.p19,
                    20 => _data.p20,
                    21 => _data.p21,
                    22 => _data.p22,
                    23 => _data.p23,
                    24 => _data.p24,
                    25 => _data.p25,
                    26 => _data.p26,
                    27 => _data.p27,
                    28 => _data.p28,
                    29 => _data.p29,
                    30 => _data.p30,
                    31 => _data.p31,

                    _ => throw new IndexOutOfRangeException($"Index {index} is out of range Length {Count}."),
                };    
            }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set
            {
#if !ANOTHERECS_RELEASE
                FListHelper.ThrowIfOutOfRange(index, Count);
#endif
                switch(index)
                {
                    case 0: _data.p0 = value; break;
                    case 1: _data.p1 = value; break;
                    case 2: _data.p2 = value; break;
                    case 3: _data.p3 = value; break;
                    case 4: _data.p4 = value; break;
                    case 5: _data.p5 = value; break;
                    case 6: _data.p6 = value; break;
                    case 7: _data.p7 = value; break;
                    case 8: _data.p8 = value; break;
                    case 9: _data.p9 = value; break;
                    case 10: _data.p10 = value; break;
                    case 11: _data.p11 = value; break;
                    case 12: _data.p12 = value; break;
                    case 13: _data.p13 = value; break;
                    case 14: _data.p14 = value; break;
                    case 15: _data.p15 = value; break;
                    case 16: _data.p16 = value; break;
                    case 17: _data.p17 = value; break;
                    case 18: _data.p18 = value; break;
                    case 19: _data.p19 = value; break;
                    case 20: _data.p20 = value; break;
                    case 21: _data.p21 = value; break;
                    case 22: _data.p22 = value; break;
                    case 23: _data.p23 = value; break;
                    case 24: _data.p24 = value; break;
                    case 25: _data.p25 = value; break;
                    case 26: _data.p26 = value; break;
                    case 27: _data.p27 = value; break;
                    case 28: _data.p28 = value; break;
                    case 29: _data.p29 = value; break;
                    case 30: _data.p30 = value; break;
                    case 31: _data.p31 = value; break;

                    default: throw new IndexOutOfRangeException($"Index {index} is out of range Length {Count}.");
                };
            }
        }

        public struct Enumerator : IEnumerator<TData>
        {
            private readonly FList32<TData> _data;
            private int _current;

            public Enumerator(ref FList32<TData> data)
            {
                _data = data;
                _current = -1;
            }

            public TData Current
            {
                [MethodImpl(MethodImplOptions.AggressiveInlining)]
                get => _data[_current];
            }

            object IEnumerator.Current
                => _data[_current];

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public bool MoveNext()
                => ++_current < _data.Count;

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public void Reset()
            {
                _current = -1;
            }

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public void Dispose() { }
        }
    }
    [Serializable] public struct Data64<T> : ISerialize where T : unmanaged 
    { 
        public T p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16, p17, p18, p19, p20, p21, p22, p23, p24, p25, p26, p27, p28, p29, p30, p31, p32, p33, p34, p35, p36, p37, p38, p39, p40, p41, p42, p43, p44, p45, p46, p47, p48, p49, p50, p51, p52, p53, p54, p55, p56, p57, p58, p59, p60, p61, p62, p63;

        public unsafe void Pack(ref WriterContextSerializer writer) => FListHelper.Pack<T>(ref writer, GCHandle.Alloc(this, GCHandleType.Pinned), 64);
        public unsafe void Unpack(ref ReaderContextSerializer reader) => FListHelper.Unpack<T>(ref reader, GCHandle.Alloc(this, GCHandleType.Pinned), 64);
    }

    [Serializable]
    public struct FList64<TData> : IFList, IFList<TData>, IList<TData>, ISerialize
        where TData : unmanaged
    {
        public Data64<TData> _data;
        public int _count;

        public int Capacity
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => 64;
        }

        public int Count
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => _count;
        }

        public bool IsReadOnly => false;

        public void ExtendToCapacity()
        {
            _count = Capacity;
        }

        public void Add(TData value)
        {
#if !ANOTHERECS_RELEASE
            FListHelper.ThrowIfOutOfRange(_count, Capacity);
#endif
            this[_count++] = value;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void RemoveLast()
        {
            if (_count != 0)
            {
                this[--_count] = default;
            }
        }

        public void RemoveAt(int index)
        {
#if !ANOTHERECS_RELEASE
            FListHelper.ThrowIfOutOfRange(_count, Capacity);
#endif
            if (index == _count - 1)
            {
                RemoveLast();
            }
            else
            {
                for (int i = index; i < _count - 1; ++i)
                {
                    this[i] = this[i + 1];
                }
                this[_count - 1] = default;
                --_count;
            }
        }

        public void Clear()
        {
            _data = default;
        }

        public object Get(int index)
            => this[index];

        public void Set(int index, object @value)
        {
            this[index] = (TData)@value;
        }

        public void Add(object value)
        {
#if !ANOTHERECS_RELEASE
            FListHelper.ThrowIfOutOfRange(_count, Capacity);
#endif
            this[_count++] = (TData)value;
        }

        public IEnumerator<TData> GetEnumerator()
            => new Enumerator(ref this);

        IEnumerator IEnumerable.GetEnumerator()
            => GetEnumerator();

        public int IndexOf(TData item)
            => IndexOf(ref item, _count);

        public int IndexOf(ref TData item)
            => IndexOf(ref item, _count);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal int IndexOf(ref TData item, int count)
        {
            for (int i = 0; i < count; ++i)
            {
                if (EqualityComparer<TData>.Default.Equals(this[i], item))
                {
                    return i;
                }
            }
            return -1;
        }

        public bool Contains(TData item)
            => Contains(ref item);

        public bool Contains(ref TData item)
            => IndexOf(ref item) != -1;

        public void Insert(int index, TData item)
        {
            Insert(index, ref item);
        }

        public void Insert(int index, ref TData item)
        {
#if !ANOTHERECS_RELEASE
            FListHelper.ThrowIfOutOfRange(_count, Capacity);
#endif
            for (int i = _count; i < index; --i)
            {
                this[i] = this[i - 1];
            }
            this[index] = item;
            ++_count;
        }

        public bool Remove(TData item)
        {
            var index = IndexOf(ref item);
            if (index != -1)
            {
                RemoveAt(index);
                return true;
            }
            return false;
        }

        public void CopyTo(TData[] array, int arrayIndex)
        {
            CopyTo(array, arrayIndex, _count);
        }

        public void CopyTo(TData[] array, int arrayIndex, int count)
        {
#if !ANOTHERECS_RELEASE
            if (count > _count)
            {
                throw new ArgumentOutOfRangeException($"'{nameof(count)}':{count} must be less or equal than '{nameof(_count)}': {_count}");
            }
#endif
            if (array == null)
            {
                throw new NullReferenceException(nameof(array));
            }
            if (arrayIndex < 0)
            {
                throw new IndexOutOfRangeException(nameof(arrayIndex));
            }
            if (count <= 0)
            {
                throw new IndexOutOfRangeException(nameof(count));
            }
            if (array.Length - arrayIndex < count)
            {
                throw new ArgumentException($"There is not enough space in {nameof(array)} to copy.");
            }

            var iMax = Math.Min(array.Length - arrayIndex, count);
            for (int i = 0; i < iMax; ++i)
            {
                array[i + arrayIndex] = this[i];
            }
        }

        public void Pack(ref WriterContextSerializer writer)
        {
            writer.Write(_count);
            _data.Pack(ref writer);
        }

        public void Unpack(ref ReaderContextSerializer reader)
        {
            _count = reader.ReadInt32();
            _data.Unpack(ref reader);
        }

        public TData this[int index]
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
#if !ANOTHERECS_RELEASE
                FListHelper.ThrowIfOutOfRange(index, Count);
#endif
                return index switch
                {
                    0 => _data.p0,
                    1 => _data.p1,
                    2 => _data.p2,
                    3 => _data.p3,
                    4 => _data.p4,
                    5 => _data.p5,
                    6 => _data.p6,
                    7 => _data.p7,
                    8 => _data.p8,
                    9 => _data.p9,
                    10 => _data.p10,
                    11 => _data.p11,
                    12 => _data.p12,
                    13 => _data.p13,
                    14 => _data.p14,
                    15 => _data.p15,
                    16 => _data.p16,
                    17 => _data.p17,
                    18 => _data.p18,
                    19 => _data.p19,
                    20 => _data.p20,
                    21 => _data.p21,
                    22 => _data.p22,
                    23 => _data.p23,
                    24 => _data.p24,
                    25 => _data.p25,
                    26 => _data.p26,
                    27 => _data.p27,
                    28 => _data.p28,
                    29 => _data.p29,
                    30 => _data.p30,
                    31 => _data.p31,
                    32 => _data.p32,
                    33 => _data.p33,
                    34 => _data.p34,
                    35 => _data.p35,
                    36 => _data.p36,
                    37 => _data.p37,
                    38 => _data.p38,
                    39 => _data.p39,
                    40 => _data.p40,
                    41 => _data.p41,
                    42 => _data.p42,
                    43 => _data.p43,
                    44 => _data.p44,
                    45 => _data.p45,
                    46 => _data.p46,
                    47 => _data.p47,
                    48 => _data.p48,
                    49 => _data.p49,
                    50 => _data.p50,
                    51 => _data.p51,
                    52 => _data.p52,
                    53 => _data.p53,
                    54 => _data.p54,
                    55 => _data.p55,
                    56 => _data.p56,
                    57 => _data.p57,
                    58 => _data.p58,
                    59 => _data.p59,
                    60 => _data.p60,
                    61 => _data.p61,
                    62 => _data.p62,
                    63 => _data.p63,

                    _ => throw new IndexOutOfRangeException($"Index {index} is out of range Length {Count}."),
                };    
            }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set
            {
#if !ANOTHERECS_RELEASE
                FListHelper.ThrowIfOutOfRange(index, Count);
#endif
                switch(index)
                {
                    case 0: _data.p0 = value; break;
                    case 1: _data.p1 = value; break;
                    case 2: _data.p2 = value; break;
                    case 3: _data.p3 = value; break;
                    case 4: _data.p4 = value; break;
                    case 5: _data.p5 = value; break;
                    case 6: _data.p6 = value; break;
                    case 7: _data.p7 = value; break;
                    case 8: _data.p8 = value; break;
                    case 9: _data.p9 = value; break;
                    case 10: _data.p10 = value; break;
                    case 11: _data.p11 = value; break;
                    case 12: _data.p12 = value; break;
                    case 13: _data.p13 = value; break;
                    case 14: _data.p14 = value; break;
                    case 15: _data.p15 = value; break;
                    case 16: _data.p16 = value; break;
                    case 17: _data.p17 = value; break;
                    case 18: _data.p18 = value; break;
                    case 19: _data.p19 = value; break;
                    case 20: _data.p20 = value; break;
                    case 21: _data.p21 = value; break;
                    case 22: _data.p22 = value; break;
                    case 23: _data.p23 = value; break;
                    case 24: _data.p24 = value; break;
                    case 25: _data.p25 = value; break;
                    case 26: _data.p26 = value; break;
                    case 27: _data.p27 = value; break;
                    case 28: _data.p28 = value; break;
                    case 29: _data.p29 = value; break;
                    case 30: _data.p30 = value; break;
                    case 31: _data.p31 = value; break;
                    case 32: _data.p32 = value; break;
                    case 33: _data.p33 = value; break;
                    case 34: _data.p34 = value; break;
                    case 35: _data.p35 = value; break;
                    case 36: _data.p36 = value; break;
                    case 37: _data.p37 = value; break;
                    case 38: _data.p38 = value; break;
                    case 39: _data.p39 = value; break;
                    case 40: _data.p40 = value; break;
                    case 41: _data.p41 = value; break;
                    case 42: _data.p42 = value; break;
                    case 43: _data.p43 = value; break;
                    case 44: _data.p44 = value; break;
                    case 45: _data.p45 = value; break;
                    case 46: _data.p46 = value; break;
                    case 47: _data.p47 = value; break;
                    case 48: _data.p48 = value; break;
                    case 49: _data.p49 = value; break;
                    case 50: _data.p50 = value; break;
                    case 51: _data.p51 = value; break;
                    case 52: _data.p52 = value; break;
                    case 53: _data.p53 = value; break;
                    case 54: _data.p54 = value; break;
                    case 55: _data.p55 = value; break;
                    case 56: _data.p56 = value; break;
                    case 57: _data.p57 = value; break;
                    case 58: _data.p58 = value; break;
                    case 59: _data.p59 = value; break;
                    case 60: _data.p60 = value; break;
                    case 61: _data.p61 = value; break;
                    case 62: _data.p62 = value; break;
                    case 63: _data.p63 = value; break;

                    default: throw new IndexOutOfRangeException($"Index {index} is out of range Length {Count}.");
                };
            }
        }

        public struct Enumerator : IEnumerator<TData>
        {
            private readonly FList64<TData> _data;
            private int _current;

            public Enumerator(ref FList64<TData> data)
            {
                _data = data;
                _current = -1;
            }

            public TData Current
            {
                [MethodImpl(MethodImplOptions.AggressiveInlining)]
                get => _data[_current];
            }

            object IEnumerator.Current
                => _data[_current];

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public bool MoveNext()
                => ++_current < _data.Count;

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public void Reset()
            {
                _current = -1;
            }

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public void Dispose() { }
        }
    }

}