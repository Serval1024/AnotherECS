// <auto-generated>
// This source code was auto-generated by StateGenerator.cs
// </auto-generated>

using System;
using System.Runtime.CompilerServices;
using AnotherECS.Converter;
using AnotherECS.Core;
using AnotherECS.Serializer;
using AnotherECS.Gen.Common;
#if !ANOTHERECS_DEBUG
using Unity.Collections.LowLevel.Unsafe;
#endif
using ReflectionUtils = AnotherECS.Core.ReflectionUtils;

namespace AnotherECS.Gen.States
{
    public sealed class <#STATE_NAME_GEN#> : <#STATE_NAME#>
    {
<#ARRAY [1..COMPONENT_COUNT+1]#>
---<#IF DIRECTACCESS#>
        private Adapter<#ADAPTER_TYPE#><<#COMPONENT_FULL_NAME#>> _<#COMPONENT_NAME_LOW#>Adapter;
        public ref Adapter<#ADAPTER_TYPE#><<#COMPONENT_FULL_NAME#>> <#COMPONENT_NAME#> { [MethodImpl(MethodImplOptions.AggressiveInlining)] get => ref _<#COMPONENT_NAME_LOW#>Adapter; }
---<#END#>
<#END#>
        private PutFuctions<<#STATE_NAME_GEN#>> _putFunctions;

        public MyStateData()
            : base() { }

        internal MyStateData(ref ReaderContextSerializer reader)
            => Unpack(ref reader);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        protected override ushort GetIndex<T>()
            => CompileComponentIdProvider<<#STATE_NAME_GEN#>, T>.ID;
        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        protected override Mask GetMask(Type type)
           => FilterGlobalRegister<<#STATE_NAME_GEN#>>.GetMask(type);

        protected override void CodeGenerationStage(in GeneralConfig general, TickProvider tickProvider)
        {
            GlobalInstaller.Install<<#STATE_NAME_GEN#>>();

            var entityCapacity = general.entityCapacity;
            var componentCapacity = general.componentCapacity;
            var historyByChangeArgs = new HistoryByChangeArgs(general.history, CGGetTickProvider());
            var historyByTickArgs = new HistoryByTickArgs(general.history, CGGetTickProvider());

<#ARRAY [1..COMPONENT_COUNT+1]#>
---<#IF DIRECTACCESS#>
            var <#COMPONENT_NAME_LOW#> = new Storage<#STORAGE_TYPE#><<#COMPONENT_FULL_NAME#>>(<#INDEX#><#IF !SHARED#>, entityCapacity, <#STORAGE_CAPACITY#><#END#><#COMPONENT_HISTORY_DECLARE#><#COMPONENT_VERISON_DECLARE#><#COMPONENT_INJECT_DECLARE#>);
            _<#COMPONENT_NAME_LOW#>Adapter = new Adapter<#ADAPTER_TYPE#><<#COMPONENT_FULL_NAME#>>(ref <#COMPONENT_NAME_LOW#>);
---<#END#>
<#END#>
            _putFunctions = new(<#COMPONENT_DIRECTACCESS_COUNT#> + 1);
<#ARRAY [1..COMPONENT_COUNT+1]#>
<#IF DIRECTACCESS#>            _putFunctions.Set(<#INDEX#>, Assigns.Index<#INDEX#>);<#END#>
<#END#>
        }

        protected override void CodeGenerationStageNonSync(in GeneralConfig general, TickProvider tickProvider, IAdapterReference[] adapters)
        {
            var entityCapacity = general.entityCapacity;
            var componentCapacity = general.componentCapacity;
            var historyByChangeArgs = new HistoryByChangeArgs(general.history, CGGetTickProvider());
            var historyByTickArgs = new HistoryByTickArgs(general.history, CGGetTickProvider());

<#ARRAY [1..COMPONENT_COUNT+1]#>
---<#IF !DIRECTACCESS#>
            var <#COMPONENT_NAME_LOW#> = new Storage<#STORAGE_TYPE#><<#COMPONENT_FULL_NAME#>>(<#INDEX#><#IF !SHARED#>, entityCapacity, <#STORAGE_CAPACITY#><#END#><#COMPONENT_HISTORY_DECLARE#><#COMPONENT_VERISON_DECLARE#><#COMPONENT_INJECT_DECLARE#>);
            adapters[<#INDEX#>] = new Adapter<#ADAPTER_TYPE#><<#COMPONENT_FULL_NAME#>>(ref <#COMPONENT_NAME_LOW#>);
---<#END#>
<#END#>
        }

        protected override int GetComponentCount()
            => <#COMPONENT_COUNT#> + 1;

        protected override void GetAdapters(IAdapterReference[] adapters)
        {
<#ARRAY [1..COMPONENT_COUNT+1]#>
<#IF DIRECTACCESS#>            adapters[<#INDEX#>] = _<#COMPONENT_NAME_LOW#>Adapter;<#END#>
<#END#>
        }

        protected override void PutAdapters(IAdapterReference[] adapters)
        {
<#ARRAY [1..COMPONENT_COUNT+1]#>
<#IF DIRECTACCESS#>            _<#COMPONENT_NAME_LOW#>Adapter = (Adapter<#ADAPTER_TYPE#><<#COMPONENT_FULL_NAME#>>)adapters[<#INDEX#>];<#END#>
<#END#>
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        protected override void PutAdapter(IAdapterReference adapter, int index)
            => _putFunctions.Invoke(index, this, adapter);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        protected override IInjectMethodsReference[] GetInjects()
            => Inject.methods;

        protected override void OnTickFinished()
        {
<#ARRAY [0..COMPONENT_BY_TICK_COUNT]#>
            _<#COMPONENT_BY_TICK_NAME_LOW#>Adapter.TickFinished();
<#END#>
        }

        private static class Assigns
        {
<#ARRAY [1..COMPONENT_COUNT+1]#>
<#IF DIRECTACCESS#>            [MethodImpl(MethodImplOptions.AggressiveInlining)] public static void Index<#INDEX#>(<#STATE_NAME_GEN#> state, IAdapterReference adapter) => state._<#COMPONENT_NAME_LOW#>Adapter = (Adapter<#ADAPTER_TYPE#><<#COMPONENT_FULL_NAME#>>)adapter;<#END#>
<#END#>
        }
    
        private static class GlobalInstaller
        {
            private static bool _isNoInstalled = true;

            public static void Install<EState>()
                where EState : IState
            {
                if (_isNoInstalled)
                {
                    _isNoInstalled = false;
                    SystemGlobalInstaller.Install();
                    InstallInternal<EState>();
                }
            }

            private static void InstallInternal<EState>()
                where EState : IState
            {
<#ARRAY [1..FILTER_COUNT+1]#>
                FilterGlobalRegister<<#STATE_NAME_GEN#>>.Install<<#FILTER_NAME#>>(Filter.IsMaskCompatible_<#FILTER_NAME_FUCTION#>, <#FILTER_ISAUTOCLEAR#>, <#FILTER_INCLUDES#>, <#FILTER_EXCLUDES#>);
<#END#>
<#ARRAY [1..COMPONENT_COUNT+1]#>
                ComponentGlobalRegister<<#STATE_NAME_GEN#>>.Install<<#COMPONENT_FULL_NAME#>>();
<#END#>
            }
        }

        private static class Filter
        {
<#ARRAY [1..FILTER_COUNT+1]#>
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public static bool IsMaskCompatible_<#FILTER_NAME_FUCTION#>(State state, EntityId id)
            {
#if ANOTHERECS_DEBUG
                var s = (<#STATE_NAME_GEN#>)state;
#else
                ref var s = ref UnsafeUtility.As<State, <#STATE_NAME_GEN#>>(ref state);
#endif
                return (<#FILTER_RULE#>);
            }
<#END#>
        }

        private static class Inject
        {
            public static IInjectMethodsReference[] methods =
                new IInjectMethodsReference[]
                {
<#ARRAY [0..COMPONENT_INJECT_COUNT]#>
                    new InjectMethods<<#COMPONENT_INJECT_FULL_NAME#>>(<#INDEX#>, Inject.Construct_<#COMPONENT_INJECT_NAME#>, Inject.Deconstruct_<#COMPONENT_INJECT_NAME#>),
<#END#>
                };

<#ARRAY [0..COMPONENT_INJECT_COUNT]#>
            public static void Construct_<#COMPONENT_INJECT_NAME#>(ref <#COMPONENT_INJECT_FULL_NAME#> component, ref InjectContainer injectContainer)
            {
#if ANOTHERECS_DEBUG
                ReflectionUtils.ReflectionInjectConstruct(ref component, ref injectContainer);
#else
---<#IF INJECT_SELF#>
                component.Construct(<#INJECT_SELF_ARGS#>);
---<#END#>
---<#ARRAY [0..INJECT_FIELD_COUNT]#>
                component.<#INJECT_FIELD_NAME#>.Construct(<#INJECT_ARGS#>);
---<#END#>
#endif
            }

            public static void Deconstruct_<#COMPONENT_INJECT_NAME#>(ref <#COMPONENT_INJECT_FULL_NAME#> component, ref InjectContainer injectContainer)
            {
#if ANOTHERECS_DEBUG
                ReflectionUtils.ReflectionInjectDeconstruct(ref component, ref injectContainer);
#else
---<#IF INJECT_SELF#>
                component.Deconstruct();
---<#END#>
---<#ARRAY [0..INJECT_FIELD_COUNT]#>
                component.<#INJECT_FIELD_NAME#>.Deconstruct();
---<#END#>
#endif
            }
<#END#>
        }

<#EMBEDCODE SystemGenerator#>
    }
}