// <auto-generated>
// This source code was auto-generated by HistoryGenerator.cs
// </auto-generated>

using AnotherECS.Core;
using AnotherECS.Serializer;
using System.Runtime.CompilerServices;
#if !ANOTHERECS_DEBUG
using Unity.Collections.LowLevel.Unsafe;
#endif

namespace AnotherECS.Gen.Common
{
#if ENABLE_IL2CPP
    [Unity.IL2CPP.CompilerServices.Il2CppSetOption (Option.NullChecks, false)]
    [Unity.IL2CPP.CompilerServices.Il2CppSetOption (Option.ArrayBoundsChecks, false)]
#endif
    public class Storage<#HISTORY_TYPE#>History<T> : History<#IF COPYABLE#>, IRecycleInternal<#END#>, ISerialize<#IF ATTACH || DETACH#>, IStateBindExternalInternal<#END#>
        where T : <#IF BLITTABLE#>unmanaged<#ELSE#>struct<#END#>, IComponent<#GENERIC_CONSTRAINTS#>
    {
        private int _sparseIndex = 0;
        private SparseData<<#SPARSE:TYPE_NAME#>>[] _sparseBuffer;

<#IF !EMPTY#>
        private int _recycledCountIndex = 0;
        private TickData<ushort>[] _recycledCountBuffer;

        private int _denseCountIndex = 0;
        private TickData<<#STORAGE:INDEX_DATA:TYPE_NAME#>>[] _denseCountBuffer;


        private int _recycledIndex = 0;
        private RecycledData<ushort>[] _recycledBuffer;
---<#IF HISTORY:BYCHANGE#>
        private int _componentIndex = 0;
        private ComponentData[] _componentBuffer;
---<#END#>
---<#IF HISTORY:BYTICK#>
        private int _componentsIndex = 0;
        private ComponentsData[] _componentsBuffer;
        private ArrayOptionalPool<T> _arrayPool;
        private int _byTickArrayExtraSize;
---<#END#>
<#END#>
        
<#IF ATTACH || DETACH#>
        private State _state;
        private Op[] _bufferOps = System.Array.Empty<Op>();
        private <#SPARSE:TYPE_NAME#>[] _sparseCopy = System.Array.Empty<<#SPARSE:TYPE_NAME#>>();
<#END#>

        internal Storage<#HISTORY_TYPE#>History(ref ReaderContextSerializer reader, HistoryArgs args)
             : base(ref reader, args.tickProvider)
        { }

<#IF HISTORY:BYTICK#>
        public Storage<#HISTORY_TYPE#>History(in HistoryByTickArgs args, uint componentCapacity)
<#ELSE#>
        public Storage<#HISTORY_TYPE#>History(in HistoryByChangeArgs args)
<#END#>
            : base(new HistoryArgs(args))
        {
            _sparseBuffer = new SparseData<<#SPARSE:TYPE_NAME#>>[args.buffersAddRemoveCapacity];
<#IF !EMPTY#>
            _recycledCountBuffer = new TickData<ushort>[args.buffersAddRemoveCapacity];
            _denseCountBuffer = new TickData<<#STORAGE:INDEX_DATA:TYPE_NAME#>>[args.buffersAddRemoveCapacity];
            _recycledBuffer = new RecycledData<ushort>[args.buffersAddRemoveCapacity];
---<#IF HISTORY:BYCHANGE#>
            _componentBuffer = new ComponentData[args.buffersChangeCapacity];
---<#END#>
---<#IF HISTORY:BYTICK#>
            _componentsBuffer = new ComponentsData[args.buffersFullCopyCapacity];
            _arrayPool = new ArrayOptionalPool<T>((int)componentCapacity);
            _byTickArrayExtraSize = (int)args.byTickArrayExtraSize;
---<#END#>
<#END#>
        }

<#IF ATTACH || DETACH#>
        public void BindExternal(State state)
        {
            _state = state;
        }
<#END#>

        public void RevertTo(uint tick, ref Storage<#STORAGE_TYPE#><T> subject)
        {
            RevertToSparseBuffer(tick, ref subject);
<#IF !EMPTY#>
            RevertToRecycledCountBuffer(tick, ref subject);
            RevertToDenseCountBuffer(tick, ref subject);
            RevertToRecycledBuffer(tick, ref subject);
<#END#>
<#IF DETACH#>
            DetachComponentRevert(ref subject);
<#END#>
<#IF !EMPTY#>
            RevertToComponentBuffer(tick, ref subject);
<#END#>
<#IF ATTACH#>
            AttachComponentReverted(ref subject);
<#END#>
        }
<#IF DISPOSE#>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Dispose()
        {
            for (int i = 0; i < _componentBuffer.Length; ++i)
            {
                if (_componentBuffer[i].tick != 0)
                {
                    _componentBuffer[i].component.Dispose();
                }
            }
        }
<#END#>

<#IF COPYABLE#>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Recycle()
        {
---<#IF HISTORY:BYCHANGE#>
            for (int i = 0; i < _componentBuffer.Length; ++i)
            {
                if (_componentBuffer[i].tick != 0)
                {
                    _componentBuffer[i].component.OnRecycle();
                }
            }
---<#ELSE#>
            for (int i = 0; i < _componentsBuffer.Length; ++i)
            {
                if (_componentsBuffer[i].tick != 0)
                {
                    _componentsBuffer[i].OnRecycle();
                }
            }
---<#END#>
        }
<#END#>


        #region Push methods
<#IF !EMPTY#>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void PushRecycledCount(ushort recycledCount)
        {
            ref var element = ref _recycledCountBuffer[_recycledCountIndex++];
            element.tick = Tick;
            element.value = recycledCount;

            HistoryUtils.CheckAndResizeLoopBuffer(ref _recycledCountIndex, ref _recycledCountBuffer, _recordHistoryLength, nameof(_recycledCountBuffer));
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void PushCount(<#STORAGE:INDEX_DATA:TYPE_NAME#> denseCount)
        {
            ref var element = ref _denseCountBuffer[_denseCountIndex++];
            element.tick = Tick;
            element.value = denseCount;

            HistoryUtils.CheckAndResizeLoopBuffer(ref _denseCountIndex, ref _denseCountBuffer, _recordHistoryLength, nameof(_denseCountBuffer));
        }
<#END#>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void PushSparse(<#SPARSE:TYPE_NAME#> sparseValue, uint sparseIndex)
        {
            ref var element = ref _sparseBuffer[_sparseIndex++];
            element.tick = Tick;
            element.sparseValue = sparseValue;
            element.sparseIndex = sparseIndex;

            HistoryUtils.CheckAndResizeLoopBuffer(ref _sparseIndex, ref _sparseBuffer, _recordHistoryLength, nameof(_sparseBuffer));
        }
<#IF !EMPTY#>
---<#IF HISTORY:BYCHANGE#>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void PushRemove(ref T component, <#STORAGE:INDEX_DATA:TYPE_NAME#> denseIndex, uint sparseIndex, ushort recycled, ushort recycledCount)
        {
            PushRecycledCount(recycledCount);
            PushDense(ref component, denseIndex);
------<#IF SPARSE:BOOL#>
            PushSparse(true, sparseIndex);
------<#ELSE#>
            PushSparse(denseIndex, sparseIndex);
------<#END#>
            ref var element = ref _recycledBuffer[_recycledIndex++];
            element.tick = Tick;
            element.recycled = recycled;
            element.recycledIndex = recycledCount;

            HistoryUtils.CheckAndResizeLoopBuffer(ref _recycledIndex, ref _recycledBuffer, _recordHistoryLength, nameof(_recycledBuffer));
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void PushDense(ref T component, <#STORAGE:INDEX_DATA:TYPE_NAME#> denseIndex)
        {
            ref var element = ref _componentBuffer[_componentIndex];
------<#IF COPYABLE#>
            if (element.tick != 0)
            {
                element.OnRecycle();
            }
------<#END#>
            element.tick = Tick;
            element.component = component;
            element.denseIndex = denseIndex;

            ++_componentIndex;

            HistoryUtils.CheckAndResizeLoopBuffer(ref _componentIndex, ref _componentBuffer, _recordHistoryLength, nameof(_componentBuffer));
        }
---<#END#>
---<#IF HISTORY:BYTICK#>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void PushRemove(<#STORAGE:INDEX_DATA:TYPE_NAME#> denseIndex, uint sparseIndex, ushort recycled, ushort recycledCount)
        {
            PushRecycledCount(recycledCount);
------<#IF SPARSE:BOOL#>
            PushSparse(true, sparseIndex);
------<#ELSE#>
            PushSparse(denseIndex, sparseIndex);
------<#END#>

            ref var element = ref _recycledBuffer[_recycledIndex++];
            element.tick = Tick;
            element.recycled = recycled;
            element.recycledIndex = recycledCount;

            HistoryUtils.CheckAndResizeLoopBuffer(ref _recycledIndex, ref _recycledBuffer, _recordHistoryLength, nameof(_recycledBuffer));
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void PushChange(T[] components, int length)
        {
            if (length > _arrayPool.Size)
            {
                _arrayPool.Resize(length + _byTickArrayExtraSize);
            }

            ref var element = ref _componentsBuffer[_componentsIndex++];
            if (element.tick != 0)
            {
------<#IF COPYABLE#>
                element.OnRecycle();
------<#END#>            
                _arrayPool.Return(element.components);
            }
            element = new ComponentsData(Tick, components, length, ref _arrayPool);

            HistoryUtils.CheckAndResizeLoopBuffer(ref _componentsIndex, ref _componentsBuffer, _recordHistoryLength, nameof(_componentsBuffer));
        }
---<#END#>
<#END#>
        #endregion
        #region Revert methods

<#IF DETACH#>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private void DetachComponentRevert(ref Storage<#STORAGE_TYPE#><T> subject)
        {
            var sparse = _sparseCopy;
            var dense = subject.GetDenseRaw();

            for (int i = 0, iMax = sparse.Length; i < iMax; ++i)
            {
                if ((_bufferOps[i] & Op.REMOVE) != 0)
                {
---<#IF !EMPTY#>
                    dense[sparse[i]].OnDetach(_state);
---<#ELSE#>
                    default(T).OnDetach(_state);
---<#END#>
                }
            }
        }
<#END#>
<#IF ATTACH#>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private void AttachComponentReverted(ref Storage<#STORAGE_TYPE#><T> subject)
        {
            var sparse = subject.GetSparseRaw();
            var dense = subject.GetDenseRaw();

            for (int i = 0, iMax = sparse.Length; i < iMax; ++i)
            {
                if ((_bufferOps[i] & Op.ADD) != 0)
                {
---<#IF !EMPTY#>
                    dense[sparse[i]].OnAttach(_state);
---<#ELSE#>
                    default(T).OnAttach(_state);
---<#END#>
                }
            }
        }
<#END#>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private void RevertToSparseBuffer(uint tick, ref Storage<#STORAGE_TYPE#><T> subject)
        {
<#IF ATTACH || DETACH#>
            RevertHelper.RevertToSparseBuffer(ref subject, tick, _sparseBuffer, ref _sparseIndex, ref _sparseCopy, ref _bufferOps);
<#ELSE#>
            RevertHelper.RevertToSparseBuffer(ref subject, tick, _sparseBuffer, ref _sparseIndex);
<#END#>
        }
<#IF !EMPTY#>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private void RevertToRecycledCountBuffer(uint tick, ref Storage<#STORAGE_TYPE#><T> subject)
        {
            RevertHelper.RevertToRecycledCountBuffer(ref subject, tick, _recycledCountBuffer, ref _recycledCountIndex);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private void RevertToDenseCountBuffer(uint tick, ref Storage<#STORAGE_TYPE#><T> subject)
        {
            RevertHelper.RevertToCountBuffer(ref subject, tick, _denseCountBuffer, ref _denseCountIndex);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private void RevertToRecycledBuffer(uint tick, ref Storage<#STORAGE_TYPE#><T> subject)
        {
            RevertHelper.RevertToRecycledBuffer(ref subject, tick, _recycledBuffer, ref _recycledIndex);
        }
---<#IF HISTORY:BYCHANGE#>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private void RevertToComponentBuffer(uint tick, ref Storage<#STORAGE_TYPE#><T> subject)
        {
            var dense = subject.GetDenseRaw();

            for (int i = _componentIndex - 1; i >= 0; --i)
            {
                var frame = _componentBuffer[i];

                if (frame.tick > tick)
                {
                    dense[frame.denseIndex] = frame.component;
                }
                else
                {
                    _componentIndex = i + 1;
                    return;
                }
            }

            
            for (int i = _componentBuffer.Length - 1; i >= _componentIndex; --i)
            {
                var frame = _componentBuffer[i];

                if (frame.tick > tick)
                {
                    dense[frame.denseIndex] = frame.component;
                }
                else
                {
                    _componentIndex = (i + 1) % _componentBuffer.Length;
                    return;
                }
            }
            
        }
---<#END#>
---<#IF HISTORY:BYTICK#>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        protected void RevertToComponentBuffer(uint tick, ref Storage<#STORAGE_TYPE#><T> subject)
        {
            for (int i = _componentsIndex - 1; i >= 0; --i)
            {
                var frame = _componentsBuffer[i];

                if (frame.tick == tick)
                {
                    _componentsIndex = i;
                    subject.SetDenseRaw(_componentsBuffer[i].components);
                    return;
                }
            }

            
            for (int i = _componentsBuffer.Length - 1; i >= _componentsIndex; --i)
            {
                var frame = _componentsBuffer[i];

                if (frame.tick == tick)
                {
                    _componentsIndex = i;
                    subject.SetDenseRaw(_componentsBuffer[i].components);
                    return;
                }
            }
        }
---<#END#>
<#END#>
        #endregion
        
<#IF INJECT#>
---<#IF HISTORY:BYCHANGE#>
        public unsafe void ReInject(ref InjectContainer injectContainer, delegate*<ref T, ref InjectContainer, void> construct)
        {
            for (int i = 0, iMax = _componentBuffer.Length; i < iMax; ++i)
            {
                ref var element = ref _componentBuffer[i];
                if (element.tick != 0)
                {
                    construct(ref element.component, ref injectContainer);
                }
            }
        }
---<#END#>
---<#IF HISTORY:BYTICK#>
        public unsafe void ReInject(ref InjectContainer injectContainer, delegate*<ref T, ref InjectContainer, void> construct)
        {
            for (int i = 0, iMax = _componentsBuffer.Length; i < iMax; ++i)
            {
                ref var element = ref _componentsBuffer[i];
                if (element.tick != 0)
                {
                    element.ReInject(ref injectContainer, ref injectMethod);
                }
            }
        }
---<#END#>
<#END#>
        public override void Pack(ref WriterContextSerializer writer)
        {
            base.Pack(ref writer);

            writer.Write(_sparseIndex);
            writer.WriteUnmanagedArray(_sparseBuffer);
<#IF !EMPTY#>
            writer.Write(_recycledCountIndex);
            writer.WriteUnmanagedArray(_recycledCountBuffer);

            writer.Write(_denseCountIndex);
            writer.WriteUnmanagedArray(_denseCountBuffer);

            writer.Write(_recycledIndex);
            writer.WriteUnmanagedArray(_recycledBuffer);
---<#IF HISTORY:BYCHANGE#>
            writer.Write(_componentIndex);
------<#IF BLITTABLE#>
            writer.WriteUnmanagedArray<ComponentData>(_componentBuffer, _componentIndex);
------<#ELSE#>
            writer.Pack(_componentBuffer);
------<#END#>
---<#END#>
---<#IF HISTORY:BYTICK#>
            writer.Write(_componentsIndex);
            writer.Pack(_componentsBuffer);
            writer.Write(_byTickArrayExtraSize);
            writer.Write(_arrayPool.Size);
---<#END#>
<#END#>
        }

        public override void Unpack(ref ReaderContextSerializer reader)
        {
            base.Unpack(ref reader);

            _sparseIndex = reader.ReadInt32();
            _sparseBuffer = reader.ReadUnmanagedArray<SparseData<<#SPARSE:TYPE_NAME#>>>();
<#IF !EMPTY#>
            _recycledCountIndex = reader.ReadInt32();
            _recycledCountBuffer = reader.ReadUnmanagedArray<TickData<ushort>>();

            _denseCountIndex = reader.ReadInt32();
            _denseCountBuffer = reader.ReadUnmanagedArray<TickData<<#STORAGE:INDEX_DATA:TYPE_NAME#>>>();

            _recycledIndex = reader.ReadInt32();
            _recycledBuffer = reader.ReadUnmanagedArray<RecycledData<ushort>>();
---<#IF HISTORY:BYCHANGE#>
            _componentIndex = reader.ReadInt32();
            _componentBuffer = reader.Unpack<ComponentData[]>();
---<#END#>

---<#IF HISTORY:BYTICK#>
            _componentsIndex = reader.ReadInt32();
            _componentsBuffer = reader.Unpack<ComponentsData[]>();

            _byTickArrayExtraSize = reader.ReadInt32();
            var componentCapacity = reader.ReadInt32();
            _arrayPool = new ArrayOptionalPool<T>(componentCapacity);
---<#END#>
<#END#>
        }

        #region Data declarations

<#IF !EMPTY#>
---<#IF HISTORY:BYCHANGE#>
        private struct ComponentData : IFrameData, ISerialize
        {
            public uint Tick
                => tick;

            public uint tick;
            public T component;
            public <#STORAGE:INDEX_DATA:TYPE_NAME#> denseIndex;

------<#IF COPYABLE#>
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public void OnRecycle()
            {
                component.OnRecycle();
            }
------<#END#>

            public void Pack(ref WriterContextSerializer writer)
            {
                writer.Write(tick);
                writer.WriteStruct(component);
                writer.Write(denseIndex);
            }

            public void Unpack(ref ReaderContextSerializer reader)
            {
                tick = reader.ReadUInt32();
                component = reader.ReadStruct<T>();
                denseIndex = reader.Read<#STORAGE:INDEX_DATA:TYPE_UNPACK_NAME#>();
            }
        }
---<#END#>
---<#IF HISTORY:BYTICK#>
        private struct ComponentsData : IFrameData, ISerialize
        {
            public uint Tick
                => tick;

            public uint tick;
            public T[] components;

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public ComponentsData(uint tick, T[] components, int length, ref ArrayOptionalPool<T> arrayPool)
            {
                var newComponents = arrayPool.Rent();
------<#IF COPYABLE#>
                for (int i = 0; i < newComponents.length; ++i)
                {
                    newComponents[i].CopyFrom(newComponents[i]);
                };
------<#ELSE#>
                System.Array.Copy(components, newComponents, length);
------<#END#>
                this.tick = tick;
                this.components = newComponents;
            }

------<#IF COPYABLE#>
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public void OnRecycle()
            {
                for (int i = 0; i < components.Length; ++i)
                {
                    components[i].OnRecycle();
                }
            }
------<#END#>

------<#IF INJECT#>
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public void ReInject(ref InjectContainer injectContainer, delegate*<ref T, ref InjectContainer, void> construct)
            {
                for (int i = 0, iMax = components.Length; i < iMax; ++i)
                {
                    construct(ref components[i].component, ref injectContainer);   
                }
            }
------<#END#>

            public void Pack(ref WriterContextSerializer writer)
            {
                writer.Write(tick);

------<#IF BLITTABLE && !FORCE:ISerialize#>
                writer.WriteUnmanagedArray(components);
------<#ELSE#>
                writer.Pack(components);
------<#END#>
            }

            public void Unpack(ref ReaderContextSerializer reader)
            {
                tick = reader.ReadUInt32();

------<#IF BLITTABLE && !FORCE:ISerialize#>
                components = reader.ReadUnmanagedArray<T>();
------<#ELSE#>
                components = reader.Unpack<T[]>();
------<#END#>
            }
        }


---<#END#>
<#END#>
        #endregion
    }
}