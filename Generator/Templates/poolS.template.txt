// <auto-generated>
// This source code was auto-generated by PoolGenerator.cs
// </auto-generated>

using System.Runtime.CompilerServices;
using System;
using AnotherECS.Core;
using AnotherECS.Serializer;
<#IF INJECT#>using AnotherECS.Unsafe;<#END#>

namespace AnotherECS.Gen.Common
{
    public struct Pool<#POOL_TYPE#><T> : ISinglePool, IComponentFactory<T>, ISerialize<#IF INJECT#>, IInjectSupport<#END#>
        where T : <#IF BLITTABLE#>unmanaged<#ELSE#>struct<#END#>, IComponent<#GENERIC_CONSTRAINTS#>
    {
        private Container _container;

        private Type _elementType;
        private ushort _elementId;
<#IF VERSION#>
        private TickProvider _tickProvider;
<#END#>
<#IF HISTORY#>
        private Pool<#HISTORY_TYPE#>History<T> _history;
<#END#>
<#IF ATTACH || DETACH#>
        private State _state;
<#END#>
        public Pool<#POOL_TYPE#>(ushort id<#CONSTRUCT_HISTORY#><#CONSTRUCT_VERSION#><#CONSTRUCT_INJECT#>)
        {
            _elementId = id;
            _container = new();
            _elementType = typeof(T);
<#IF VERSION#>
            _tickProvider = tickProvider;
<#END#>
<#IF INJECT#>
        private ushort _injectId;
        private InjectContainer _injectContainer;
        private delegate*<ref T, ref InjectContainer, void> _construct;
        private delegate*<ref T, ref InjectContainer, void> _deconstruct;
<#END#>

<#IF HISTORY#>
            _history = history;
<#END#>
<#IF ATTACH || DETACH#>
            _state = null;
<#END#>
<#IF INJECT#>
            _injectContainer = injectContainer;
            var methods = (InjectMethods<T>)injectMethods;
            _injectId = methods.id;
            _construct = UnsafeUtils.ConvertToPointer(methods.construct);
            _deconstruct = UnsafeUtils.ConvertToPointer(methods.deconstruct);
<#END#>
        }

<#IF HISTORY#>
        public void BindExternal(IHistory history)
        {
            _history = (Pool<#HISTORY_TYPE#>History<T>)history;
        }
<#END#>

<#IF ATTACH || DETACH#>
        public void BindExternal(State state)
        {
            _state = state;
        }
<#END#>

<#IF INJECT#>
        public void BindInject(ref InjectContainer injectContainer, IInjectMethodsReference[] injectMethods)
        {
            var methods = (InjectMethods<T>)injectMethods[_injectId];
            _injectContainer = injectContainer;
            _injectId = methods.id;
            _construct = UnsafeUtils.ConvertToPointer(methods.construct);
            _deconstruct = UnsafeUtils.ConvertToPointer(methods.deconstruct);
        }

        public void ReInject()
        {
            for (int i = 0, iMax = _data.index; i < iMax; ++i)
            {
                _construct(ref _dense[i], ref _injectContainer);
            }
---<#IF HISTORY#>
            _history.ReInject(ref _injectContainer, _construct);
---<#END#>
        }
<#END#>
<#IF ATTACH#>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Attach()
        {
            if (_container.isValue)
            {
                _container.value.OnAttach(_state);
            }
        }
<#END#>
<#IF DETACH#>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Detach()
        {
            if (_container.isValue)
            {
                _container.value.OnDetach(_state);
            }
        }
<#END#>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool IsHas()
           => _container.isValue;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Add(ref T data)
        {
<#IF HISTORY#>
            _history.PushIsValue(false);
<#END#>
            _container.isValue = true;
            _container.value = data;
<#IF VERSION#>
            _container.version = _tickProvider.Tick;
<#END#>
<#IF INJECT#>
            _construct(ref _container.value, ref _injectContainer);
<#END#>
<#IF ATTACH#>
            _container.value.OnAttach(_state);
<#END#>
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ref T Add()
        {
<#IF HISTORY#>
            _history.PushIsValue(false);
<#END#>
            _container.isValue = true;
<#IF VERSION#>
            _container.version = _tickProvider.Tick;
<#END#>
<#IF INJECT#>
            _construct(ref _container.value, ref _injectContainer);
<#END#>
<#IF ATTACH#>
            _container.value.OnAttach(_state);
<#END#>
            return ref _container.value;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public object ReadObject()
            => _container;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ref readonly T Read()
            => ref _container.value;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ref T Get()
        {
<#IF VERSION#>
            _container.version = _tickProvider.Tick;
<#END#>
<#IF HISTORY:BYCHANGE#>
---<#IF COPYABLE#>
            T copy = default; copy.CopyFrom(in _container.value);
            _history.PushValue(ref copy);
---<#ELSE#>
            _history.PushValue(ref _container.value);
---<#END#>
<#END#>
            return ref _container.value;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Set(ref T data)
        {
<#IF HISTORY:BYCHANGE#>
            _history.PushValue(ref _container.value);
<#END#>
            _container.value = data;
<#IF VERSION#>
            _container.version = _tickProvider.Tick;
<#END#>
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Remove()
        {
<#IF HISTORY#>
            _history.PushIsValue(true);
<#END#>
<#IF HISTORY:BYCHANGE#>
            _history.PushValue(ref _container.value);
<#END#>
<#IF DETACH#>
            _container.value.OnDetach(_state);
<#END#>
<#IF INJECT#>
            _deconstruct(ref component, ref _injectContainer);
<#END#>
<#IF COPYABLE && !HISTORY:BYCHANGE#>
            _container.OnRecycle();
<#ELSE#>
            _container.value = default;
<#END#>
            _container.isValue = false;
        }

<#IF VESRION#>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint GetVersion()
            => _container.version;
<#END#>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ushort GetTypeId()
            => _elementId;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Type GetElementType()
            => _elementType;

<#IF HISTORY:BYTICK#>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void PushChanges()
            => _history.PushValue(ref _container.value);
<#END#>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Clear()
        {
            Reset();
            _container.value = default;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Reset()
        {
<#IF COPYABLE#>
            Recycle();
<#END#>
<#IF INJECT#>
            Deconstruct();
<#END#>
            _container.isValue = false;
        }
<#IF COPYABLE#>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Recycle()
        {
            if (_container.isValue)
            {
                _container.value.OnRecycle();
            }
        }
<#END#>
<#IF INJECT#>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Deconstruct()
        {
            if (_container.isValue)
            {
                _deconstruct(ref _container.value, ref _injectContainer);
            }
        }
<#END#>
<#IF DISPOSE#>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Dispose()
        {

        }
<#END#>

        public bool GetIsValueRaw()
            => _container.isValue;
        
        public void SetIsValueRaw(bool value)
            => _container.isValue = value;

        public ref T GetValueRaw()
            => ref _container.value;

        public void SetValueRaw(ref T value)
            => _container.value = value;

<#IF HISTORY#>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void RevertTo(uint tick)
            => _history.RevertTo(tick, ref this);
<#END#>

        public T Create()
        {
<#IF INJECT#>
            var component = new T();
            _construct(ref component, ref _injectContainer);
            return component;
<#ELSE#>
            return default;
<#END#>
        }

        public void Pack(ref WriterContextSerializer writer)
        {
<#IF INJECT#>
            writer.Write(_injectId);
<#END#>
            writer.Pack(_container);
            writer.Write(_elementId);
        }

        public void Unpack(ref ReaderContextSerializer reader)
        {
<#IF INJECT#>
            _injectId = reader.ReadUInt16();
<#END#>
            _container = reader.Unpack<Container>();
            _elementId = reader.ReadUInt16();
            _elementType = typeof(T);
        }

        public class Container : ISerialize
        {
            public bool isValue;
            public T value;
<#IF VERSION#>
            public int version;
<#END#>

            public void Pack(ref WriterContextSerializer writer)
            {
                writer.Write(isValue);
                writer.WriteStruct(value);
<#IF VERSION#>
                writer.Write(version);
<#END#>
            }

            public void Unpack(ref ReaderContextSerializer reader)
            {
                isValue = reader.ReadBoolean();
                value = reader.ReadStruct<T>();
<#IF VERSION#>
                version = reader.ReadInt32();
<#END#>
            }
        }
    }
}

