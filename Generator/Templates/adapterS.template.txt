// <auto-generated>
// This source code was auto-generated by AdapterGenerator.cs
// </auto-generated>

using AnotherECS.Core;
using AnotherECS.Serializer;
using System.Runtime.CompilerServices;

namespace AnotherECS.Gen.Common
{
    public <#IF STORAGE_REFERNCE#>class<#ELSE#>struct<#END#> Adapter<#ADAPTER_TYPE#><T> : ISingleAdapter<T>, IAdapterReference<#IF DISPOSE#>, IDisposableInternal<#END#><#IF HISTORY#>, IRevert<#END#>, IComponentFactory<T><#IF COPYABLE#>, IRecycleInternal<#END#>, ISerialize<#IF INJECT#>, IInjectSupportInternal<#END#><#IF ATTACH#>, IAttachInternal<#END#><#IF DETACH#>, IDetachInternal<#END#><#IF HISTORY#>, IHistoryBindExternalInternal<#END#><#IF ATTACH || DETACH#>, IStateBindExternalInternal<#END#>
        where T : <#IF BLITTABLE#>unmanaged<#ELSE#>struct<#END#>, IComponent<#GENERIC_CONSTRAINTS#>
    {
        private Storage<#STORAGE_TYPE#><T> _storage;

        public Adapter<#ADAPTER_TYPE#>(ref Storage<#STORAGE_TYPE#><T> storage)
        {
            _storage = storage;
#if ANOTHERECS_DEBUG
            _state = null;
#endif
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool IsHas()
            => _storage.IsHas();

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ref readonly T Read()
        {
#if ANOTHERECS_DEBUG
            ExceptionHelper.ThrowIfInvalide(_state, _storage);
#endif
            return ref _storage.Read();
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ref T Get()
        {
#if ANOTHERECS_DEBUG
            ExceptionHelper.ThrowIfInvalide(_state, _storage);
#endif
            return ref _storage.Get();
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Set(T data)
        {
#if ANOTHERECS_DEBUG
            ExceptionHelper.ThrowIfInvalide(_state, _storage);
#endif
            _storage.Set(ref data);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Set(ref T data)
        {
#if ANOTHERECS_DEBUG
            ExceptionHelper.ThrowIfInvalide(_state, _storage);
#endif
            _storage.Set(ref data);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void SetOrAdd(T data)
            => SetOrAdd(ref data);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void SetOrAdd(ref T data)
        {
            if (IsHas())
            {
                Set(ref data);
            }
            else
            {
                Add(ref data);
            }
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ref T Add()
        {
#if ANOTHERECS_DEBUG
            ExceptionHelper.ThrowIfInvalide(_state, _storage, false);
#endif
            return ref _storage.Add();
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Add(T data)
            => Add(ref data);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Add(ref T data)
        {
#if ANOTHERECS_DEBUG
            ExceptionHelper.ThrowIfInvalide(_state, _storage, false);
#endif
            _storage.Add(ref data);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        ref T ISingleAdapter<T>.AddSync()
        {
#if ANOTHERECS_DEBUG
            ExceptionHelper.ThrowIfInvalide(_state, _storage, false);
#endif
            return ref Add();
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        void ISingleAdapter.AddSyncVoid()
        {
#if ANOTHERECS_DEBUG
            ExceptionHelper.ThrowIfInvalide(_state, _storage, false);
#endif
            Add();
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Remove()
        {
#if ANOTHERECS_DEBUG
            ExceptionHelper.ThrowIfInvalide(_state, _storage);
#endif
            RemoveInternal();
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        void ISingleAdapter.RemoveSync()
            => Remove();


<#IF HISTORY:BYTICK#>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TickFinished()
            => _storage.PushChanges();
<#END#>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T Create()
            => _storage.Create();

<#IF DISPOSE#>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        void IDisposableInternal.Dispose()
            => _storage.Dispose();
<#END#>

<#IF COPYABLE#>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        void IRecycleInternal.Recycle()
            => _storage.Recycle();
<#END#>

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private void RemoveInternal()
            => _storage.Remove();        
<#IF ATTACH#>
        void IAttachInternal.Attach()
            => _storage.Attach();
<#END#>
<#IF DETACH#>
        void IDetachInternal.Detach()
            => _storage.Detach();
<#END#>

<#IF HISTORY#>
        void IHistoryBindExternalInternal.BindExternal(IHistory history)
            => _storage.BindExternal(history);
<#END#>

<#IF ATTACH || DETACH#>
        void IStateBindExternalInternal.BindExternal(State state)
            => _storage.BindExternal(state);
<#END#>

<#IF INJECT#>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        void IInjectSupportInternal.BindInject(ref InjectContainer injectContainer, IInjectMethodsReference[] injectMethods)
            => _storage.BindInject(ref injectContainer, injectMethods);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        void IInjectSupportInternal.ReInject()
            => _storage.ReInject();
<#END#>

<#IF HISTORY#>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        void IRevert.RevertTo(uint tick)
            => _storage.RevertTo(tick);
<#END#>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        void IAdapter.Rebind(IStorage storage)
            => _storage = (Storage<#STORAGE_TYPE#><T>)storage;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        void IAdapter.Clear()
            => _storage.Clear();

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        IStorage IAdapter.GetStorage()
            => _storage;

        public void Pack(ref WriterContextSerializer writer)
        {
            _storage.Pack(ref writer);
        }

        public void Unpack(ref ReaderContextSerializer reader)
        {
            _storage.Unpack(ref reader);
        }

#if ANOTHERECS_DEBUG
        private IDebugException _state;

        void IAdapter.SetState(IDebugException state)
        {
            _state = state;
        }
#endif
    }
}
