// <auto-generated>
// This source code was auto-generated by CallerGenerator.cs
// </auto-generated>

using System;
using System.Runtime.CompilerServices;
using AnotherECS.Core;
using AnotherECS.Core.Actions;
<#IF MULTI#>using EntityId = System.UInt32;<#END#>

namespace AnotherECS.Gen.Common
{
#if ENABLE_IL2CPP
    [Unity.IL2CPP.CompilerServices.Il2CppSetOption(Option.NullChecks, false)]
    [Unity.IL2CPP.CompilerServices.Il2CppSetOption(Option.ArrayBoundsChecks, false)]
#endif
    public unsafe struct <#CALLER:TYPE_NAME#>_Caller<TComponent> : 
        I<#STORAGE:MODE#>Caller<TComponent><#IF DISPOSABLE#>, IDisposable<#END#><#IF HISTORY#>, IRevert<#END#><#IF FORCE:ISerialize#>, ISerialize<#END#><#IF HISTORY:BYTICK && !EMPTY#>ITickFinished<#END#><#IF ATTACH#>, ICallerAttach<#END#><#IF DETACH#>, ICallerDetach<#END#>
        where TComponent : unmanaged, IComponent<#GENERIC_CONSTRAINTS:TComponent#>
    {
    
        private UnmanagedLayout<<#SPARSE:TYPE_NAME#>, TComponent, <#VERSION:TYPE_NAME#>, <#RECYCLE:TYPE_NAME#>>* _layout;
        private GlobalDepencies* _depencies;
        private ushort _elementId;

<#IF ATTACH || DETACH#>
        private State _state;
---<#IF SINGLE#>
        private <#SPARSE:TYPE_NAME#> _bufferCopyTemp;
        private Op _opsTemp;
---<#END#>
---<#IF MULTI#>
        private AnotherECS.Core.Collection.ArrayPtr _bufferCopyTemp;
        private AnotherECS.Core.Collection.ArrayPtr<Op> _opsTemp;
---<#END#>
<#END#>

<#IF EMPTY#>
        private DefaultContainer _empty;
<#END#>

        void ICaller.Config(UnmanagedLayout* layout, GlobalDepencies* depencies, ushort id, State state)
        {
            _layout = (UnmanagedLayout<TComponent>*)layout;
            _depencies = depencies;
            _elementId = id;
<#IF ATTACH || DETACH#>
            _state = state;
---<#IF MULTI#>
            _bufferCopyTemp = AnotherECS.Core.Collection.ArrayPtr.Create<<#SPARSE:TYPE_NAME#>>(_depencies->config.general.entityCapacity);
            _opsTemp = new AnotherECS.Core.Collection.ArrayPtr<Op>(_depencies->config.general.entityCapacity);
---<#END#>
<#END#>
<#IF EMPTY#>
            _empty = new DefaultContainer();
<#END#>
        }

        void ICaller.AllocateLayout()
        {
            CallerFacadeActions<TComponent>.AllocateSparse<#STORAGE:MODE#><#IF MULTI#><<#SPARSE:TYPE_NAME#>><#END#>(ref *_layout, ref *_depencies, <#HISTORY:FLAG#>);
<#IF !EMPTY#>
            CallerFacadeActions<TComponent>.AllocateDense<#STORAGE:MODE#>(ref *_layout, ref *_depencies, <#HISTORY:FLAG#>);
<#END#>
<#IF ALLOCATOR:RECYCLE#>
            CallerFacadeActions<TComponent>.AllocateRecycle<#STORAGE:MODE#>(ref *_layout, ref *_depencies, <#HISTORY:FLAG#>);
<#END#>
<#IF VERSION#>
            CallerFacadeActions<TComponent>.AllocateVersion<#STORAGE:MODE#>(ref *_layout, ref *_depencies, <#HISTORY:FLAG#>);
<#END#>
        }

        public TComponent Create()
        {
<#IF INJECT#>
            var component = new TComponent();
            StorageActions<TComponent>.CallConstruct(ref *_layout, ref *_depencies, ref component);
            return component;
<#ELSE#>
            return default;
<#END#>
        }

<#IF DISPOSABLE#>
        public void Dispose()
        {
---<#IF MULTI#>
            _bufferCopyTemp.Dispose();
            _opsTemp.Dispose();
---<#END#>
            Reset();
        }
<#END#>
        public Type GetElementType()
            => typeof(TComponent);

        public uint GetCount()
            => <#STORAGE:MODE#>StorageActions<TComponent>.GetCount(ref *_layout);

<#IF MULTI#>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Resize(uint capacity)
        {
            <#STORAGE:MODE#>StorageActions<TComponent>.ResizeSparse<<#SPARSE:TYPE_NAME#>>(ref *_layout, capacity);
---<#IF SPARSE:BOOL#>
------<#IF !EMPTY#>
            <#STORAGE:MODE#>StorageActions<TComponent>.ResizeDense(ref *_layout, capacity);
------<#END#>
------<#IF VERSION#>
            <#STORAGE:MODE#>StorageActions<TComponent>.ResizeVersion(ref *_layout, capacity);
------<#END#>
---<#END#>
        }
<#END#>

<#IF INJECT#>
        public void Inject()
        {
            <#STORAGE:MODE#>StorageActions<TComponent>.CallConstruct_<#SPARSE:TYPE_NAME#>(ref *_layout, ref *_depencies<#IF !SPARSE:BOOL#>, GetCount()<#END#>);
---<#IF HISTORY#>
            HistoryActions<TComponent>.Inject(ref *_layout, ref *_depencies);
---<#END#>
        }
<#END#>

<#IF ATTACH#>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Attach()
        {
---<#IF EMPTY#>
            AttachStorageActions<TComponent>.Attach_empty(_state);
---<#ELSE#>
            <#STORAGE:MODE#>AttachStorageActions<TComponent>.Attach_<#SPARSE:TYPE_NAME#>(ref *_layout, _state<#IF !SPARSE:BOOL#>, GetCount()<#END#>);
---<#END#>
        }
<#END#>

<#IF DETACH#>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Detach()
        {
---<#IF EMPTY#>
            DetachStorageActions<TComponent>.Detach_empty();
---<#ELSE#>
            <#STORAGE:MODE#>DetachStorageActions<TComponent>.Detach_<#SPARSE:TYPE_NAME#>(ref *_layout, _state<#IF !SPARSE:BOOL#>, GetCount()<#END#>);
---<#END#>
        }
<#END#>

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool IsHas(<#IF MULTI#>EntityId id<#END#>)
            => <#STORAGE:MODE#>StorageActions<TComponent>.IsHas_<#SPARSE:TYPE_NAME#>(ref *_layout<#IF MULTI#>, id<#END#>);

<#IF SINGLE#>
        public void SetOrAdd(ref TComponent component)
        {
            if (IsHas())
            {
                Set(ref component);
            }
            else
            {
                Add(ref component);
            }
        }
<#END#>

<#IF EMPTY#>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Add(<#IF MULTI#>EntityId id, <#END#>ref TComponent data)
        {
            AddInternal(<#IF MULTI#>id<#END#>);
---<#IF ATTACH#>
            _empty.value.OnAttach(_state);
---<#END#>
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ref TComponent Add(<#IF MULTI#>EntityId id<#END#>)
        {
            AddInternal(<#IF MULTI#>id<#END#>);
---<#IF ATTACH#>
            _empty.value.OnAttach(_state);
---<#END#>
            return ref _empty.value;
        }

        public void AddVoid(<#IF MULTI#>EntityId id<#END#>)
        {
            AddInternal(<#IF MULTI#>id<#END#>);
---<#IF ATTACH#>
            _empty.value.OnAttach(_state);
---<#END#>
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private void AddInternal(<#IF MULTI#>EntityId id<#END#>)
        {
---<#IF BIND_TO_ENTITY && MULTI#>
            _depencies->entities.Add(id, _elementId);
---<#END#>
---<#IF VERSION && MULTI#>
            <#STORAGE:MODE#>StorageActions<TComponent>.TryResizeVersion(ref *_layout);
---<#END#>
---<#IF MULTI#>
            var denseIndex = (ushort)<#STORAGE:MODE#>StorageActions<TComponent>.AllocateId<#IF !ALLOCATOR:RECYCLE#>Increment<#END#>(ref *_layout, ref *_depencies);
            <#STORAGE:MODE#>StorageActions<TComponent>.SetSparse<#IF HISTORY#>History<#END#>_empty(ref *_layout, ref *_depencies, id);
---<#ELSE#>
            SingleStorageActions<TComponent>.SetSparse<#IF HISTORY#>History<#END#>_empty(ref *_layout, ref *_depencies);
---<#END#>
---<#IF VERSION#>
            <#STORAGE:MODE#>StorageActions<TComponent>.UpdateVersion(ref *_layout, ref *_depencies<#IF MULTI#>, denseIndex<#END#>);
---<#END#>
---<#IF INJECT#>
            StorageActions<TComponent>.CallConstruct(ref *_layout, ref *_depencies, ref _empty.value);
---<#END#>
        }
<#ELSE#>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Add(<#IF MULTI#>EntityId id, <#END#>ref TComponent data)
        {
            ref var component = ref AddInternal(<#IF MULTI#>id<#END#>);
            component = data;
---<#IF ATTACH#>
            component.OnAttach(_state);
---<#END#>
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ref TComponent Add(<#IF MULTI#>EntityId id<#END#>)
        {
            ref var component = ref AddInternal(<#IF MULTI#>id<#END#>);
---<#IF ATTACH#>
            component.OnAttach(_state);
---<#END#>
            return ref component;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void AddVoid(<#IF MULTI#>EntityId id<#END#>)
        {
            ref var component = ref AddInternal(<#IF MULTI#>id<#END#>);
---<#IF ATTACH#>
            component.OnAttach(_state);
---<#END#>
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private ref TComponent AddInternal(<#IF MULTI#>EntityId id<#END#>)
        {
---<#IF BIND_TO_ENTITY && MULTI#>
            _depencies->entities.Add(id, _elementId);
---<#END#>
---<#IF MULTI#>
            MultiStorageActions<TComponent>.TryResizeDense<#IF VERSION#>Version<#END#>(ref *_layout);
---<#END#>
            var denseIndex = (ushort)MultiStorageActions<TComponent>.AllocateId<#IF !ALLOCATOR:RECYCLE#>Increment<#END#><#IF HISTORY#>History<#END#>(ref *_layout, ref *_depencies);

            ref var component = ref <#STORAGE:MODE#>StorageActions<TComponent>.SetSparse<#IF HISTORY#>History<#END#>_<#SPARSE:TYPE_NAME#>(ref *_layout, ref *_depencies<#IF MULTI#>, id, denseIndex<#END#>);
---<#IF VERSION#>
            <#STORAGE:MODE#>StorageActions<TComponent>.UpdateVersion(ref *_layout, ref *_depencies<#IF MULTI#>, denseIndex<#END#>);
---<#END#>
---<#IF INJECT#>
            StorageActions<TComponent>.CallConstruct(ref *_layout, ref *_depencies, ref component);
---<#END#>
            return ref component;
        }
<#END#>

<#IF EMPTY#>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Remove(<#IF MULTI#>EntityId id<#END#>)
        {
---<#IF BIND_TO_ENTITY#>
            _depencies->entities.Remove(id, _elementId);
---<#END#>
            <#STORAGE:MODE#>StorageActions<TComponent>.RemoveSparse<#IF HISTORY#>History<#END#>_empty(ref *_layout, ref *_depencies<#IF MULTI#>, id<#END#>);
---<#IF DETACH#>
            default(TComponent).OnDetach(_state);
---<#END#>
        }
<#ELSE#>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Remove(<#IF MULTI#>EntityId id<#END#>)
        {
<#IF SINGLE#>
            <#STORAGE:MODE#>StorageActions<TComponent>.RemoveSparse<#IF HISTORY#>History<#END#>_<#SPARSE:TYPE_NAME#>(ref *_layout, ref *_depencies);
<#END#>
<#IF MULTI#>
            var denseIndex = (ushort)<#STORAGE:MODE#>StorageActions<TComponent>.RemoveSparse<#IF HISTORY#>History<#END#>_<#SPARSE:TYPE_NAME#>(ref *_layout, ref *_depencies, id);
<#END#>
---<#IF ALLOCATOR:RECYCLE#>
            MultiStorageActions<TComponent>.DeallocateId<#IF HISTORY#>History<#END#>(ref *_layout, ref *_depencies, denseIndex);
---<#END#>
            ref var component = ref <#STORAGE:MODE#>StorageActions<TComponent>.ReadDirect(ref *_layout<#IF MULTI#>, denseIndex<#END#>);
---<#IF HISTORY:BYCHANGE#>
            <#STORAGE:MODE#>StorageActions<TComponent>.RemoveDense(ref *_layout, ref *_depencies<#IF MULTI#>, denseIndex<#END#>, ref component);
---<#END#>
            Recycle(ref component);

---<#IF DETACH#>
            component.OnDetach(_state);
---<#END#>
---<#IF INJECT#>
            StorageActions<TComponent>.CallDeconstruct(ref *_layout, ref *_depencies, ref component);
---<#END#>
        }
<#END#>

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private void Recycle(ref TComponent component)
        {
<#IF COPYABLE#>
---<#IF HISTORY:BYTICK#>
            component.OnRecycle();
---<#ELSE#>
            component = default;
---<#END#>
<#ELSE#>
            component = default;
<#END#>
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public IComponent GetCopy(<#IF MULTI#>EntityId id<#END#>)
            => Get(<#IF MULTI#>id<#END#>);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Set(<#IF MULTI#>EntityId id, <#END#>IComponent data)
        {
            ref var component = ref Get(<#IF MULTI#>id<#END#>);
            component = (TComponent)data;
        }

<#IF EMPTY#>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ref readonly TComponent Read(<#IF MULTI#>EntityId id<#END#>)
            => ref _empty.value;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ref TComponent Get(<#IF MULTI#>EntityId id<#END#>)
            => ref _empty.value;


        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Set(<#IF MULTI#>EntityId id, <#END#>ref TComponent data)
        {
            _empty.value = data;
        }
<#ELSE#>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ref readonly TComponent Read(<#IF MULTI#>EntityId id<#END#>)
---<#IF SPARSE:BOOL#>
            => ref <#STORAGE:MODE#>StorageActions<TComponent>.ReadDirect(ref *_layout<#IF MULTI#>, id<#END#>);
---<#ELSE#>
            => ref <#STORAGE:MODE#>StorageActions<TComponent>.Read_<#SPARSE:TYPE_NAME#>(ref *_layout<#IF MULTI#>, id<#END#>);
---<#END#>

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ref TComponent Get(<#IF MULTI#>EntityId id<#END#>)
        {
---<#IF MULTI#>
            var denseIndex = <#STORAGE:MODE#>StorageActions<TComponent>.GetDense_<#SPARSE:TYPE_NAME#>(ref *_layout, id);
---<#END#>
            ref var component = ref <#STORAGE:MODE#>StorageActions<TComponent>.ReadDirect(ref *_layout<#IF MULTI#>, denseIndex<#END#>);
---<#IF VERSION#>
            <#STORAGE:MODE#>StorageActions<TComponent>.UpdateVersion(ref *_layout, ref *_depencies<#IF MULTI#>, denseIndex<#END#>);
---<#END#>
---<#IF HISTORY:BYCHANGE && !EMPTY#>
            <#IF COPYABLE#>Copyable<#ELSE#>Multi<#END#>HistoryFacadeActions<TComponent>.PushDense(ref *_layout, ref *_depencies, <#IF MULTI#>denseIndex<#ELSE#>0<#END#>, ref component);
---<#END#>
            return ref component;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Set(<#IF MULTI#>EntityId id, <#END#>ref TComponent data)
        {
            ref var component = ref Get(<#IF MULTI#>id<#END#>);
            component = data;
        }
<#END#>

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint GetVersion(<#IF MULTI#>EntityId id<#END#>)
<#IF VERSION#>
            => <#STORAGE:MODE#>StorageActions<TComponent>.GetVersion_<#SPARSE:TYPE_NAME#>(ref *_layout, id);
<#ELSE#>
            => 0;
<#END#>

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ResetStorage()
        {
<#IF DETACH#>
            Detach();
<#END#>
<#IF COPYABLE#>
            <#STORAGE:MODE#>CopyableStorageActions<TComponent>.CallRecycle_<#SPARSE:TYPE_NAME#>(ref *_layout<#IF !SPARSE:BOOL#>, GetCount()<#END#>);
<#END#>
<#IF INJECT#>
            <#STORAGE:MODE#>StorageActions<TComponent>.CallDeconstruct_<#SPARSE:TYPE_NAME#>(ref *_layout, ref *_depencies<#IF !SPARSE:BOOL#>, GetCount()<#END#>);
<#END#>
            <#STORAGE:MODE#>StorageActions<TComponent>.StorageClear(ref *_layout);
        }
<#IF HISTORY#>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ResetHistory()
        {
            <#IF COPYABLE#>Copyable<#END#>HistoryActions<TComponent>.HistoryClear(ref *_layout);
        }
<#END#>
        public void Reset()
        {
            ResetStorage();
<#IF HISTORY#>
            ResetHistory();
<#END#>
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void RevertTo(uint tick, State state)
        {
<#IF ATTACH | DETACH#>
            <#STORAGE:MODE#>HistoryFacadeActions<TComponent>.RevertToSparseAttachDetachBuffer<#IF MULTI#><<#SPARSE:TYPE_NAME#>><#END#>(ref *_layout, tick, ref _opsTemp<#IF MULTI#>, ref _bufferCopyTemp<#END#>);
<#ELSE#>
            MultiHistoryFacadeActions<TComponent>.RevertToSparseBuffer<<#SPARSE:TYPE_NAME#>>(ref *_layout, tick);
<#END#>
<#IF !EMPTY && !SINGLE#>
            <#STORAGE:MODE#>HistoryFacadeActions<TComponent>.RevertToCountBuffer(ref *_layout, tick);
<#END#>
<#IF ALLOCATOR:RECYCLE#>
            <#STORAGE:MODE#>HistoryFacadeActions<TComponent>.RevertToRecycleCountBuffer(ref *_layout, tick);
            <#STORAGE:MODE#>HistoryFacadeActions<TComponent>.RevertToRecycleBuffer(ref *_layout, tick);
<#END#>
<#IF EMPTY#>
---<#IF DETACH#>
            <#STORAGE:MODE#>DetachHistoryActions<TComponent>.CallDetach_empty(ref *_layout, state, ref _opsTemp);
---<#END#>
---<#IF ATTACH#>
            <#STORAGE:MODE#>AttachHistoryActions<TComponent>.CallAttach_empty(ref *_layout, state, ref _opsTemp);
---<#END#>
<#ELSE#>
---<#IF DETACH#>
            <#STORAGE:MODE#>DetachHistoryActions<TComponent>.CallDetach_<#SPARSE:TYPE_NAME#>(ref *_layout, state, ref _opsTemp);
---<#END#>
---<#IF HISTORY:BYCHANGE#>
            MultiHistoryFacadeActions<TComponent>.RevertToDenseBuffer(ref *_layout, tick);
---<#END#>
---<#IF HISTORY:BYTICK#>
            MultiHistoryFacadeActions<TComponent>.RevertToFullDenseBuffer(ref *_layout, tick);
---<#END#>
---<#IF ATTACH#>
            <#STORAGE:MODE#>AttachHistoryActions<TComponent>.CallAttach_<#SPARSE:TYPE_NAME#>(ref *_layout, state, ref _opsTemp);
---<#END#>
<#END#>
<#IF VERSION#>
            <#STORAGE:MODE#>StorageActions<TComponent>.UpdateVersion(ref *_layout, ref *_depencies);
<#END#>
        }

<#IF HISTORY:BYTICK && !EMPTY#>
        public void TickFinished()
        {
            <#IF COPYABLE#>Copyable<#ELSE#>Multi<#END#>HistoryFacadeActions<TComponent>.PushFullDense(ref *_layout, ref *_depencies);
        }
<#END#>

<#IF !BLITTABLE | FORCE:ISerialize#>
        public void Pack(ref WriterContextSerializer writer)
        {
---<#IF FORCE:ISerialize#>
            CustomSerializeActions<TComponent>.Pack(ref writer, ref *_layout, <#HISTORY:FLAG#>);
---<#ELSE#>
            NonBlittableSerializeActions<TComponent>.Pack(ref writer, ref *_layout, <#HISTORY:FLAG#>, <#BLITTABLE#>);
---<#END#>
        }
<#END#>

<#IF !BLITTABLE | FORCE:ISerialize | HISTORY:BYTICK#>
        public void Unpack(ref ReaderContextSerializer reader)
        {
---<#IF FORCE:ISerialize#>
            CustomSerializeActions<TComponent>.Unpack(ref reader, ref *_layout, <#HISTORY:FLAG#>, _layout->storage.denseIndex);
---<#ELSE#>
            NonBlittableSerializeActions<TComponent>.Unpack(ref reader, ref *_layout, <#HISTORY:FLAG#>, _layout->storage.denseIndex, <#BLITTABLE#>);
---<#END#>
        }
<#END#>

<#IF EMPTY#>
        private class DefaultContainer
        {
            public TComponent value;
        }
<#END#>
    }
}