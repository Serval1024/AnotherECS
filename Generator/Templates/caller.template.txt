// <auto-generated>
// This source code was auto-generated by CallerGenerator.cs
// </auto-generated>

using System;
using System.Runtime.CompilerServices;
using AnotherECS.Core;
using AnotherECS.Core.Actions
using EntityId = System.UInt32;

namespace AnotherECS.Gen.Common
{
#if ENABLE_IL2CPP
    [Unity.IL2CPP.CompilerServices.Il2CppSetOption(Option.NullChecks, false)]
    [Unity.IL2CPP.CompilerServices.Il2CppSetOption(Option.ArrayBoundsChecks, false)]
#endif
    public unsafe struct <#STORAGE:TYPE_NAME#>_Caller<TComponent> : I<#STORAGE:MODE#>Caller<TComponent>
        where TComponent : unmanaged, IComponent<#GENERIC_CONSTRAINTS:TComponent#>
    {
        private StorageLayout<EntityHead>* _layout;
        private GlobalDepencies* _depencies;
        private ushort _elementId;

<#IF ATTACH || DETACH#>
        private State _state;
---<#IF SINGLE#>
        private <#SPARSE:TYPE_NAME#> _bufferCopyTemp;
        private Op _opsTemp;
---<#END#>
---<#IF MULTI#>
        private ArrayPtr _bufferCopyTemp;
        private ArrayPtr<Op> _opsTemp;
---<#END#>
<#END#>

<#IF EMPTY#>
        private DefaultContainer _empty;
<#END#>

        void ICaller.Config(StorageLayout* layout, GlobalDepencies* depencies, ushort id, State state)
        {
<#IF ATTACH || DETACH#>
            _state = state;
---<#IF MULTI#>
            _bufferCopyTemp = ArrayPtr.Create<<#SPARSE:TYPE_NAME#>>(_depencies.config.entityCapacity);
            _opsTemp = new ArrayPtr<T>(_depencies.config.entityCapacity);
---<#END#>
<#END#>
            _layout = layout;
            _depencies = depencies;
            _elementId = id;
<#IF EMPTY#>
            _empty = new DefaultContainer();
<#END#>
        }

        void ICaller.AllocateLayout()
        {
            CallerFacadeActions<TComponent>.AllocateSparse<#STORAGE:MODE#><<#SPARSE:TYPE_NAME#>>(ref *_layout, ref *_depencies, <#HISTORY:FLAG#>);
<#IF !EMPTY#>
            CallerFacadeActions<TComponent>.AllocateDense<#STORAGE:MODE#>(ref *_layout, ref *_depencies, <#HISTORY:FLAG#>);
<#END#>
<#IF ALLOCATOR:RECYCLE#>
            CallerFacadeActions<TComponent>.AllocateRecycle<#STORAGE:MODE#>(ref *_layout, ref *_depencies, <#HISTORY:FLAG#>);
<#END#>
<#IF VERSION#>
            CallerFacadeActions<TComponent>.AllocateVersion<#STORAGE:MODE#>(ref *_layout, ref *_depencies, <#HISTORY:FLAG#>);
<#END#>
        }

        public T Create()
        {
<#IF INJECT#>
            var component = new T();
            StorageActions<T>.CallConstruct(ref *_layout, ref *_depencies, ref component);
            return component;
<#ELSE#>
            return default;
<#END#>
        }

<#IF ATTACH || DETACH#>
        public void Dispose()
        {
---<#IF MULTI#>
            _bufferCopyTemp.Dispose();
            _opsTemp.Dispose();
---<#END#>
        }
<#END#>
        public Type GetElementType()
            => typeof(T);

        public uint GetCount()
            => <#STORAGE:MODE#>StorageActions<TComponent>.GetCount(ref *_layout);

<#IF MULTI#>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Resize(int capacity)
        {
            <#STORAGE:MODE#>StorageActions<TComponent>.ResizeSparse(ref *_layout, capacity);
---<#IF SPARSE:BOOL#>
------<#IF !EMPTY#>
            <#STORAGE:MODE#>StorageActions<TComponent>.ResizeDense(ref *_layout, capacity);
------<#END#>
------<#IF VERSION#>
            <#STORAGE:MODE#>StorageActions<TComponent>.ResizeVersion(ref *_layout, capacity);
------<#END#>
---<#END#>
        }
<#END#>

<#IF INJECT#>
        public void Inject()
        {
            <#STORAGE:MODE#>StorageActions<TComponent>.CallConstruct_<#SPARSE:TYPE_NAME#>(ref *_layout, ref *_depencies<#IF !SPARSE:BOOL#>, GetCount()<#END#>);
---<#IF HISTORY#>
            HistoryActions<TComponent>.Inject(ref *_layout, ref *_depencies);
---<#END#>
        }
<#END#>

<#IF ATTACH#>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Attach()
        {
---<#IF EMPTY#>
            AttachStorageActions<T>.Attach_empty(_state);
---<#ELSE#>
            <#STORAGE:MODE#>AttachStorageActions<T>.Attach_<#SPARSE:TYPE_NAME#>(ref *_layout, _state<#IF !SPARSE:BOOL#>, GetCount()<#END#>);
---<#END#>
        }
<#END#>

<#IF DETACH#>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Detach()
        {
---<#IF EMPTY#>
            DetachStorageActions<T>.Detach_empty();
---<#ELSE#>
            <#STORAGE:MODE#>DetachStorageActions<T>.Detach_<#SPARSE:TYPE_NAME#>(ref *_layout<#IF !SPARSE:BOOL#>, GetCount()<#END#>);
---<#END#>
        }
<#END#>

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool IsHas(<#IF MULTI#>EntityId id<#END#>)
            => <#STORAGE:MODE#>StorageActions<T>.IsHas_<#SPARSE:TYPE_NAME#>(ref *_layout<#IF MULTI#>, id<#END#>);

<#IF EMPTY#>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Add(<#IF MULTI#>EntityId id, <#END#>ref T data)
        {
            AddInternal(<#IF MULTI#>id<#END#>);
---<#IF ATTACH#>
            _empty.value.OnAttach(_state);
---<#END#>
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ref T Add(<#IF MULTI#>EntityId id<#END#>)
        {
            AddInternal(<#IF MULTI#>id<#END#>);
---<#IF ATTACH#>
            _empty.value.OnAttach(_state);
---<#END#>
            return ref _empty.value;
        }

        public void AddVoid(<#IF MULTI#>EntityId id<#END#>)
        {
            AddInternal(<#IF MULTI#>id<#END#>);
---<#IF ATTACH#>
            _empty.value.OnAttach(_state);
---<#END#>
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private void AddInternal(<#IF MULTI#>EntityId id<#END#>)
        {
---<#IF BIND_TO_ENTITY && MULTI#>
            _depencies.entities.Add(id, _elementId);
---<#END#>
---<#IF VERSION && MULTI#>
            <#STORAGE:MODE#>StorageActions<T>.TryResizeVersion(ref *_layout);
---<#END#>
---<#IF MULTI#>
            var denseIndex = <#STORAGE:MODE#>StorageActions<T>.AllocateId<#IF !ALLOCATOR:RECYCLE#>Increment<#END#>(ref *_layout, ref *_depencies);
            <#STORAGE:MODE#>StorageActions<T>.SetSparse<#IF HISTORY#>History<#END#>_empty(ref *_layout, ref *_depencies, id);
---<#ELSE#>
            SingleStorageActions<T>.SetSparse<#IF HISTORY#>History<#END#>_empty(ref *_layout, ref *_depencies);
---<#END#>
---<#IF VERSION#>
            <#STORAGE:MODE#>StorageActions<T>.UpdateVersion(ref *_layout, ref *_depencies<#IF MULTI#>, denseIndex<#END#>);
---<#END#>
---<#IF INJECT#>
            StorageActions<T>.CallConstruct(ref *_layout, ref *_depencies, ref _empty.value);
---<#END#>
        }
<#ELSE#>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Add(<#IF MULTI#>EntityId id, <#END#>ref T data)
        {
            ref var component = ref AddInternal(<#IF MULTI#>id<#END#>);
            component = data;
---<#IF ATTACH#>
            component.OnAttach(_state);
---<#END#>
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ref T Add(<#IF MULTI#>EntityId id<#END#>)
        {
            ref var component = ref AddInternal(<#IF MULTI#>id<#END#>);
---<#IF ATTACH#>
            component.OnAttach(_state);
---<#END#>
            return ref component;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void AddVoid(<#IF MULTI#>EntityId id<#END#>)
        {
            ref var component = ref AddInternal(<#IF MULTI#>id<#END#>);
---<#IF ATTACH#>
            component.OnAttach(_state);
---<#END#>
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private ref T AddInternal(<#IF MULTI#>EntityId id<#END#>)
        {
---<#IF BIND_TO_ENTITY && MULTI#>
            _depencies.entities.Add(id, _elementId);
---<#END#>
---<#IF MULTI#>
            MultiStorageActions<T>.TryResizeDense<#IF VERSION#>Version<#END#>(ref *_layout);
---<#END#>
            var denseIndex = MultiStorageActions<T>.AllocateId<#IF !ALLOCATOR:RECYCLE#>Increment<#END#><#IF HISTORY#>History<#END#>(ref *_layout, ref *_depencies);

            ref var component = ref <#STORAGE:MODE#>StorageActions<T>.SetSparse<#IF HISTORY#>History<#END#>_<#SPARSE:TYPE_NAME#>(ref *_layout, ref *_depencies<#IF MULTI#>, id, denseIndex<#END#>);
---<#IF VERSION#>
            <#STORAGE:MODE#>StorageActions<T>.UpdateVersion(ref *_layout, ref *_depencies<#IF MULTI#>, denseIndex<#END#>);
---<#END#>
---<#IF INJECT#>
            StorageActions<T>.CallConstruct(ref *_layout, ref *_depencies, ref component);
---<#END#>
            return ref component;
        }
<#END#>

<#IF EMPTY#>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Remove(<#IF MULTI#>EntityId id<#END#>)
        {
---<#IF BIND_TO_ENTITY#>
            _depencies.entities.Remove(id, _elementId);
---<#END#>
            <#STORAGE:MODE#>StorageActions<T>.RemoveSparse<#IF HISTORY#>History<#END#>_empty(ref *_layout, ref *_depencies<#IF MULTI#>, id<#END#>);
---<#IF DETACH#>
            default(T).OnDetach(_state);
---<#END#>
        }
<#ELSE#>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Remove(<#IF MULTI#>EntityId id<#END#>)
        {
<#IF SINGLE#>
            <#STORAGE:MODE#>StorageActions<T>.RemoveSparse<#IF HISTORY#>History<#END#>_<#SPARSE:TYPE_NAME#>(ref *_layout, ref *_depencies);
<#END#>
<#IF MULTI#>
            var denseIndex = <#STORAGE:MODE#>StorageActions<T>.RemoveSparse<#IF HISTORY#>History<#END#>_<#SPARSE:TYPE_NAME#>(ref *_layout, ref *_depencies, id);
<#END#>
---<#IF ALLOCATOR:RECYCLE#>
            StorageActions<T>.DeallocateId<#IF HISTORY#>History<#END#>(ref *_layout, ref *_depencies, denseIndex);
---<#END#>
            ref var component ref = <#STORAGE:MODE#>StorageActions<T>.ReadDirect(ref *_layout, ref *_depencies<#IF MULTI#>, denseIndex<#END#>);
---<#IF HISTORY:BYCHANGE#>
            <#STORAGE:MODE#>StorageActions<T>.RemoveDense(ref *_layout, ref *_depencies<#IF MULTI#>, denseIndex<#END#>, ref component);
---<#END#>
            Recycle();

---<#IF DETACH#>
            component.OnDetach(_state);
---<#END#>
---<#IF INJECT#>
            StorageActions<T>.CallDeconstruct(ref *_layout, ref *_depencies, ref T component);
---<#END#>
        }
<#END#>

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private void Recycle()
        {
<#IF COPYABLE#>
---<#IF HISTORY:BYTICK#>
            component.OnRecycle();
---<#ELSE#>
            component = default;
---<#END#>
<#ELSE#>
            component = default;
<#END#>
        }

<#IF EMPTY#>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ref readonly T Read(<#IF MULTI#>EntityId id<#END#>)
            => ref _empty.value;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ref T Get(<#IF MULTI#>EntityId id<#END#>)
            => ref _empty.value;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Set(<#IF MULTI#>EntityId id, <#END#>ref T data)
        {
            _empty.value = data;
        }
<#ELSE#>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ref readonly T Read(<#IF MULTI#>EntityId id<#END#>)
---<#IF SPARSE:BOOL#>
            => ref <#STORAGE:MODE#>StorageActions<T>.ReadDirect(ref _layout, id);
---<#ELSE#>
            => ref <#STORAGE:MODE#>StorageActions<T>.Read(ref _layout, id);
---<#END#>

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ref T Get(<#IF MULTI#>EntityId id<#END#>)
        {
---<#IF MULTI#>
            var denseIndex = <#STORAGE:MODE#>StorageActions<T>.GetDense_<#SPARSE:TYPE_NAME#>(ref *_layout, id);
---<#END#>
            ref var component = <#STORAGE:MODE#>StorageActions<T>.ReadDirect(ref *_layout<#IF MULTI#>, denseIndex<#END#>);
---<#IF VERSION#>
            <#STORAGE:MODE#>StorageActions<T>.UpdateVersion(ref *_layout, ref *_depencies<#IF MULTI#>, denseIndex<#END#>);
---<#END#>
---<#IF HISTORY:BYCHANGE && !EMPTY#>
            <#IF COPYABLE#>Copyable<#ELSE#>Multi<#END#>HistoryFacadeActions<T>.PushDense(ref layout, ref depencies<#IF MULTI#>, denseIndex<#ELSE#>0<#END#>, ref component);
---<#END#>
            return ref component;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Set(<#IF MULTI#>EntityId id<#END#>, ref T data)
        {
            ref var component = Get(<#IF MULTI#>id<#END#>);
            component = data;
        }
<#END#>

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint GetVersion(<#IF MULTI#>EntityId id<#END#>)
<#IF VERSION#>
            => <#STORAGE:MODE#>StorageActions<T>.GetVersion_<#SPARSE:TYPE_NAME#>(ref *_layout, id);
<#ELSE#>
            => 0;
<#END#>

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Reset()
        {
<#IF DETACH#>
            Detach();
<#END#>
<#IF COPYABLE#>
            <#STORAGE:MODE#>CopyableStorageActions<T>.CallRecycle_<#SPARSE:TYPE_NAME#>(ref *_layout<#IF !SPARSE:BOOL#>, GetCount()<#END#>);
<#END#>
<#IF INJECT#>
            <#STORAGE:MODE#>StorageActions<TComponent>.CallDeconstruct_<#SPARSE:TYPE_NAME#>(ref *_layout, ref *_depencies<#IF !SPARSE:BOOL#>, GetCount()<#END#>);
<#END#>
            <#STORAGE:MODE#>StorageActions<T>.StorageClear(ref *_layout);
        }
    

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void RevertTo(uint tick)
        {
<#IF ATTACH | DETACH#>
            <#STORAGE:MODE#>HistoryFacadeActions<T>.RevertToSparseAttachDetachBuffer<#IF MULTI#><<#SPARSE:TYPE_NAME#>><#END#>(ref *_layout, tick, ref _opsTemp<#IF MULTI#>, ref _bufferCopyTemp<#END#>);
<#ELSE#>
            MultiHistoryFacadeActions<T>.RevertToSparseBuffer<<#SPARSE:TYPE_NAME#>>(ref *_layout, tick);
<#END#>
<#IF !EMPTY && !SINGLE#>
            <#STORAGE:MODE#>HistoryFacadeActions<T>.RevertToDenseCountBuffer(ref *_layout, tick);
<#END#>
<#IF ALLOCATOR:RECYCLE#>
            <#STORAGE:MODE#>HistoryFacadeActions<T>.RevertToRecycleCountBuffer(ref *_layout, tick);
            <#STORAGE:MODE#>HistoryFacadeActions<T>.RevertToRecycleBuffer(ref *_layout, tick);
<#END#>
<#IF EMPTY#>
---<#IF DETACH#>
            <#STORAGE:MODE#>DetachHistoryActions<T>.CallDetach_empty(ref *_layout, state, ref _opsTemp);
---<#END#>
---<#IF ATTACH#>
            <#STORAGE:MODE#>AttachHistoryActions<T>.CallAttach_empty(ref *_layout, state, ref _opsTemp);
---<#END#>
<#ELSE#>
---<#IF DETACH#>
            <#STORAGE:MODE#>DetachHistoryActions<T>.CallDetach_<#SPARSE:TYPE_NAME#>(ref *_layout, state, ref _opsTemp);
---<#END#>
---<#IF HISTORY:BYCHANGE#>
            MultiHistoryFacadeActions<T>.RevertToDenseBuffer(ref *_layout, tick);
---<#END#>
---<#IF HISTORY:BYTICK#>
            MultiHistoryFacadeActions<T>.RevertToFullDenseBuffer(ref *_layout, tick);
---<#END#>
---<#IF ATTACH#>
            <#STORAGE:MODE#>AttachHistoryActions<T>.CallAttach_<#SPARSE:TYPE_NAME#>(ref *_layout, state, ref _opsTemp);
---<#END#>
<#END#>
<#IF VERSION#>
            <#STORAGE:MODE#>StorageActions<T>.UpdateVersion(ref *_layout, ref *_depencies);
<#END#>
        }

<#IF HISTORY:BYTICK && !EMPTY#>
        public void TickFinished()
        {
            <#IF COPYABLE#>Copyable<#ELSE#>Multi<#END#>HistoryFacadeActions<T>.PushFullDense(ref *_layout, ref *_depencies);
        }
<#END#>

<#IF EMPTY#>
        private class DefaultContainer
        {
            public T value;
        }
<#END#>
    }
}