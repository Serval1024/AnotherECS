// <auto-generated>
// This source code was auto-generated by HistoryGenerator.cs
// </auto-generated>

using AnotherECS.Core;
using AnotherECS.Serializer;
using System.Runtime.CompilerServices;
#if !ANOTHERECS_DEBUG
using Unity.Collections.LowLevel.Unsafe;
#endif

namespace AnotherECS.Gen.Common
{
#if ENABLE_IL2CPP
    [Unity.IL2CPP.CompilerServices.Il2CppSetOption (Option.NullChecks, false)]
    [Unity.IL2CPP.CompilerServices.Il2CppSetOption (Option.ArrayBoundsChecks, false)]
#endif
    public class Pool<#HISTORY_TYPE#>History<T> : PoolHistory<#IF COPYABLE#>, IRecycleInternal<#END#>, ISerialize<#IF ATTACH || DETACH#>, IStateBindExternalInternal<#END#>
        where T : <#IF BLITTABLE#>unmanaged<#ELSE#>struct<#END#>, IComponent<#GENERIC_CONSTRAINTS#>
    {
        private int _isValueIndex;
        private TickBoolData[] _isValueBuffer;

        private int _componentIndex;
        private ComponentData[] _componentBuffer;

<#IF ATTACH || DETACH#>
        private State _state;
        private Op _ops;
<#END#>

        internal Pool<#HISTORY_TYPE#>History(ref ReaderContextSerializer reader, TickProvider tickProvider)
             : base(ref reader, tickProvider)
        { }

        public Pool<#HISTORY_TYPE#>History(in HistoryConfig config, TickProvider tickProvider, uint subjectId)
            : base(config, tickProvider, subjectId)
        {
            _isValueBuffer = new TickBoolData[config.buffersAddRemoveCapacity];
            _componentBuffer = new ComponentData[config.buffersChangeCapacity];
        }

<#IF ATTACH || DETACH#>
        public void BindExternal(State state)
        {
            _state = state;
        }
<#END#>

        public void RevertTo(uint tick, ref Pool<#POOL_TYPE#><T> subject)
        {
            RevertToIsValueBuffer(tick, ref subject);
<#IF DETACH#>
            DetachComponentRevert(ref subject);
<#END#>
            RevertToComponentBuffer(tick, ref subject);
<#IF ATTACH#>
            AttachComponentRevert(ref subject);
<#END#>
        }

<#IF DISPOSE#>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Dispose()
        {
            for (int i = 0; i < _componentBuffer.Length; ++i)
            {
                if (_componentBuffer[i].tick != 0)
                {
                    _componentBuffer[i].component.Dispose();
                }
            }
        }
<#END#>

<#IF COPYABLE#>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Recycle()
        {
            for (int i = 0; i < _componentBuffer.Length; ++i)
            {
                if (_componentBuffer[i].tick != 0)
                {
                    _componentBuffer[i].component.OnRecycle();
                }
            }
        }
<#END#>

        #region Push methods

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void PushIsValue(bool isValue)
        {
            ref var element = ref _isValueBuffer[_isValueIndex++];
            element.tick = Tick;
            element.value = isValue;

            HistoryUtils.CheckAndResizeLoopBuffer(ref _isValueIndex, ref _isValueBuffer, _recordHistoryLength, nameof(_isValueBuffer));
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void PushValue(ref T data)
        {
            ref var element = ref _componentBuffer[_componentIndex];
<#IF COPYABLE#>
            if (element.tick != 0)
            {
                element.OnRecycle();
            }
<#END#>
            element.tick = Tick;
            element.component = data;

            ++_componentIndex;

            HistoryUtils.CheckAndResizeLoopBuffer(ref _componentIndex, ref _componentBuffer, _recordHistoryLength, nameof(_componentBuffer));
        }
        #endregion

        #region Revert methods
        <#IF ATTACH || DETACH#>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private void RevertToIsValueBuffer(uint tick, ref Pool<#POOL_TYPE#><T> subject)
        {
            var sparse = subject.GetIsValueRaw();
            _ops = 0;

            for (int i = _isValueIndex - 1; i >= 0; --i)
            {
                var frame = _isValueBuffer[i];

                if (frame.tick > tick)
                {
                    if (_ops != Op.BOTH)
                    {
                        if (sparse != frame.value)
                        {
                            _ops |= Op.BOTH;
                        }
                        else if (!sparse && frame.value)
                        {
                            _ops |= Op.ADD;
                        }
                        else if (sparse && !frame.value)
                        {
                            _ops = Op.REMOVE;
                        }
                    }

                    subject.SetIsValueRaw(frame.value);
                }
                else
                {
                    _isValueIndex = i + 1;
                    return;
                }
            }

           
            for (int i = _isValueBuffer.Length - 1; i >= _isValueIndex; --i)
            {
                var frame = _isValueBuffer[i];

                if (frame.tick > tick)
                {
                    if (_ops != Op.BOTH)
                    {
                        if (sparse != frame.value)
                        {
                            _ops |= Op.BOTH;
                        }
                        else if (!sparse && frame.value)
                        {
                            _ops |= Op.ADD;
                        }
                        else if (sparse && !frame.value)
                        {
                            _ops = Op.REMOVE;
                        }
                    }

                    subject.SetIsValueRaw(frame.value);
                }
                else
                {
                    _isValueIndex = (i + 1) % _isValueBuffer.Length;
                    return;
                }
            }
            
        }
<#ELSE#>
        private void RevertToIsValueBuffer(uint tick, ref Pool<#POOL_TYPE#><T> subject)
        {
            var isNeedContinueSearch = true;

            for (int i = _isValueIndex - 1; i >= 0; --i)
            {
                if (_isValueBuffer[i].tick <= tick)
                {
                    var lastIndex = i + 1;
                    if (i < _isValueIndex)
                    {
                        subject.SetIsValueRaw(_isValueBuffer[lastIndex].value);
                        _isValueIndex = lastIndex;
                        isNeedContinueSearch = false;
                    }
                    break;
                }
            }

            if (isNeedContinueSearch)
            {
                for (int i = _isValueBuffer.Length - 1; i >= _isValueIndex; --i)
                {
                    if (_isValueBuffer[i].tick <= tick)
                    {
                        var lastIndex = i + 1;
                        if (lastIndex < _isValueBuffer.Length)
                        {
                            subject.SetIsValueRaw(_isValueBuffer[lastIndex].value);
                            _isValueIndex = lastIndex;
                            isNeedContinueSearch = false;
                        }
                        break;
                    }
                }
            }

            if (isNeedContinueSearch)
            {
                subject.SetIsValueRaw(_isValueBuffer[_isValueIndex].value);
            }
        }
<#END#>
<#IF DETACH#>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private void DetachComponentRevert(ref Pool<#POOL_TYPE#><T> subject)
        {
            if ((_ops & Op.REMOVE) != 0)
            {
                ref var value = ref subject.GetValueRaw();
                value.OnDetach(_state);
            }
        }
<#END#>
<#IF ATTACH#>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private void AttachComponentRevert(ref Pool<#POOL_TYPE#><T> subject)
        {
            if ((_ops & Op.ADD) != 0)
            {
                ref var value = ref subject.GetValueRaw();
                value.OnAttach(_state);
            }
        }
<#END#>

        private void RevertToComponentBuffer(uint tick, ref Pool<#POOL_TYPE#><T> subject)
        {
            var isNeedContinueSearch = true;

            for (int i = _componentIndex - 1; i >= 0; --i)
            {
                if (_componentBuffer[i].tick <= tick)
                {
                    var lastIndex = i + 1;
                    if (i < _componentIndex)
                    {
                        subject.SetValueRaw(ref _componentBuffer[lastIndex].component);
                        _componentIndex = lastIndex;
                        isNeedContinueSearch = false;
                    }
                    break;
                }
            }

            if (isNeedContinueSearch)
            {
                for (int i = _componentBuffer.Length - 1; i >= _componentIndex; --i)
                {
                    if (_componentBuffer[i].tick <= tick)
                    {
                        var lastIndex = i + 1;
                        if (lastIndex < _componentBuffer.Length)
                        {
                            subject.SetValueRaw(ref _componentBuffer[lastIndex].component);
                            _componentIndex = lastIndex;
                            isNeedContinueSearch = false;
                        }
                        break;
                    }
                }
            }

            if (isNeedContinueSearch)
            {
                subject.SetValueRaw(ref _componentBuffer[_componentIndex].component);
            }
        }

        #endregion

<#IF INJECT#>
        public void ReInject(ref InjectContainer injectContainer, delegate*<ref T, ref InjectContainer, void> construct)
        {
            for (int i = 0, iMax = _componentBuffer.Length; i < iMax; ++i)
            {
                ref var element = ref _componentBuffer[i];
                if (element.tick != 0)
                {
                    construct(ref element.component, ref injectContainer);
                }
            }
        }
<#END#>

        public override void Pack(ref WriterContextSerializer writer)
        {
            base.Pack(ref writer);

            writer.Write(_isValueIndex);
            writer.WriteUnmanagedArray(_isValueBuffer);

            writer.Write(_componentIndex);
            writer.Pack(_componentBuffer);
<#IF BLITTABLE#>
            writer.WriteUnmanagedArray(_componentBuffer);
<#ELSE#>
            writer.Pack(_componentBuffer);
<#END#>
        }

        public override void Unpack(ref ReaderContextSerializer reader)
        {
            base.Unpack(ref reader);

            _isValueIndex = reader.ReadInt32();
            _isValueBuffer = reader.ReadUnmanagedArray<TickBoolData>();

            _componentIndex = reader.ReadInt32();
            _componentBuffer = reader.Unpack<ComponentData[]>();
<#IF BLITTABLE#>
            _componentBuffer = reader.ReadUnmanagedArray<ComponentData>();
<#ELSE#>
            _componentBuffer = reader.Unpack<ComponentData[]>();
<#END#>
        }

        #region Data declarations

        private struct ComponentData : IFrameData, ISerialize
        {
            public uint Tick
                => tick;

            public uint tick;
            public T component;

<#IF COPYABLE#>
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public void OnRecycle()
            {
                component.OnRecycle();
            }
<#END#>
            public void Pack(ref WriterContextSerializer writer)
            {
                writer.Write(tick);
                writer.WriteStruct(component);
            }

            public void Unpack(ref ReaderContextSerializer reader)
            {
                tick = reader.ReadUInt32();
                component = reader.ReadStruct<T>();
            }
        }
        #endregion
    }
}