// <auto-generated>
// This source code was auto-generated by HistoryGenerator.cs
// </auto-generated>

using AnotherECS.Core;
using AnotherECS.Serializer;
using System.Runtime.CompilerServices;
#if !ANOTHERECS_DEBUG
using Unity.Collections.LowLevel.Unsafe;
#endif

namespace AnotherECS.Gen.Common
{
#if ENABLE_IL2CPP
    [Unity.IL2CPP.CompilerServices.Il2CppSetOption (Option.NullChecks, false)]
    [Unity.IL2CPP.CompilerServices.Il2CppSetOption (Option.ArrayBoundsChecks, false)]
#endif
    public class Storage<#HISTORY_TYPE#>History<T> : History<#IF COPYABLE#>, IRecycleInternal<#END#>, ISerialize<#IF ATTACH || DETACH#>, IStateBindExternalInternal<#END#>
        where T : <#IF BLITTABLE#>unmanaged<#ELSE#>struct<#END#>, IComponent<#GENERIC_CONSTRAINTS#>
    {
        private int _isValueIndex;
        private TickData<bool>[] _isValueBuffer;

        private int _componentIndex;
        private ComponentData<T>[] _componentBuffer;

<#IF ATTACH || DETACH#>
        private State _state;
        private Op _ops;
<#END#>

        internal Storage<#HISTORY_TYPE#>History(ref ReaderContextSerializer reader, HistoryArgs args)
             : base(ref reader, args.tickProvider)
        { }

        public Storage<#HISTORY_TYPE#>History(in HistoryByChangeArgs args)
            : base(new HistoryArgs(args))
        {
            _isValueBuffer = new TickData<bool>[args.buffersAddRemoveCapacity];
            _componentBuffer = new ComponentData<T>[args.buffersChangeCapacity];
        }

<#IF ATTACH || DETACH#>
        public void BindExternal(State state)
        {
            _state = state;
        }
<#END#>

        public void RevertTo(uint tick, ref Storage<#STORAGE_TYPE#><T> subject)
        {
            RevertToIsValueBuffer(tick, ref subject);
<#IF DETACH#>
            DetachComponentRevert(ref subject);
<#END#>
            RevertToComponentBuffer(tick, ref subject);
<#IF ATTACH#>
            AttachComponentRevert(ref subject);
<#END#>
        }

<#IF DISPOSE#>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Dispose()
        {
            for (int i = 0; i < _componentBuffer.Length; ++i)
            {
                if (_componentBuffer[i].tick != 0)
                {
                    _componentBuffer[i].component.Dispose();
                }
            }
        }
<#END#>

<#IF COPYABLE#>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Recycle()
        {
            for (int i = 0; i < _componentBuffer.Length; ++i)
            {
                if (_componentBuffer[i].tick != 0)
                {
                    _componentBuffer[i].component.OnRecycle();
                }
            }
        }
<#END#>

        #region Push methods

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void PushIsValue(bool isValue)
        {
            ref var element = ref _isValueBuffer[_isValueIndex++];
            element.tick = Tick;
            element.value = isValue;

            HistoryUtils.CheckAndResizeLoopBuffer(ref _isValueIndex, ref _isValueBuffer, _recordHistoryLength, nameof(_isValueBuffer));
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void PushValue(ref T data)
        {
            ref var element = ref _componentBuffer[_componentIndex];
<#IF COPYABLE#>
            if (element.tick != 0)
            {
                element.component.OnRecycle();
            }
<#END#>
            element.tick = Tick;
            element.component = data;

            ++_componentIndex;

            HistoryUtils.CheckAndResizeLoopBuffer(ref _componentIndex, ref _componentBuffer, _recordHistoryLength, nameof(_componentBuffer));
        }
        #endregion

        #region Revert methods
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private void RevertToIsValueBuffer(uint tick, ref Storage<#STORAGE_TYPE#><T> subject)
        {
<#IF ATTACH || DETACH#>
            RevertHelper.RevertToSingleSparseBuffer(ref subject, tick, _isValueBuffer, ref _isValueIndex, out _ops); 
<#ELSE#>
            RevertHelper.RevertToSingleSparseBuffer(ref subject, tick, _isValueBuffer, ref _isValueIndex); 
<#END#>
        }
<#IF DETACH#>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private void DetachComponentRevert(ref Storage<#STORAGE_TYPE#><T> subject)
        {
            if ((_ops & Op.REMOVE) != 0)
            {
                ref var value = ref subject.GetSingleDenseRaw();
                value.OnDetach(_state);
            }
        }
<#END#>
<#IF ATTACH#>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private void AttachComponentRevert(ref Storage<#STORAGE_TYPE#><T> subject)
        {
            if ((_ops & Op.ADD) != 0)
            {
                ref var value = ref subject.GetSingleDenseRaw();
                value.OnAttach(_state);
            }
        }
<#END#>

        private void RevertToComponentBuffer(uint tick, ref Storage<#STORAGE_TYPE#><T> subject)
        {
            RevertHelper.RevertToSingleComponentBuffer(ref subject, tick, _componentBuffer, ref _componentIndex); 
        }

        #endregion

<#IF INJECT#>
        public void ReInject(ref InjectContainer injectContainer, delegate*<ref T, ref InjectContainer, void> construct)
        {
            for (int i = 0, iMax = _componentBuffer.Length; i < iMax; ++i)
            {
                ref var element = ref _componentBuffer[i];
                if (element.tick != 0)
                {
                    construct(ref element.component, ref injectContainer);
                }
            }
        }
<#END#>

        public override void Pack(ref WriterContextSerializer writer)
        {
            base.Pack(ref writer);

            writer.Write(_isValueIndex);
            writer.WriteUnmanagedArray(_isValueBuffer);

            writer.Write(_componentIndex);
<#IF BLITTABLE#>
            writer.WriteUnmanagedArray(_componentBuffer);
<#ELSE#>
            writer.Pack(_componentBuffer);
<#END#>
        }

        public override void Unpack(ref ReaderContextSerializer reader)
        {
            base.Unpack(ref reader);

            _isValueIndex = reader.ReadInt32();
            _isValueBuffer = reader.ReadUnmanagedArray<TickData<bool>>();

            _componentIndex = reader.ReadInt32();
<#IF BLITTABLE#>
            _componentBuffer = reader.ReadUnmanagedArray<ComponentData<T>>();
<#ELSE#>
            _componentBuffer = reader.Unpack<ComponentData[]>();
<#END#>
        }
    }
}