// <auto-generated>
// This source code was auto-generated by PoolGenerator.cs
// </auto-generated>

using System.Runtime.CompilerServices;
using System;
using AnotherECS.Core;
using AnotherECS.Serializer;
<#IF INJECT#>using AnotherECS.Unsafe;<#END#>
using EntityId = System.Int32;

namespace AnotherECS.Gen.Common
{
#if ENABLE_IL2CPP
    [Unity.IL2CPP.CompilerServices.Il2CppSetOption (Option.NullChecks, false)]
    [Unity.IL2CPP.CompilerServices.Il2CppSetOption (Option.ArrayBoundsChecks, false)]
#endif
    public <#IF INJECT#>unsafe <#END#>struct Pool<#POOL_TYPE#><T> : IEntityPool, IComponentFactory<T>, ISerialize<#IF INJECT#>, IInjectSupport<#END#>
        where T : <#IF BLITTABLE#>unmanaged<#ELSE#>struct<#END#>, IComponent<#GENERIC_CONSTRAINTS#>
    {
        private <#SPARSE:TYPE_NAME#>[] _sparse;
<#IF !EMPTY#>
        private T[] _dense;
<#END#>
<#IF !MARKER && !EMPTY#>
        private <#POOLDATA_INDEX:TYPE_NAME#>[] _recycled;
<#END#>
<#IF !EMPTY || VERSION#>
        private PoolData _data;
<#END#>
        private Type _elementType;
        private ushort _elementId;
<#IF VERSION#>
        private uint[] _version;
        private TickProvider _tickProvider;
<#END#>
<#IF INJECT#>
        private ushort _injectId;
        private InjectContainer _injectContainer;
        private delegate*<ref T, ref InjectContainer, void> _construct;
        private delegate*<ref T, ref InjectContainer, void> _deconstruct;
<#END#>
<#IF HISTORY#>
        private Pool<#HISTORY_TYPE#>History<T> _history;
<#END#>
<#IF ATTACH || DETACH#>
        private State _state;
<#END#>
        public Pool<#POOL_TYPE#>(ushort id, uint entityCapacity, uint componentCapacity<#CONSTRUCT_HISTORY#><#CONSTRUCT_VERSION#><#CONSTRUCT_INJECT#>)
        {
            _elementId = id;
            _sparse = new <#SPARSE:TYPE_NAME#>[entityCapacity + 1];
<#IF !EMPTY#>
---<#IF SPARSE:BOOL#>
            _dense = new T[entityCapacity + 1];
---<#ELSE#>
            _dense = new T[componentCapacity + 1];
---<#END#>
<#END#>
            _elementType = typeof(T);
<#IF !MARKER && !EMPTY#>
            _recycled = new <#POOLDATA_INDEX:TYPE_NAME#>[32];
<#END#>
<#IF !EMPTY || VERSION#>
            _data = new PoolData()
            {
                index = 1
            };
<#END#>
<#IF VERSION#>
---<#IF SPARSE:BOOL#>
            _version = new uint[entityCapacity + 1];
---<#ELSE#>
            _version = new uint[componentCapacity + 1];
---<#END#>
            _tickProvider = tickProvider;
<#END#>
<#IF HISTORY#>
            _history = history;
<#END#>
<#IF ATTACH || DETACH#>
            _state = null;
<#END#>
<#IF INJECT#>
            _injectContainer = injectContainer;
            var methods = (InjectMethods<T>)injectMethods;
            _injectId = methods.id;
            _construct = UnsafeUtils.ConvertToPointer(methods.construct);
            _deconstruct = UnsafeUtils.ConvertToPointer(methods.deconstruct);
<#END#>
        }

<#IF HISTORY#>
        public void BindExternal(IHistory history)
        {
            _history = (Pool<#HISTORY_TYPE#>History<T>)history;
        }
<#END#>

<#IF ATTACH || DETACH#>
        public void BindExternal(State state)
        {
            _state = state;
        }
<#END#>

<#IF INJECT#>
        public void BindInject(ref InjectContainer injectContainer, IInjectMethodsReference[] injectMethods)
        {
            var methods = (InjectMethods<T>)injectMethods[_injectId];
            _injectContainer = injectContainer;
            _injectId = methods.id;
            _construct = UnsafeUtils.ConvertToPointer(methods.construct);
            _deconstruct = UnsafeUtils.ConvertToPointer(methods.deconstruct);
        }

        public void ReInject()
        {
---<#IF SPARSE:BOOL#>
            for(int i = 1, iMax = _data.index; i < iMax; ++i)
            {
                if (_sparse[i])
                {
                    _construct(ref _dense[i], ref _injectContainer);
                }
            }
---<#ELSE#>
            int count = _data.index - 1;
            for(int i = 1, iMax = _sparse.Length; i < iMax; ++i)
            {
                if (_sparse[i] != 0)
                {
                    _construct(ref _dense[_sparse[i]], ref _injectContainer);
                    if (--count == 0)
                    {
                        break;
                    }
                }
            }
---<#END#>
---<#IF HISTORY#>
            _history.ReInject(ref _injectContainer, _construct);
---<#END#>
        }
<#END#>
<#IF ATTACH#>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Attach()
        {
---<#IF !EMPTY#>
------<#IF SPARSE:BOOL#>
            for(int i = 1, iMax = _data.index; i < iMax; ++i)
            {
                if (_sparse[i])
                {
                    _dense[i].OnAttach(_state);
                }
            }
------<#ELSE#>
            int count = _data.index - 1;
            for(int i = 1, iMax = _sparse.Length; i < iMax; ++i)
            {
                if (_sparse[i] != 0)
                {
                    _dense[_sparse[i]].OnAttach(_state);
                    if (--count == 0)
                    {
                        break;
                    }
                }
            }
------<#END#>
---<#ELSE#>
            default(T).OnAttach(_state);
---<#END#>
        }
<#END#>
<#IF DETACH#>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Detach()
        {
---<#IF !EMPTY#>
------<#IF SPARSE:BOOL#>
            for(int i = 1, iMax = _data.index; i < iMax; ++i)
            {
                if (_sparse[i])
                {
                    _dense[i].OnDetach(_state);
                }
            }
------<#ELSE#>
            int count = _data.index - 1;
            for(int i = 1, iMax = _sparse.Length; i < iMax; ++i)
            {
                if (_sparse[i] != 0)
                {
                    _dense[_sparse[i]].OnDetach(_state);
                    if (--count == 0)
                    {
                        break;
                    }
                }
            }
------<#END#>
---<#ELSE#>
            default(T).OnDetach(_state);
---<#END#>
        }
<#END#>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool IsHas(EntityId id)
<#IF SPARSE:BOOL#>
            => _sparse[id];
<#ELSE#>
            => _sparse[id] != 0;
<#END#>

<#IF !EMPTY || VERSION#>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryDenseResized()
        {
---<#IF SPARSE:BOOL#>
            return false;
---<#ELSE#>
------<#IF !EMPTY#>
            if (_data.index == _dense.Length)
------<#ELSE#>
            if (_data.index == _version.Length)
------<#END#>
            {
------<#IF !EMPTY#>
                Array.Resize(ref _dense, _data.index << 1);
------<#END#>
------<#IF VERSION#>
                Array.Resize(ref _version, _data.index << 1);
------<#END#>
                return true;
            }
            return false;
---<#END#>
        }
<#END#>

<#IF !EMPTY#>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Add(EntityId id, ref T data)
        {
            ref var component = ref AddInternal(id);
            component = data;
---<#IF ATTACH#>
            component.OnAttach(_state);
---<#END#>
        }

        public ref T Add(EntityId id)
        {
            ref var component = ref AddInternal(id);
---<#IF ATTACH#>
            component.OnAttach(_state);
---<#END#>
            return ref component;
        }
<#ELSE#>
        public void Add(EntityId id)
        {
            AddInternal(id);
---<#IF ATTACH#>
            default(T).OnAttach(_state);
---<#END#>
        }
<#END#>

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
<#IF !EMPTY#>
        private ref T AddInternal(EntityId id)
<#ELSE#>
        private void AddInternal(EntityId id)
<#END#>
        {
<#IF !EMPTY#>
            <#POOLDATA_INDEX:TYPE_NAME#> denseIndex;
<#END#>
<#IF !MARKER && !EMPTY#>
            ref var recycledCount = ref _data.recycle;
            if (recycledCount > 0)
            {
---<#IF HISTORY#>
                _history.PushRecycledCount(recycledCount);
---<#END#>
                denseIndex = _recycled[--recycledCount];
            }
            else
<#END#>
<#IF !EMPTY#>
            {
                ref var currentIndex = ref _data.index;
#if ANOTHERECS_DEBUG
                if (currentIndex == <#POOLDATA_INDEX:TYPE_NAME#>.MaxValue)
                {
                    throw new Exceptions.ReachedLimitComponentException(<#POOLDATA_INDEX:TYPE_NAME#>.MaxValue);
                }
#endif
                denseIndex = currentIndex;
---<#IF HISTORY#>
                _history.PushCount(currentIndex);
---<#END#>
                ++currentIndex;
            }

<#END#>
<#IF HISTORY#>
---<#IF SPARSE:BOOL#>
            _history.PushSparse(false, id);
---<#ELSE#>
            _history.PushSparse(0, id);
---<#END#>
<#END#>
<#IF SPARSE:BOOL#>
            _sparse[id] = true;
<#ELSE#>
            _sparse[id] = denseIndex;
<#END#>
<#IF VERSION#>
            _version[denseIndex] = _tickProvider.Tick;
<#END#>
<#IF INJECT#>
            _construct(ref _dense[denseIndex], ref _injectContainer);
<#END#>
<#IF !EMPTY#>
            return ref _dense[denseIndex];
<#END#>
        }

<#IF !EMPTY#>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ref readonly T Read(EntityId id)
---<#IF SPARSE:BOOL#>
            => ref _dense[id];
---<#ELSE#>
            => ref _dense[_sparse[id]];
---<#END#>

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ref T Get(EntityId id)
        {
---<#IF SPARSE:BOOL#>
            var denseIndex = (<#POOLDATA_INDEX:TYPE_NAME#>)id;
---<#ELSE#>
            var denseIndex = _sparse[id];
---<#END#>
            ref var component = ref _dense[denseIndex];
---<#IF VERSION#>
            _version[denseIndex] = _tickProvider.Tick;
---<#END#>
---<#IF HISTORY:BYCHANGE#>
------<#IF COPYABLE#>
            T copy = default; copy.CopyFrom(in component);
            _history.PushDense(ref copy, denseIndex);
------<#ELSE#>
            _history.PushDense(ref component, denseIndex);
------<#END#>
---<#END#>
            return ref component;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Set(EntityId id, ref T data)
        {
---<#IF SPARSE:BOOL#>
            var denseIndex = (<#POOLDATA_INDEX:TYPE_NAME#>)id;
---<#ELSE#>
            var denseIndex = _sparse[id];
---<#END#>
            ref var component = ref _dense[denseIndex];
---<#IF HISTORY:BYCHANGE#>
            _history.PushDense(ref component, denseIndex);
---<#END#>
            component = data;
---<#IF VERSION#>
            _version[denseIndex] = _tickProvider.Tick;
---<#END#>
        }
---<#IF !MARKER#>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryRecycledResized()
        {
            if (_data.recycle == _recycled.Length)
            {
                Array.Resize(ref _recycled, _data.recycle << 1);
                return true;
            }
            return false;
        }
---<#END#>

<#END#>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Remove(EntityId id)
        {
<#IF SPARSE:BOOL#>
            var denseIndex = (<#POOLDATA_INDEX:TYPE_NAME#>)id;
<#ELSE#>
            ref var denseIndex = ref _sparse[id];
<#END#>
<#IF !EMPTY#>
            ref var component = ref _dense[denseIndex];
<#END#>
<#IF !MARKER && !EMPTY#>
            ref var recycledCount = ref _data.recycle;
<#END#>
<#IF HISTORY:BYCHANGE#>
---<#IF !EMPTY#>
------<#IF !MARKER#>
            _history.PushRemove(ref component, denseIndex, id, _recycled[recycledCount], recycledCount);
------<#ELSE#>
            _history.PushRemove(ref component, denseIndex, id);
------<#END#>
---<#ELSE#>
            _history.PushSparse(denseIndex, id);
---<#END#>
<#END#>
<#IF HISTORY:BYTICK#>
---<#IF !MARKER#>
            _history.PushRemove(denseIndex, id, _recycled[recycledCount], recycledCount);
---<#ELSE#>
            _history.PushRemove(denseIndex, id);
---<#END#>
<#END#>
<#IF DETACH#>
---<#IF !EMPTY#>
            component.OnDetach(_state);
---<#ELSE#>
            default(T).OnDetach(_state);
---<#END#>
<#END#>

<#IF INJECT#>
            _deconstruct(ref component, ref _injectContainer);
<#END#>

<#IF !EMPTY#>
---<#IF COPYABLE && !HISTORY:BYCHANGE#>
            component.OnRecycle();
---<#ELSE#>
            component = default;
---<#END#>
<#END#>
<#IF !MARKER && !EMPTY#>
            _recycled[recycledCount++] = denseIndex;
<#END#>

<#IF SPARSE:BOOL#>
            _sparse[id] = false;
<#ELSE#>
            denseIndex = 0;
<#END#>
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Resize(int capacity)
        {
            Array.Resize(ref _sparse, capacity);
<#IF SPARSE:BOOL#>
---<#IF !EMPTY#>
            Array.Resize(ref _dense, capacity);
---<#END#>
---<#IF VERSION#>
            Array.Resize(ref _version, capacity);
---<#END#>
<#END#>
        }

<#IF VESRION#>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint GetVersion(EntityId id)
---<#IF SPARSE:BOOL#>
            => _version[id];
---<#ELSE#>
            => _version[_sparse[id]];
---<#END#>
<#END#>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ushort GetTypeId()
            => _elementId;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Type GetElementType()
            => _elementType;

<#IF HISTORY:BYTICK#>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void PushChanges()
            => _history.PushChange(_dense, _data.index);
<#END#>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Clear()
        {
            Reset();
<#IF !EMPTY#>
            Array.Clear(_dense, 1, _data.index);
<#END#>
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Reset()
        {
<#IF COPYABLE#>
            Recycle();
<#END#>
<#IF INJECT#>
            Deconstruct();
<#END#>
<#IF !EMPTY || VERSION#>
            _data.index = 1;
<#END#>
<#IF !MARKER && !EMPTY#>
            Array.Clear(_recycled, 0, _data.recycle);
            _data.recycle = 0;
<#END#>
            Array.Clear(_sparse, 1, _sparse.Length - 1);
        }
<#IF COPYABLE#>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Recycle()
        {
---<#IF SPARSE:BOOL#>
            for(int i = 1, iMax = _data.index; i < iMax; ++i)
            {
                if (_sparse[i])
                {
                    _dense[i].OnRecycle(_state);
                }
            }
---<#ELSE#>
            int count = _data.index - 1;
            for (int i = 1; i < _sparse.Length; ++i)
            {
                if (_sparse[i] != 0)
                {
                    _dense[_sparse[i]].OnRecycle();
                    if (--count == 0)
                    {
                        break;
                    }
                }
            }
---<#END#>
        }
<#END#>
<#IF INJECT#>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Deconstruct()
        {
---<#IF SPARSE:BOOL#>
            for(int i = 1, iMax = _data.index; i < iMax; ++i)
            {
                if (_sparse[i])
                {
                    _deconstruct(ref _dense[i], ref _injectContainer);
                }
            }
---<#ELSE#>
            int count = _data.index - 1;
            for (int i = 1; i < _sparse.Length; ++i)
            {
                if (_sparse[i] != 0)
                {
                    _deconstruct(ref _dense[_sparse[i]], ref _injectContainer);
                    if (--count == 0)
                    {
                        break;
                    }
                }
            }
---<#END#>
        }
<#END#>
<#IF DISPOSE#>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Dispose()
        {

        }
<#END#>
        public void SetRecycledCountRaw(ushort count)
<#IF !MARKER && !EMPTY#>
            => _data.recycle = count;
<#ELSE#>
            => throw new NotSupportedException();
<#END#>        

        public void SetDenseCountRaw(<#POOLDATA_INDEX:TYPE_NAME#> count)
<#IF !EMPTY#>
            => _data.index = count;
<#ELSE#>
            => throw new NotSupportedException();
<#END#>        

        public <#POOLDATA_INDEX:TYPE_NAME#>[] GetRecycledRaw()
<#IF !MARKER && !EMPTY#>
            => _recycled;
<#ELSE#>
            => throw new NotSupportedException();
<#END#>

        public void SetDenseRaw(T[] data)
<#IF !MARKER && !EMPTY#>
            => _dense = data;
<#ELSE#>    
            => throw new NotSupportedException();
<#END#>
        public <#SPARSE:TYPE_NAME#>[] GetSparseRaw()
            => _sparse;

        public T[] GetDenseRaw()
<#IF !MARKER && !EMPTY#>
            => _dense;
<#ELSE#>    
            => throw new NotSupportedException();
<#END#>

        public T Create()
        {
<#IF INJECT#>
            var component = new T();
            _construct(ref component, ref _injectContainer);
            return component;
<#ELSE#>
            return default;
<#END#>
        }

<#IF HISTORY#>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void RevertTo(uint tick)
            => _history.RevertTo(tick, ref this);
<#END#>

        public void Pack(ref WriterContextSerializer writer)
        {
<#IF INJECT#>
            writer.Write(_injectId);
<#END#>
            writer.WriteUnmanagedArray(_sparse);
<#IF !EMPTY && !MARKER#>
---<#IF BLITTABLE && !FORCE:ISerialize#>
            writer.WriteUnmanagedArray(_dense, _data.index);
---<#ELSE#>
            writer.WriteArray(_dense, _data.index);
---<#END#>
<#END#>
<#IF !MARKER && !EMPTY#>
            writer.WriteUnmanagedArray(_recycled);
<#END#>
<#IF !EMPTY || VERSION#>
            writer.WriteStruct(_data);
<#END#>
            writer.Write(_elementId);
<#IF VERSION#>
            writer.WriteUnmanagedArray(_version);
<#END#>
        }

        public void Unpack(ref ReaderContextSerializer reader)
        {
<#IF INJECT#>
            _injectId = reader.ReadUInt16();
<#END#>
            _sparse = reader.ReadUnmanagedArray<<#SPARSE:TYPE_NAME#>>();
<#IF !EMPTY && !MARKER#>
---<#IF BLITTABLE && !FORCE:ISerialize#>
            _dense = reader.ReadUnmanagedArray<T>();
---<#ELSE#>
            _dense = reader.ReadArray<T>();
---<#END#>
<#END#>
<#IF !MARKER && !EMPTY#>
            _recycled = reader.ReadUnmanagedArray<<#POOLDATA_INDEX:TYPE_NAME#>>();
<#END#>
<#IF !EMPTY || VERSION#>
            _data = reader.ReadStruct<PoolData>();
<#END#>
            _elementId = reader.ReadUInt16();
<#IF VERSION#>
            _version = reader.ReadUnmanagedArray<uint>();
<#END#>
            _elementType = typeof(T);
        }

<#IF !EMPTY#>
---<#IF DIRECTACCESS || REFERNCE_POOL#>
        private struct PoolData : ISerialize
---<#ELSE#>
        private class PoolData : ISerialize
---<#END#>
        {
---<#IF !MARKER#>
            public ushort recycle;
---<#END#>
            public <#POOLDATA_INDEX:TYPE_NAME#> index;

            public void Pack(ref WriterContextSerializer writer)
            {
                writer.Write(recycle);
                writer.WriteStruct(index);
            }

            public void Unpack(ref ReaderContextSerializer reader)
            {
                recycle = reader.ReadUInt16();
                index = reader.ReadStruct<<#POOLDATA_INDEX:TYPE_NAME#>>();
            }
        }
<#END#>
    }
}

